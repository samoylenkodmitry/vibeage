// Project Documentation
// Generated on: 2025-05-05T17:21:08.293Z
// This file contains the source code of all meaningful files in the project.



// ==============================================================================
// FILE: app/game/components/ActiveSkills.tsx
// ==============================================================================

'use client';

import { useEffect, useState, useCallback, JSX } from 'react';
import { useFrame } from '@react-three/fiber';
import { Vector3 } from 'three';
import { useGameStore } from '../systems/gameStore';
import { WaterSplash } from '../skills/WaterSplash';
import { PetrifyProjectile } from '../skills/Petrify';
import { SKILLS } from '../models/Skill';
import ProjectileVfx from '../vfx/ProjectileVfx';
import WaterProjectile from '../vfx/WaterProjectile';
import FireballProjectile from '../vfx/FireballProjectile';
import IceBoltProjectile from '../vfx/IceBoltProjectile';
import IceBoltVfx from '../vfx/IceBoltVfx';
import { PetrifyFlash } from '../vfx/PetrifyFlash';
import SplashVfx, { spawnSplashVfx, spawnStunFlash } from '../vfx/SplashVfx';
import { ProjSpawn2, ProjHit2, InstantHit } from '../../../shared/messages';
import { tryStartCast } from '../systems/castController';
import { SkillId } from '../../../shared/skillsDefinition';

// Type definitions
interface SkillEffect {
  id: string;
  skillId: string;
  startPosition: Vector3;
  targetPosition: Vector3;
  targetId: string;
  createdAtTs: number;
}

interface SkillTriggeredEvent {
  id: string;
  skillId: string;
  sourceId: string;
  targetId: string;
  startPosition: { x: number; y: number; z: number };
  targetPosition: { x: number; y: number; z: number };
  createdAtTs: number;
}

// Define interfaces for our component props
interface ProjectileProps {
  id: string;
  origin: { x: number; y: number; z: number };
  dir: { x: number; y: number; z: number };
  speed: number;
}

declare global {
  interface WindowEventMap {
    'skillTriggered': CustomEvent<SkillTriggeredEvent>;
    'requestPlayerPosition': CustomEvent<{
      effectId: string;
      callback: (position: { x: number; y: number; z: number }) => void;
    }>;
    // Legacy events removed
    'instanthit': CustomEvent<InstantHit>;
    'spawnSplash': CustomEvent<{ position: any; radius: number }>;
    'spawnStunFlash': CustomEvent<{ position: any }>;
    
    // New enhanced events
    'projspawn2': CustomEvent<ProjSpawn2>;
    'projhit2': CustomEvent<ProjHit2>;
  }
  
  interface Window {
    castFireball?: () => void;
    castIceBolt?: () => void;
    castWater?: () => void;
    castPetrify?: () => void;
  }
}

export default function ActiveSkills() {
  // Use a more stable selection from the store
  const myPlayerId = useGameStore(state => state.myPlayerId);
  const selectedTargetId = useGameStore(state => state.selectedTargetId);
  const socket = useGameStore(state => state.socket);
  
  // New state for projectiles
  const [projs, setProjs] = useState<Record<string, ProjSpawn2>>({});
  const [splashes, setSplashes] = useState<{id: string, position: any, radius: number}[]>([]);
  const [stunFlashes, setStunFlashes] = useState<{id: string, position: any}[]>([]);
  const [petrifyFlashes, setPetrifyFlashes] = useState<{id: string, position: any}[]>([]);
  
  // Listen for projectile events
  useEffect(() => {
    const spawn = (e: CustomEvent<ProjSpawn2>) => {
      console.log('Projectile spawn:', e.detail);
      
      // Ensure the projectile has an ID
      if (!e.detail.id) {
        e.detail.id = `proj-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
      }
      
      setProjs(p => ({...p, [e.detail.id]: e.detail}));
    };
    
    const end = (e: CustomEvent<{id: string}>) => {
      console.log('Projectile end:', e.detail);
      setProjs(p => {
        const q = {...p};
        delete q[e.detail.id];
        return q;
      });
    };
    
    const spawnSplash = (e: CustomEvent<{position: any, radius: number}>) => {
      const id = `splash-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
      setSplashes(s => [...s, { id, position: e.detail.position, radius: e.detail.radius }]);
      
      // Auto-remove splash after animation time
      setTimeout(() => {
        setSplashes(s => s.filter(splash => splash.id !== id));
      }, 1000);
    };
    
    const spawnFlash = (e: CustomEvent<{position: any}>) => {
      const id = `flash-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
      setStunFlashes(s => [...s, { id, position: e.detail.position }]);
      
      // Auto-remove flash after animation time
      setTimeout(() => {
        setStunFlashes(s => s.filter(flash => flash.id !== id));
      }, 500);
    };
    
    const spawnPetrifyFlash = (e: CustomEvent<{position: any}>) => {
      const id = `petrify-flash-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
      setPetrifyFlashes(s => [...s, { id, position: e.detail.position }]);
      
      // Auto-remove flash after animation time
      setTimeout(() => {
        setPetrifyFlashes(s => s.filter(flash => flash.id !== id));
      }, 500);
    };
    
    const hit = (e: CustomEvent<any>) => {
      console.log('Hit event:', e.detail);
      
      // Remove the projectile from state
      if ('id' in e.detail) {
        setProjs(p => {
          const q = {...p};
          delete q[e.detail.id];
          return q;
        });
      }
      
      // Handle hit effects for specific skills
      if ('skillId' in e.detail) {
        let position;
        if ('impactPos' in e.detail) {
          position = { x: e.detail.impactPos.x, y: 1.5, z: e.detail.impactPos.z }; // ProjHit2
        } else if ('targetPos' in e.detail) {
          position = e.detail.targetPos; // InstantHit
        }
        
        if (position) {
          // Create different effects based on skill type
          switch (e.detail.skillId) {
            case 'waterSplash':
              // Create a water splash effect
              window.dispatchEvent(new CustomEvent('spawnSplash', {
                detail: {
                  position: new Vector3(position.x, position.y, position.z),
                  radius: 2
                }
              }));
              break;
              
            case 'fireball':
              // Create a fire explosion effect
              window.dispatchEvent(new CustomEvent('spawnSplash', {
                detail: {
                  position: new Vector3(position.x, position.y, position.z),
                  radius: 1.5
                }
              }));
              break;
              
            case 'icebolt':
              // Create an ice shatter effect
              window.dispatchEvent(new CustomEvent('spawnSplash', {
                detail: {
                  position: new Vector3(position.x, position.y, position.z),
                  radius: 1
                }
              }));
              break;
              
            case 'petrify':
              // Create a stun flash effect
              window.dispatchEvent(new CustomEvent('spawnStunFlash', {
                detail: {
                  position: new Vector3(position.x, position.y, position.z)
                }
              }));
              break;
          }
        }
      }
    };
    
    window.addEventListener('projspawn2', spawn as EventListener);
    window.addEventListener('projhit2', hit as EventListener);
    window.addEventListener('instanthit', hit as EventListener);
    window.addEventListener('spawnSplash', spawnSplash as EventListener);
    window.addEventListener('spawnStunFlash', spawnFlash as EventListener);
    window.addEventListener('petrifyFlash', spawnPetrifyFlash as EventListener);
    
    return () => {
      window.removeEventListener('projspawn2', spawn as EventListener);
      window.removeEventListener('projhit2', hit as EventListener);
      window.removeEventListener('instanthit', hit as EventListener);
      window.removeEventListener('spawnSplash', spawnSplash as EventListener);
      window.removeEventListener('spawnStunFlash', spawnFlash as EventListener);
      window.removeEventListener('petrifyFlash', spawnPetrifyFlash as EventListener);
    };
  }, []);
  
  // For debugging - expose global methods to manually trigger skills
  useEffect(() => {
    const castSkill = (skillId: SkillId) => {
      // Use the imported tryStartCast function
      tryStartCast(skillId, selectedTargetId || undefined);
    };
    
    window.castFireball = () => castSkill('fireball' as SkillId);
    window.castIceBolt = () => castSkill('icebolt' as SkillId);
    window.castWater = () => castSkill('waterSplash' as SkillId); // Changed from 'water' to 'waterSplash'
    window.castPetrify = () => castSkill('petrify' as SkillId);
    
    return () => {
      window.castFireball = undefined;
      window.castIceBolt = undefined;
      window.castWater = undefined;
      window.castPetrify = undefined;
    };
  }, [selectedTargetId]);
  
  // VFX registry for skill components
  const vfxTable: Record<string, (props: ProjectileProps) => JSX.Element> = {
    fireball: FireballProjectile,
    icebolt: IceBoltVfx,
    waterSplash: WaterProjectile,
    petrify: ProjectileVfx, // Using generic projectile for now
    // Add more skills as they are implemented
  };
  
  // Render projectiles, splashes, and stun flashes
  return (
    <group>
      {/* Render all active projectiles */}
      {Object.values(projs).map((p) => {
        // Skip rendering if required props are missing
        if (!p.id) {
          console.warn('Skipping projectile with undefined id');
          return null;
        }
        
        console.log('Rendering projectile:', p.id, 'skillId:', p.skillId);
        
        // Convert skillId to a safe string key for the vfxTable
        const skillIdKey = p.skillId?.toString() || '';
        
        // Convert 2D vectors to 3D vectors with y=0 for this specific projectile
        const origin3D = {
          x: p.origin.x, 
          y: 0, // Default height for projectiles
          z: p.origin.z
        };
        
        const dir3D = {
          x: p.dir.x,
          y: 0, // No vertical component
          z: p.dir.z
        };
        
        // Use the VFX component from our registry
        const VfxComponent = vfxTable[skillIdKey];
        
        if (VfxComponent) {
          return (
            <VfxComponent 
              key={p.id || `proj-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`} 
              id={p.id || `proj-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`} 
              origin={origin3D} 
              dir={dir3D} 
              speed={p.speed}
            />
          );
        }
        
        // Fallback to default if not found in registry
        return (
          <ProjectileVfx 
            key={p.id || `proj-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`} 
            id={p.id || `proj-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`} 
            origin={origin3D} 
            dir={dir3D} 
            speed={p.speed}
          />
        );
      })}
      
      {/* Render splash effects */}
      {splashes.map(splash => (
        <SplashVfx 
          key={splash.id} 
          position={splash.position} 
          radius={splash.radius} 
        />
      ))}
      
      {/* Keep existing stun flash for petrify - replace with custom VFX later */}
      {stunFlashes.map(flash => (
        <mesh 
          key={flash.id} 
          position={[flash.position.x, flash.position.y + 1.5, flash.position.z]}
        >
          <sphereGeometry args={[0.4, 16, 16]} />
          <meshBasicMaterial color={'yellow'} transparent={true} opacity={0.8} />
        </mesh>
      ))}
      
      {/* Render petrify flash effects */}
      {petrifyFlashes.map(flash => (
        <PetrifyFlash 
          key={flash.id} 
          pos={flash.position} 
        />
      ))}
    </group>
  );
}

// ==============================================================================
// FILE: app/game/components/ConnectionStatus.tsx
// ==============================================================================

'use client';

import React, { useEffect, useState } from 'react';
import { useGameStore } from '../systems/gameStore';

const ConnectionStatus: React.FC = () => {
  const isConnected = useGameStore(state => state.isConnected);
  const lastConnectionChangeTs = useGameStore(state => state.lastConnectionChangeTs);
  const [showNotification, setShowNotification] = useState(false);
  
  // Show notification for 3 seconds when connection status changes
  useEffect(() => {
    setShowNotification(true);
    const timer = setTimeout(() => {
      setShowNotification(false);
    }, 3000);
    
    return () => clearTimeout(timer);
  }, [lastConnectionChangeTs]);
  
  // Format time since connection change
  const getTimeSinceMs = () => {
    const elapsedMs = Date.now() - lastConnectionChangeTs;
    if (elapsedMs < 60000) return `${Math.floor(elapsedMs / 1000)}s ago`;
    if (elapsedMs < 3600000) return `${Math.floor(elapsedMs / 60000)}m ago`;
    return `${Math.floor(elapsedMs / 3600000)}h ago`;
  };
  
  return (
    <div className="connection-status">
      {/* Always visible status indicator */}
      <div 
        className={`connection-indicator ${isConnected ? 'connected' : 'disconnected'}`}
        title={`Server ${isConnected ? 'Connected' : 'Disconnected'} (${getTimeSinceMs()})`}
      >
        <div className="status-dot"></div>
        <span className="status-text">{isConnected ? 'Online' : 'Offline'}</span>
      </div>
      
      {/* Notification that fades away */}
      {showNotification && (
        <div className={`status-notification ${isConnected ? 'connected' : 'disconnected'}`}>
          Server {isConnected ? 'Connected' : 'Disconnected'}
        </div>
      )}
      
      <style jsx>{`
        .connection-status {
          position: fixed;
          bottom: 10px;
          right: 10px;
          z-index: 100;
        }
        
        .connection-indicator {
          display: flex;
          align-items: center;
          padding: 4px 10px;
          border-radius: 12px;
          font-size: 12px;
          font-weight: bold;
          background-color: rgba(0, 0, 0, 0.7);
          color: white;
        }
        
        .status-dot {
          width: 8px;
          height: 8px;
          border-radius: 50%;
          margin-right: 5px;
        }
        
        .connected .status-dot {
          background-color: #4CAF50;
          box-shadow: 0 0 5px #4CAF50;
        }
        
        .disconnected .status-dot {
          background-color: #F44336;
          box-shadow: 0 0 5px #F44336;
        }
        
        .status-notification {
          position: absolute;
          bottom: 100%;
          right: 0;
          margin-bottom: 10px;
          padding: 8px 15px;
          border-radius: 4px;
          font-size: 14px;
          font-weight: 500;
          animation: fadeOut 3s forwards;
          white-space: nowrap;
        }
        
        .status-notification.connected {
          background-color: rgba(76, 175, 80, 0.9);
          color: white;
        }
        
        .status-notification.disconnected {
          background-color: rgba(244, 67, 54, 0.9);
          color: white;
        }
        
        @keyframes fadeOut {
          0% { opacity: 1; }
          70% { opacity: 1; }
          100% { opacity: 0; }
        }
      `}</style>
    </div>
  );
};

export default ConnectionStatus;


// ==============================================================================
// FILE: app/game/components/DebugPanel.tsx
// ==============================================================================

'use client';

import { useState, useEffect } from 'react';
import { useGameStore, selectEnemyCount } from '../systems/gameStore';

export default function DebugPanel() {
  const [isVisible, setIsVisible] = useState(false);
  const enemyCount = useGameStore(selectEnemyCount);
  const enemies = useGameStore(state => state.enemies);
  const isConnected = useGameStore(state => state.isConnected);
  const myPlayerId = useGameStore(state => state.myPlayerId);
  
  // Toggle visibility with ~ key
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === '`' || e.key === '~') {
        setIsVisible(prev => !prev);
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);
  
  if (!isVisible) return null;
  
  return (
    <div className="fixed top-0 right-0 bg-black/80 text-white p-4 m-4 rounded-lg z-50 max-w-md max-h-[80vh] overflow-auto">
      <h2 className="text-xl font-bold mb-2">Debug Info</h2>
      <div className="space-y-2 text-sm">
        <p>Connection: <span className={isConnected ? "text-green-500" : "text-red-500"}>{isConnected ? "Connected" : "Disconnected"}</span></p>
        <p>Player ID: {myPlayerId || "Not assigned"}</p>
        <p>Enemy Count: {enemyCount}</p>
        
        <div className="mt-4">
          <h3 className="text-lg font-semibold mb-1">Enemies:</h3>
          {enemyCount > 0 ? (
            <ul className="space-y-1">
              {Object.entries(enemies).map(([id, enemy]) => (
                <li key={id} className="text-xs">
                  {enemy.name} (Lv.{enemy.level}) - Health: {enemy.health}/{enemy.maxHealth} - 
                  Pos: [{Math.round(enemy.position.x)}, {Math.round(enemy.position.y)}, {Math.round(enemy.position.z)}]
                </li>
              ))}
            </ul>
          ) : (
            <p className="text-yellow-500">No enemies found in game state</p>
          )}
        </div>
        
        <div className="mt-4">
          <button 
            className="bg-blue-600 hover:bg-blue-700 text-white px-2 py-1 rounded text-xs"
            onClick={() => {
              const socket = useGameStore.getState().socket;
              if (socket) {
                console.log('Requesting fresh game state');
                socket.emit('requestGameState');
              }
            }}
          >
            Request Game State
          </button>
        </div>
      </div>
    </div>
  );
}


// ==============================================================================
// FILE: app/game/components/Enemies.tsx
// ==============================================================================

'use client';

import { useFrame } from '@react-three/fiber';
import { useState, useRef } from 'react';
import { RigidBody } from '@react-three/rapier';
import { Html } from '@react-three/drei';
import { Vector3 } from 'three';
import * as THREE from 'three';
import { useGameStore } from '../systems/gameStore';
import { zoneManager } from '../systems/zoneSystem';

interface Position {
  x: number;
  y: number;
  z: number;
}

export default function Enemies() {
  const enemies = useGameStore(state => state.enemies);
  const selectedTargetId = useGameStore(state => state.selectedTargetId);
  const selectTarget = useGameStore(state => state.selectTarget);

  // Convert enemies object to array
  const enemiesArray = Object.values(enemies);

  useFrame(() => {
    // Enemy AI and movement logic here
  });

  return (
    <group>
      {enemiesArray.map((enemy) => (
        <Enemy 
          key={enemy.id}
          enemy={enemy}
          isSelected={selectedTargetId === enemy.id}
          onSelect={() => selectTarget(enemy.id)}
        />
      ))}
    </group>
  );
}

interface EnemyProps {
  enemy: any;
  isSelected: boolean;
  onSelect: () => void;
}

function Enemy({ enemy, isSelected, onSelect }: EnemyProps) {
  const meshRef = useRef<THREE.Mesh>(null);
  const { id, type, position, health, maxHealth, isAlive, name, level } = enemy;
  const [isHovered, setIsHovered] = useState(false);
  const originalPosition = useRef(new Vector3(enemy.position.x, enemy.position.y, enemy.position.z));
  const currentZone = useRef(zoneManager.getZoneAtPosition(enemy.position));
  
  // Different models for different enemy types
  const getEnemyModel = () => {
    switch (type) {
      case 'goblin':
        return <GoblinModel isSelected={isSelected} isHovered={isHovered} />;
      case 'wolf':
        return <WolfModel isSelected={isSelected} isHovered={isHovered} />;
      case 'skeleton':
        return <SkeletonModel isSelected={isSelected} isHovered={isHovered} />;
      default:
        return <DefaultEnemyModel isSelected={isSelected} isHovered={isHovered} />;
    }
  };

  if (!isAlive) return null;
  
  // Get proper capitalized mob name
  const getMobName = (type: string) => {
    return type.charAt(0).toUpperCase() + type.slice(1);
  };
  
  return (
    <RigidBody type="fixed" position={[position.x, position.y, position.z]}>
      {/* Clickable area */}
      <mesh 
        ref={meshRef}
        onClick={(e) => {
          e.stopPropagation();
          onSelect();
        }}
        onPointerOver={(e) => {
          e.stopPropagation();
          document.body.style.cursor = 'pointer';
          setIsHovered(true);
        }}
        onPointerOut={(e) => {
          e.stopPropagation();
          document.body.style.cursor = 'default';
          setIsHovered(false);
        }}
      >
        <sphereGeometry args={[1.2, 8, 8]} />
        <meshBasicMaterial transparent opacity={0} />
      </mesh>
      
      {/* Enemy model */}
      {getEnemyModel()}
      
      {/* Health bar and name tag */}
      <Html position={[0, 2.5, 0]} center sprite>
        <div className="flex flex-col items-center pointer-events-none">
          <div className={`text-white text-xs font-medium bg-black/50 px-2 py-1 rounded mb-1 ${isSelected ? 'ring-2 ring-red-500' : ''}`}>
            {`${getMobName(type)} Lv.${level}`}
          </div>
          <div className="w-16 h-1.5 bg-gray-800 rounded-full overflow-hidden">
            <div
              className="h-full bg-red-600"
              style={{ width: `${(health / maxHealth) * 100}%` }}
            />
          </div>
        </div>
      </Html>
      
      {/* Selection indicator */}
      {isSelected && (
        <mesh position={[0, 0.1, 0]} rotation={[-Math.PI / 2, 0, 0]}>
          <ringGeometry args={[1.4, 1.6, 32]} />
          <meshBasicMaterial color="#ff0000" transparent opacity={0.6} />
        </mesh>
      )}
    </RigidBody>
  );
}

// Enhanced enemy models with selection/hover feedback

interface ModelProps {
  isSelected: boolean;
  isHovered: boolean;
}

function GoblinModel({ isSelected, isHovered }: ModelProps) {
  const baseColor = "#4a7c59";
  const hoverColor = "#5d8e6b";
  const selectedColor = "#6aaa7e";
  
  const color = isSelected ? selectedColor : (isHovered ? hoverColor : baseColor);
  
  return (
    <group>
      <mesh position={[0, 0.5, 0]} castShadow>
        <boxGeometry args={[0.6, 1.0, 0.6]} />
        <meshStandardMaterial color={color} />
      </mesh>
      <mesh position={[0, 1.2, 0]} castShadow>
        <sphereGeometry args={[0.4, 16, 16]} />
        <meshStandardMaterial color={color} />
      </mesh>
    </group>
  );
}

function WolfModel({ isSelected, isHovered }: ModelProps) {
  const baseColor = "#6e6e6e";
  const hoverColor = "#808080";
  const selectedColor = "#9a9a9a";
  
  const color = isSelected ? selectedColor : (isHovered ? hoverColor : baseColor);
  
  return (
    <group>
      <mesh position={[0, 0.5, 0]} rotation={[0, 0, Math.PI / 2]} castShadow>
        <capsuleGeometry args={[0.4, 1.0, 8, 16]} />
        <meshStandardMaterial color={color} />
      </mesh>
      <mesh position={[0.8, 0.5, 0]} castShadow>
        <boxGeometry args={[0.6, 0.3, 0.5]} />
        <meshStandardMaterial color={color} />
      </mesh>
    </group>
  );
}

function SkeletonModel({ isSelected, isHovered }: ModelProps) {
  const baseColor = "#d8d8d0";
  const hoverColor = "#e5e5dc";
  const selectedColor = "#f2f2ea";
  
  const color = isSelected ? selectedColor : (isHovered ? hoverColor : baseColor);
  
  return (
    <group>
      <mesh position={[0, 0.8, 0]} castShadow>
        <boxGeometry args={[0.6, 1.6, 0.3]} />
        <meshStandardMaterial color={color} />
      </mesh>
      <mesh position={[0, 1.8, 0]} castShadow>
        <sphereGeometry args={[0.4, 16, 16]} />
        <meshStandardMaterial color={color} />
      </mesh>
    </group>
  );
}

function DefaultEnemyModel({ isSelected, isHovered }: ModelProps) {
  const baseColor = "#8B0000";
  const hoverColor = "#A52A2A";
  const selectedColor = "#DC143C";
  
  const color = isSelected ? selectedColor : (isHovered ? hoverColor : baseColor);
  
  return (
    <mesh position={[0, 1, 0]} castShadow>
      <boxGeometry args={[1, 2, 1]} />
      <meshStandardMaterial color={color} />
    </mesh>
  );
}

// Helper function to get health bar color based on percentage
function getHealthColor(percentage: number): string {
  if (percentage > 0.6) return '#00ff00';
  if (percentage > 0.3) return '#ffff00';
  return '#ff0000';
}

// Helper function to get zone indicator color
function getZoneColor(zoneId: string): string {
  const colors: { [key: string]: string } = {
    starter_meadow: '#90EE90', // Light green
    dark_forest: '#228B22',    // Forest green
    rocky_highlands: '#A0522D', // Brown
    misty_lake: '#4682B4'      // Steel blue
  };
  return colors[zoneId] || '#FFFFFF';
}

// ==============================================================================
// FILE: app/game/components/Game.tsx
// ==============================================================================

'use client';

import { Canvas } from '@react-three/fiber';
import { Physics } from '@react-three/rapier';
import { Sky, KeyboardControls } from '@react-three/drei';
import { useEffect, useState, useCallback, useRef } from 'react';
import World from './World';
import Player from './Player';
import Enemies from './Enemies';
import UI from './UI';
import KeyboardShortcuts from './KeyboardShortcuts';
import ActiveSkills from './ActiveSkills';
import TargetRing from './TargetRing';
import { useGameStore } from '../systems/gameStore';
import SocketManager from '../systems/SocketManager';

// Define keyboard controls
const controls = [
  { name: 'forward', keys: ['ArrowUp', 'KeyW'] },
  { name: 'backward', keys: ['ArrowDown', 'KeyS'] },
  { name: 'left', keys: ['ArrowLeft', 'KeyA'] },
  { name: 'right', keys: ['ArrowRight', 'KeyD'] },
  { name: 'jump', keys: ['Space'] },
  { name: 'fireball', keys: ['Digit1', 'KeyQ'] },
  { name: 'icebolt', keys: ['Digit2', 'KeyE'] },
  { name: 'waterSplash', keys: ['Digit3', 'KeyR'] },
  { name: 'petrify', keys: ['Digit4', 'KeyF'] },
];

export default function Game() {
  const [isGameStarted, setGameStarted] = useState(false);
  const [playerName, setPlayerName] = useState('');
  const [joiningError, setJoiningError] = useState<string | null>(null);
  const isConnected = useGameStore(state => state.isConnected);
  const socket = useGameStore(state => state.socket);
  const hasJoinedGame = useGameStore(state => state.hasJoinedGame);
  const setHasJoinedGame = useGameStore(state => state.setHasJoinedGame);

  useEffect(() => {
    if (isGameStarted && socket && isConnected && playerName.trim() && !hasJoinedGame) {
      console.log('Joining game with player name:', playerName);
      socket.emit('joinGame', playerName);
      setJoiningError(null);
      setHasJoinedGame(true);
    }
  }, [isGameStarted, socket, isConnected, playerName, hasJoinedGame, setHasJoinedGame]);

  const handleStartGame = useCallback(() => {
    if (playerName.trim()) {
      if (!isConnected) {
        setJoiningError('Waiting for server connection...');
      }
      setGameStarted(true);
    }
  }, [playerName, isConnected]);

  if (!isGameStarted) {
    return (
      <div className="w-full h-screen flex items-center justify-center bg-black">
        <div className="bg-gray-900 p-8 rounded-lg max-w-md w-full">
          <h1 className="text-4xl font-bold mb-6 text-purple-500">
            VibeAge
          </h1>
          <p className="text-gray-300 mb-6">
            Enter the world of magic and combat. Defeat enemies, level up, and unlock powerful spells in this Lineage-inspired MMORPG!
          </p>
          <div className="mb-4">
            <label htmlFor="name" className="block text-sm font-medium text-gray-300 mb-2">
              Character Name
            </label>
            <input
              type="text"
              id="name"
              value={playerName}
              onChange={(e) => setPlayerName(e.target.value)}
              className="w-full px-4 py-2 rounded bg-gray-800 text-white focus:outline-none focus:ring-2 focus:ring-purple-500"
              placeholder="Enter your character name"
            />
          </div>
          <button
            onClick={handleStartGame}
            className="w-full py-2 px-4 bg-purple-600 hover:bg-purple-700 text-white font-medium rounded transition-colors"
          >
            Enter the World
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="relative w-full h-full">
      <SocketManager />
      <KeyboardShortcuts />
      <KeyboardControls map={controls}>
        <Canvas 
          className="w-full h-screen"
          shadows
          frameloop="always"
          performance={{ min: 0.5 }}
        >
          <fog attach="fog" args={['#202060', 0, 100]} />
          <ambientLight intensity={0.5} />
          <directionalLight
            position={[10, 10, 10]}
            intensity={0.8}
            castShadow
            shadow-mapSize={[2048, 2048]}
          />
          <Physics>
            <World />
            <Player />
            <Enemies />
            <ActiveSkills />
            <TargetRing />
          </Physics>
        </Canvas>
      </KeyboardControls>
      <UI />
    </div>
  );
}

// ==============================================================================
// FILE: app/game/components/HUD/CombatLog.tsx
// ==============================================================================

import { useCombatLogStore } from '../../stores/useCombatLogStore';
import { useEffect, useState } from 'react';

export default function CombatLog() {
  const list = useCombatLogStore(s => s.list);

  // to fade after 6s
  const [now, setNow] = useState(Date.now());
  useEffect(() => {
    const t = setInterval(() => setNow(Date.now()), 1000);
    return () => clearInterval(t);
  }, []);

  return (
    <div 
      data-testid="combat-log"
      className="absolute left-2 bottom-2 w-72 text-xs font-mono pointer-events-none"
    >
      {list.slice(-20).map(e => {
        const age = now - e.ts;
        const op = age > 6000 ? 0 : 1 - age/6000;
        
        // Don't render entries that are completely faded out
        if (op <= 0) return null;
        
        return (
          <div 
            key={e.id}
            data-testid="log-entry"
            style={{opacity: op}}
            className="leading-4 text-white drop-shadow-sm"
          >
            {e.text}
          </div>
        );
      })}
    </div>
  );
}


// ==============================================================================
// FILE: app/game/components/KeyboardShortcuts.tsx
// ==============================================================================

'use client';

import { useEffect } from 'react';
import { useGameStore } from '../systems/gameStore';
import { validateSkillId } from '../systems/skillUtils';
import { tryStartCast } from '../systems/castController';

/**
 * Component that handles keyboard shortcuts for the game
 * This component doesn't render anything but sets up event listeners
 */
export default function KeyboardShortcuts() {
  // We no longer need the game store's handleSkillHotkey
  const getMyPlayer = useGameStore(state => state.getMyPlayer);
  
  useEffect(() => {
    // Add keyboard event listener for skill shortcuts
    const handleKeyDown = (e: KeyboardEvent) => {
      // Skip if input or textarea is focused
      if (document.activeElement instanceof HTMLInputElement || 
          document.activeElement instanceof HTMLTextAreaElement) {
        return;
      }
      
      // Toggle combat log with L key
      if (e.key === 'l' || e.key === 'L') {
        document.body.classList.toggle('hide-combat-log');
        console.log('Combat log toggled with L key');
        return;
      }
      
      // Only handle number keys 1-9
      if (e.key >= '1' && e.key <= '9') {
        console.log(`Key pressed: ${e.key}`);
        
        const player = getMyPlayer();
        if (!player || !player.skillShortcuts) return;
        
        // Convert key to index (keys 1-9 map to array indices 0-8)
        const keyNum = parseInt(e.key);
        if (isNaN(keyNum) || keyNum < 1 || keyNum > 9) return;
        
        const shortcutIndex = keyNum - 1;
        const skillId = player.skillShortcuts[shortcutIndex];
        
        if (skillId && validateSkillId(skillId)) {
          console.log(`Using skill hotkey ${keyNum} to cast ${skillId}`);
          // Use the new unified cast controller instead of the game store method
          tryStartCast(skillId);
        }
      }
    };
    
    // Add the event listener
    window.addEventListener('keydown', handleKeyDown);
    
    // Remove event listener on cleanup
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [getMyPlayer]);
  
  // This component doesn't render anything
  return null;
}


// ==============================================================================
// FILE: app/game/components/Player.tsx
// ==============================================================================

import React, { useRef, useEffect, useState, useCallback } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import { RigidBody, CapsuleCollider, useRapier } from '@react-three/rapier';
import { Vector3, Euler, Raycaster, Plane, Mesh, Vector2 } from 'three';
import { useGameStore, selectPlayerIds, selectMyPlayerId, selectPlayer } from '../systems/gameStore';
import { simulateMovement, GROUND_Y } from '../systems/moveSimulation';
import { VecXZ } from '../../../shared/messages';
import { SnapBuffer } from '../systems/interpolation';

// Movement constants
const BASE_SPEED = 20;
const SPRINT_MUL = 1.5;

// Individual Player Component
function PlayerCharacter({ playerId, isControlledPlayer }: { playerId: string, isControlledPlayer: boolean }) {
  const playerRef = useRef<any>(null);
  const playerState = useGameStore(selectPlayer(playerId));
  const lastUpdateTimeTs = useRef<number | null>(null);
  const socket = useGameStore(state => state.socket);

  // --- Remote Player Interpolation ---
  const previousPositionRef = useRef(new Vector3());
  const targetPositionRef = useRef(new Vector3());
  const previousRotationRef = useRef(0);
  const targetRotationRef = useRef(0);
  const lastPositionUpdateTimeRef = useRef(0);
  const interpolationAlphaRef = useRef(0);
  
  // --- Snapshot interpolation with SnapBuffer ---
  const snapBufferRef = useRef<SnapBuffer | null>(null);
  
  // --- Controlled Player Reconciliation ---
  const pendingCorrectionRef = useRef(false);
  const serverCorrectionPositionRef = useRef(new Vector3());
  const correctionStartTimeRef = useRef(0);
  const correctionDurationRef = useRef(300); // ms
  
  // --- Hooks and State specific to the controlled player ---
  const { camera, gl, raycaster } = useThree();
  const { rapier, world } = useRapier();
  const [isGrounded, setIsGrounded] = useState(false);
  const [hasJumped, setHasJumped] = useState(false);
  const [targetPosition, setTargetPosition] = useState<Vector3 | null>(null);
  const movementStartTimeTs = useRef<number | null>(null);
  const lastDistanceToTarget = useRef<number>(Infinity);
  const stuckCounter = useRef(0);
  const [isRotating, setIsRotating] = useState(false);
  const previousMousePosition = useRef({ x: 0, y: 0 });
  const cameraAngleRef = useRef(Math.PI);
  const cameraInitialized = useRef(false);
  const groundPlane = new Plane(new Vector3(0, 1, 0), -GROUND_Y);
  const moveDirection = useRef({ forward: 0, right: 0, jump: false });
  
  // Keyboard state for determining if shift is pressed (sprinting)
  const [keys, setKeys] = useState({ shift: false });

  // --- Constants ---
  const jumpForce = 8;
  const MOVEMENT_PRECISION = 0.1;
  const TARGET_REACHED_THRESHOLD = 0.05; // Smaller threshold for more precise stopping

  // --- Callbacks for Controlled Player Input ---
  const handleMouseClick = useCallback((e: MouseEvent) => {
    if (!isControlledPlayer || e.button !== 0 || isRotating) return;
    if ((e.target as HTMLElement).closest('.pointer-events-auto')) return;
    if (!socket || !playerState) return;

    // Make sure we're using the correct canvas dimensions for accurate clicking
    const canvasRect = gl.domElement.getBoundingClientRect();
    
    // Calculate normalized device coordinates (-1 to +1) using the canvas's actual position
    const mouse = new Vector2(
      ((e.clientX - canvasRect.left) / canvasRect.width) * 2 - 1,
      -((e.clientY - canvasRect.top) / canvasRect.height) * 2 + 1
    );

    // Update the ray with the camera and mouse position
    raycaster.setFromCamera(mouse, camera);

    // Find where ray intersects the ground plane
    const intersectPoint = new Vector3();
    if (raycaster.ray.intersectPlane(groundPlane, intersectPoint)) {
      // For debugging, log the click position
      console.log('Click position:', intersectPoint);
      
      movementStartTimeTs.current = Date.now();
      lastDistanceToTarget.current = Infinity;
      stuckCounter.current = 0;
      
      // Create target position, ensuring Y is at ground level
      const newTarget = new Vector3(intersectPoint.x, GROUND_Y, intersectPoint.z);
      
      // Get current position
      const currentPos = playerRef.current.translation();
      
      // Call the store's function to send the move start message with new protocol
      const path = [{ x: newTarget.x, z: newTarget.z }];
      const speed = BASE_SPEED * (keys.shift ? SPRINT_MUL : 1);
      useGameStore.getState().sendMoveStart(path, speed);
      
      // Set the target position in the component state (for local simulation)
      setTargetPosition(newTarget);
      
      // Store the target position globally
      useGameStore.getState().setTargetWorldPos(newTarget);
    }
  }, [isControlledPlayer, isRotating, camera, raycaster, groundPlane, gl, socket, playerState, playerId, keys]);

  const emitMoveStop = useCallback((position: any) => {
    if (!socket || !playerState) return;
    
    // Using the renamed function for immediate move sync
    useGameStore.getState().sendMoveSyncImmediate({ x: position.x, z: position.z });
    
    // Clear local target
    setTargetPosition(null);
    useGameStore.getState().setTargetWorldPos(null);
  }, [socket, playerState]);

  const handleMouseDown = useCallback((e: MouseEvent) => {
    if (!isControlledPlayer || e.button !== 2) return;
    setIsRotating(true);
    previousMousePosition.current = { x: e.clientX, y: e.clientY };
    document.body.style.cursor = 'grabbing';
    e.preventDefault(); e.stopPropagation();
  }, [isControlledPlayer]);

  const handleMouseUp = useCallback((e: MouseEvent) => {
    if (!isControlledPlayer || e.button !== 2) return;
    setIsRotating(false);
    document.body.style.cursor = 'default';
    e.preventDefault(); e.stopPropagation();
  }, [isControlledPlayer]);

  const handleMouseMove = useCallback((e: MouseEvent) => {
    if (!isControlledPlayer || !isRotating) return;
    const deltaX = e.clientX - previousMousePosition.current.x;
    cameraAngleRef.current -= deltaX * 0.02;
    previousMousePosition.current = { x: e.clientX, y: e.clientY };
    e.preventDefault(); e.stopPropagation();
  }, [isControlledPlayer, isRotating]);

  const handleContextMenu = useCallback((e: MouseEvent) => {
    if (!isControlledPlayer) return;
    e.preventDefault(); e.stopPropagation();
  }, [isControlledPlayer]);

  const handleKeyDown = useCallback((e: KeyboardEvent) => {
    if (!isControlledPlayer) return;
    
    // Handle space for jumping
    if (e.code === 'Space' && !hasJumped && isGrounded) {
      moveDirection.current.jump = true;
      setHasJumped(true);
    }
    
    // Handle shift for sprint
    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
      setKeys(prev => ({ ...prev, shift: true }));
    }
    
    // Handle S key for force stop
    if (e.code === 'KeyS' && playerState?.movement?.targetPos) {
      if (playerRef.current) {
        emitMoveStop(playerRef.current.translation());
      }
    }
    
  }, [isControlledPlayer, hasJumped, isGrounded, playerState, emitMoveStop]);

  const handleKeyUp = useCallback((e: KeyboardEvent) => {
    if (!isControlledPlayer) return;
    
    // Handle shift for sprint
    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
      setKeys(prev => ({ ...prev, shift: false }));
    }
    
  }, [isControlledPlayer]);

  // --- Register event listeners for controlled player ---
  useEffect(() => {
    if (!isControlledPlayer) return;

    window.addEventListener('click', handleMouseClick);
    window.addEventListener('mousedown', handleMouseDown);
    window.addEventListener('mouseup', handleMouseUp);
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('contextmenu', handleContextMenu);
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    document.body.style.cursor = 'default';

    return () => {
      window.removeEventListener('click', handleMouseClick);
      window.removeEventListener('mousedown', handleMouseDown);
      window.removeEventListener('mouseup', handleMouseUp);
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('contextmenu', handleContextMenu);
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [isControlledPlayer, handleMouseClick, handleMouseDown, handleMouseUp, handleMouseMove, handleContextMenu, handleKeyDown, handleKeyUp]);

  // --- Update Player.tsx useFrame handler to handle position snapshots ---
  useFrame((_, delta) => {
    if (!playerRef.current || !playerState) return;

    try {
      const currentPosition = playerRef.current.translation();
      lastUpdateTimeTs.current = Date.now();

      // For controlled player, we do client-side prediction and light reconciliation
      if (isControlledPlayer) {
        // Check if we have a movement active
        if (playerState.movement?.targetPos && targetPosition) {
          const dest = playerState.movement.targetPos;
          const speed = playerState.movement.speed;
          
          // Use simulated movement for predictive client updates
          const isMoving = simulateMovement(playerRef.current, dest, speed, delta);
          
          if (!isMoving) {
            // We've arrived at destination - notify server but only once
            if (!targetPosition) return; // Already notified server
            
            // First send MoveSync then clear the movement state
            useGameStore.getState().sendMoveSyncImmediate({ 
              x: currentPosition.x, 
              z: currentPosition.z 
            });
            setTargetPosition(null);
          } else {
            // Update rotation to face direction of movement
            const dir = new Vector3(dest.x - currentPosition.x, 0, dest.z - currentPosition.z).normalize();
            const targetRotation = Math.atan2(dir.x, dir.z);
            playerRef.current.setNextKinematicRotation({
              x: 0,
              y: Math.sin(targetRotation / 2),
              z: 0,
              w: Math.cos(targetRotation / 2)
            });
          }
        }

        // Apply jump velocity if needed
        if (moveDirection.current.jump && isGrounded && !hasJumped) {
          playerRef.current.setLinvel({ x: 0, y: jumpForce, z: 0 });
          moveDirection.current.jump = false;
        }

        // Update camera position
        const distance = 15;
        const height = 10;
        const angle = cameraAngleRef.current;
        camera.position.set(
          currentPosition.x - Math.sin(angle) * distance,
          currentPosition.y + height,
          currentPosition.z - Math.cos(angle) * distance
        );
        camera.lookAt(currentPosition.x, currentPosition.y + 1.0, currentPosition.z);
      } else {
        // Remote player: Use SnapBuffer for interpolation
        if (snapBufferRef.current && !isControlledPlayer && playerState) {
          const INTERP_LAG = 120; // ms
          const renderTs = Date.now() - INTERP_LAG;
          const playerSpeed = playerState.movement?.speed || 25;
          const sample = snapBufferRef.current.sample(renderTs, playerSpeed);
          
          if (sample) {
            // Apply interpolated position
            playerRef.current.setTranslation({
              x: sample.x,
              y: GROUND_Y,
              z: sample.z
            }, true);
            
            // Apply interpolated rotation
            playerRef.current.setRotation({
              x: 0,
              y: Math.sin(sample.rot/2),
              z: 0,
              w: Math.cos(sample.rot/2)
            }, true);
          }
        }
      }
      
      // Handle server-side correction for controlled player
      if (isControlledPlayer && pendingCorrectionRef.current) {
        const now = performance.now();
        const correctionProgress = Math.min(
          (now - correctionStartTimeRef.current) / correctionDurationRef.current, 
          1
        );
        
        if (correctionProgress < 1) {
          // Get current position
          const currentPos = playerRef.current.translation();
          // Create a vector from current position to server position
          const correctionVector = new Vector3().subVectors(
            serverCorrectionPositionRef.current,
            new Vector3(currentPos.x, currentPos.y, currentPos.z)
          );
          // Apply a fraction of the correction each frame
          correctionVector.multiplyScalar(delta * 10); // Adjust speed factor as needed
          
          // Apply partial correction
          const newPos = new Vector3(
            currentPos.x + correctionVector.x,
            currentPos.y + correctionVector.y,
            currentPos.z + correctionVector.z
          );
          playerRef.current.setTranslation(newPos);
        } else {
          // Correction completed
          pendingCorrectionRef.current = false;
        }
      }
    } catch (err) {
      console.error("Error in useFrame handler:", err);
    }
  });

  // --- Effect to handle server position updates for interpolation ---
  useEffect(() => {
    if (!playerState) return;
    
    // Handle remote player interpolation
    if (!isControlledPlayer) {
      const now = performance.now();
      // If movement just stopped, snap interpolation refs to stop position
      if (!playerState.movement?.targetPos) {
        previousPositionRef.current.set(
          playerState.position.x,
          playerState.position.y,
          playerState.position.z
        );
        targetPositionRef.current.set(
          playerState.position.x,
          playerState.position.y,
          playerState.position.z
        );
        interpolationAlphaRef.current = 0;
      } else if (lastPositionUpdateTimeRef.current === 0 || now - lastPositionUpdateTimeRef.current > 1000) {
        previousPositionRef.current.set(
          playerState.position.x,
          playerState.position.y,
          playerState.position.z
        );
        targetPositionRef.current.set(
          playerState.position.x,
          playerState.position.y,
          playerState.position.z
        );
        previousRotationRef.current = playerState.rotation.y;
        targetRotationRef.current = playerState.rotation.y;
      } else {
        // Otherwise, set previous to current target, and update target
        previousPositionRef.current.copy(targetPositionRef.current);
        targetPositionRef.current.set(
          playerState.position.x,
          playerState.position.y,
          playerState.position.z
        );
        previousRotationRef.current = targetRotationRef.current;
        targetRotationRef.current = playerState.rotation.y;
        interpolationAlphaRef.current = 0; // Reset interpolation progress
      }
      lastPositionUpdateTimeRef.current = now;
    }
  }, [playerState, isControlledPlayer]);

  // --- Effect to handle server corrections for controlled player ---
  useEffect(() => {
    if (!socket) return;

    // Handle position updates from server 
    const handlePosSnap = (data: { type: string, snaps: Array<{ id: string, pos: VecXZ, vel: VecXZ, ts: number }> }) => {
      if (data.type !== 'PosSnap') return;
      if (!data.snaps || !Array.isArray(data.snaps)) return;
      
      // Find this player's snap in the snaps array
      const thisPlayerSnap = data.snaps.find(snap => snap && snap.id === playerId);
      if (!thisPlayerSnap || !thisPlayerSnap.pos || !thisPlayerSnap.vel || !thisPlayerSnap.ts) return;
      
      if (isControlledPlayer) {
        // For controlled player: apply correction if needed
        const currentPosition = playerRef.current?.translation();
        if (!currentPosition) return;
        
        const serverPosition = new Vector3(thisPlayerSnap.pos.x, currentPosition.y, thisPlayerSnap.pos.z);
        const distance = new Vector3(
          serverPosition.x - currentPosition.x,
          0, // Ignore Y differences
          serverPosition.z - currentPosition.z
        ).length();
        
        // Only apply correction if the difference is significant
        if (distance > 1.0) {
          console.log(`Server correction: ${distance.toFixed(2)} units`);
          pendingCorrectionRef.current = true;
          serverCorrectionPositionRef.current.copy(serverPosition);
          correctionStartTimeRef.current = performance.now();
        }
      } else {
        // For remote players: use SnapBuffer for interpolation
        if (snapBufferRef.current && playerState) {
          try {
            snapBufferRef.current.push({
              pos: thisPlayerSnap.pos,
              vel: thisPlayerSnap.vel,
              rot: playerState.rotation?.y || 0,
              snapTs: thisPlayerSnap.ts
            });
          } catch (err) {
            console.error('Error pushing to snap buffer:', err);
          }
        }
      }
    };
    
    // Listen for position snapshots
    socket.on('msg', handlePosSnap);
    
    return () => {
      socket.off('msg', handlePosSnap);
    };
  }, [playerId, socket, isControlledPlayer, playerState]);

  // --- Listen for player position requests from skill effects ---
  useEffect(() => {
    if (!isControlledPlayer || !playerRef.current) return;

    const handleRequestPosition = (e: CustomEvent) => {
      const { effectId, callback } = e.detail;
      if (playerRef.current) {
        const currentPosition = playerRef.current.translation();
        // Provide the accurate client-side position for skill effects
        callback({
          x: currentPosition.x,
          y: currentPosition.y,
          z: currentPosition.z
        });
      }
    };

    window.addEventListener('requestPlayerPosition', handleRequestPosition as EventListener);
    
    return () => {
      window.removeEventListener('requestPlayerPosition', handleRequestPosition as EventListener);
    };
  }, [isControlledPlayer]);

  // Initialize the interpolation buffer on component mount
  useEffect(() => {
    if (!isControlledPlayer) {
      console.log(`Creating SnapBuffer for remote player ${playerId}`);
      snapBufferRef.current = new SnapBuffer();
    }
    
    return () => {
      // Clean up
      if (snapBufferRef.current && !isControlledPlayer) {
        console.log(`Cleaning up SnapBuffer for remote player ${playerId}`);
        snapBufferRef.current = null;
      }
    };
  }, [isControlledPlayer, playerId]);

  // Log player state on mount
  useEffect(() => {
    console.log(`PlayerCharacter mounting: id=${playerId}, isControlled=${isControlledPlayer}`, {
      position: playerState?.position,
      playerStateExists: !!playerState,
      allPlayers: Object.keys(useGameStore.getState().players)
    });

    return () => {
      console.log(`PlayerCharacter unmounting: id=${playerId}, isControlled=${isControlledPlayer}`);
    };
  }, [playerId, isControlledPlayer, playerState]);

  // Render the player model
  if (!playerState) return null; // Don't render if state doesn't exist yet

  return (
    <RigidBody
      ref={playerRef}
      position={[playerState.position.x, playerState.position.y, playerState.position.z]} // Initial position from store
      enabledRotations={[false, true, false]} // Allow Y rotation for facing direction
      colliders={false}
      mass={isControlledPlayer ? 10 : 1}
      type={isControlledPlayer ? "kinematicPosition" : "kinematicPosition"}
      lockRotations={!isControlledPlayer} // Lock rotation for non-controlled players if needed
      linearDamping={isControlledPlayer ? 0.5 : 0}
      angularDamping={isControlledPlayer ? 0.95 : 0}
      friction={isControlledPlayer ? 0.2 : 0}
      restitution={0.0}
      gravityScale={isControlledPlayer ? 2 : 0} // Disable gravity for remote players
      ccd={true}
      key={playerId} // Important for React to identify elements correctly
      userData={{ type: 'player', id: playerId }} // Add userData for identification
    >
      <CapsuleCollider args={[0.5, 0.6]} />
      {/* Single unified player model */}
      <group>
        {/* Body */}
        <mesh castShadow position={[0, 0.5, 0]}>
          <capsuleGeometry args={[0.5, 1.2, 8, 16]} />
          <meshStandardMaterial color={isControlledPlayer ? "#3870c4" : "#5a8cd9"} />
        </mesh>
        {/* Head */}
        <mesh castShadow position={[0, 1.6, 0]}>
          <sphereGeometry args={[0.3, 16, 16]} />
          <meshStandardMaterial color="#f5deb3" />
        </mesh>
      </group>
    </RigidBody>
  );
}

// Main Players Component (Renders all players)
export default function Players() {
  // Use stable selector functions from the store
  const playerIds = useGameStore(selectPlayerIds);
  const myPlayerId = useGameStore(selectMyPlayerId);
  
  // Debug logging for player store state
  useEffect(() => {
    // Log current state of players in store
    const allPlayers = useGameStore.getState().players;
    console.log('DEBUG - Player store state:', {
      playerIds,
      myPlayerId,
      allPlayerCount: Object.keys(allPlayers).length,
      timestamp: new Date().toISOString(),
      duplicatePlayerCheck: Object.values(allPlayers).filter(p => p.id === myPlayerId).length > 1 ? 'DUPLICATE DETECTED' : 'No duplicates',
      allPlayerIds: Object.values(allPlayers).map(p => p.id),
      allSocketIds: Object.values(allPlayers).map(p => p.socketId),
    });
  }, [playerIds, myPlayerId]);

  // Check for duplicate playerIds to prevent rendering the same player twice
  const uniquePlayerIds = [...new Set(playerIds)];
  
  // Direct and aggressive approach to ensure we render exactly one instance of each player
  const filteredPlayerIds = React.useMemo(() => {
    const allPlayers = useGameStore.getState().players;
    const seenPlayers = new Set<string>();
    const result: string[] = [];
    
    // First, ensure our player is included if it exists
    if (myPlayerId && allPlayers[myPlayerId]) {
      result.push(myPlayerId);
      seenPlayers.add(myPlayerId);
      console.log('Added controlled player to render list:', myPlayerId);
    }
    
    // Then add other unique players (but never add duplicates of our player)
    Object.values(allPlayers).forEach(player => {
      // Skip our own player (already added) and any players we've already seen
      if (player.id !== myPlayerId && !seenPlayers.has(player.id)) {
        result.push(player.id);
        seenPlayers.add(player.id);
      }
    });
    
    console.log('Final filtered player IDs for rendering:', {
      myPlayerId,
      filteredCount: result.length,
      filteredIds: result
    });
    
    return result;
  }, [uniquePlayerIds, myPlayerId]);

  // Memoize player creation
  const playerComponents = React.useMemo(() => 
    filteredPlayerIds.map(id => (
      <PlayerCharacter 
        key={id}
        playerId={id}
        isControlledPlayer={id === myPlayerId}
      />
    ))
  , [filteredPlayerIds, myPlayerId]); // Only recreate when IDs or controlled player changes

  // Render just the players, no target marker (moved to the TargetRing component)
  return <>{playerComponents}</>;
}

// ==============================================================================
// FILE: app/game/components/SkillTreeUI.tsx
// ==============================================================================

'use client';

import React, { useState, useEffect } from 'react';
import { useGameStore } from '../systems/gameStore';
import { SKILLS, SkillId } from '../models/Skill';
import { CLASS_SKILL_TREES, canLearnSkill, CharacterClass } from '../../../shared/classSystem';
import dragState from '../systems/dragState';
import skillUtils from '../systems/skillUtils';
import styles from '../styles/SkillTreeUI.module.css';

const SkillTreeUI: React.FC = () => {
  const socket = useGameStore(state => state.socket);
  const player = useGameStore(state => state.getMyPlayer());
  const [availableSkills, setAvailableSkills] = useState<SkillId[]>([]);
  const [selectedClass, setSelectedClass] = useState<CharacterClass | null>(null);
  const [isSkillTreeOpen, setIsSkillTreeOpen] = useState(false);
  // New state for skill shortcuts (keys 1-9)
  const [skillShortcuts, setSkillShortcuts] = useState<(SkillId | null)[]>([null, null, null, null, null, null, null, null, null]);

  // Force update when drag state changes
  const [dragStateKey, setDragStateKey] = useState(0);
  // Create local wrappers for drag state functions that trigger re-renders
  const setDraggedSkill = (skillId: string | null) => {
    dragState.setDraggedSkill(skillId);
    setDragStateKey(prev => prev + 1);
  };
  
  const clearDraggedSkill = () => {
    dragState.clearDraggedSkill();
    setDragStateKey(prev => prev + 1);
  };
  
  useEffect(() => {
    // Debug log to see if component is rendering and has proper data
    console.log('SkillTreeUI rendering:', { 
      player, 
      className: player?.className,
      skillPoints: player?.availableSkillPoints,
      draggedSkill: dragState.getDraggedSkill()
    });
    
    // Update selected class when player data changes
    if (player?.className) {
      setSelectedClass(player.className as CharacterClass);
    }
  }, [player, dragStateKey]);

  useEffect(() => {
    // Calculate available skills when relevant data changes
    if (selectedClass && player) {
      // Get unlearned skills that are available to learn
      const availableSkillsList: SkillId[] = [];
      const classTree = CLASS_SKILL_TREES[selectedClass];
      
      console.log('DEBUG: Calculating available skills', {
        className: selectedClass,
        level: player.level,
        unlockedSkills: player.unlockedSkills,
        skillPoints: player.availableSkillPoints
      });
      
      if (classTree) {
        for (const [skillId, requirement] of Object.entries(classTree.skillProgression)) {
          // Skip skills player already has
          if (player.unlockedSkills.includes(skillId as SkillId)) {
            console.log(`DEBUG: Skipping already unlocked skill: ${skillId}`);
            continue;
          }
          
          // Check if player can learn this skill
          const canLearn = canLearnSkill(
            skillId as SkillId,
            selectedClass,
            player.level,
            player.unlockedSkills as SkillId[]
          );
          
          console.log(`DEBUG: Skill ${skillId} can be learned: ${canLearn}`, {
            levelRequirement: requirement.level,
            playerLevel: player.level,
            requiredSkills: requirement.requiredSkills
          });
          
          if (canLearn) {
            availableSkillsList.push(skillId as SkillId);
          }
        }
      }
      
      console.log('Available skills to learn:', availableSkillsList);
      setAvailableSkills(availableSkillsList);
    }
  }, [player, selectedClass]);

  useEffect(() => {
    // Update skill shortcuts when player data changes
    if (player?.skillShortcuts) {
      setSkillShortcuts(player.skillShortcuts);
    }
  }, [player?.skillShortcuts]);
  
  // Add debugging for drag and drop events
  useEffect(() => {
    // Debug drag and drop issues
    if (typeof window !== 'undefined') {
      console.log('Setting up drag and drop debugging');
      
      const logDragEvent = (e: DragEvent, name: string) => {
        console.log(`Drag event ${name}:`, {
          types: e.dataTransfer ? Array.from(e.dataTransfer.types) : [],
          target: e.target
        });
      };
      
      window.addEventListener('dragstart', (e) => logDragEvent(e, 'dragstart'), false);
      window.addEventListener('drop', (e) => logDragEvent(e, 'drop'), false);
      
      return () => {
        window.removeEventListener('dragstart', (e) => logDragEvent(e, 'dragstart'), false);
        window.removeEventListener('drop', (e) => logDragEvent(e, 'drop'), false);
      };
    }
  }, []);

  const learnSkill = (skillId: SkillId) => {
    console.log('Attempting to learn skill:', skillId, {
      hasSocket: !!socket,
      skillPoints: player?.availableSkillPoints
    });
    
    if (socket && player?.availableSkillPoints && player.availableSkillPoints > 0) {
      console.log('Sending LearnSkill message to server');
      // Send learn skill request to server
      socket.emit('msg', {
        type: 'LearnSkill',
        skillId: skillId
      });
    } else {
      console.log('Cannot learn skill - no socket or skill points:', {
        socket: !!socket,
        skillPoints: player?.availableSkillPoints
      });
    }
  };

  const setSkillShortcut = (skillId: SkillId, slotIndex: number) => {
    if (!socket) {
      console.error('Cannot set skill shortcut: No socket connection');
      return;
    }
    
    if (!player) {
      console.error('Cannot set skill shortcut: No player data');
      return;
    }
    
    // Validate skill ID - make sure it's an actual skill ID, not a path or something else
    if (!SKILLS[skillId]) {
      console.error(`Cannot set skill shortcut: Invalid skill ID "${skillId}"`);
      return;
    }

    console.log(`Setting skill ${skillId} to shortcut slot ${slotIndex+1}`);
    
    try {
      // First, check if this skill already exists in another slot
      const existingIndex = skillShortcuts.findIndex(s => s === skillId);
      
      // If the skill exists somewhere else and we're not replacing it with itself,
      // clear the old slot first to prevent duplicates
      if (existingIndex !== -1 && existingIndex !== slotIndex) {
        console.log(`Skill ${skillId} already exists in slot ${existingIndex + 1}, removing it first`);
        const newShortcuts = [...skillShortcuts];
        newShortcuts[existingIndex] = null;
        setSkillShortcuts(newShortcuts);
      }
      
      // Send request to set skill shortcut
      socket.emit('msg', {
        type: 'SetSkillShortcut',
        slotIndex: slotIndex,
        skillId: skillId
      });
      
      // Immediately update local state for responsive UI
      const newShortcuts = [...skillShortcuts];
      newShortcuts[slotIndex] = skillId;
      setSkillShortcuts(newShortcuts);
      
      // Add visual feedback
      const slotElement = document.querySelector(`.${styles.shortcutSlot}:nth-child(${slotIndex + 1})`);
      if (slotElement) {
        slotElement.classList.add(styles.shortcutSuccess);
        setTimeout(() => {
          slotElement.classList.remove(styles.shortcutSuccess);
        }, 500);
      }
      
    } catch (err) {
      console.error('Error setting skill shortcut:', err);
    }
  };

  const toggleSkillTree = (e: React.MouseEvent) => {
    // Prevent event from propagating to the world
    e.preventDefault();
    e.stopPropagation();
    
    console.log('Toggle skill tree clicked');
    setIsSkillTreeOpen(!isSkillTreeOpen);
  };

  console.log('SkillTreeUI render checks:', { 
    hasPlayer: !!player, 
    playerClassName: player?.className,
    selectedClass,
    classTreeExists: selectedClass ? !!CLASS_SKILL_TREES[selectedClass] : false 
  });

  // If we don't have player data yet, render just the button for now
  if (!player) {
    console.log('No player data yet, rendering only button');
    return (
      <button 
        className={styles.skillTreeButton} 
        onClick={toggleSkillTree}
        onMouseDown={(e) => e.stopPropagation()}
        onMouseUp={(e) => e.stopPropagation()}
      >
        Skill Tree
      </button>
    );
  }

  // If we don't have a class selected or the class tree doesn't exist, just show button
  if (!selectedClass || !CLASS_SKILL_TREES[selectedClass]) {
    console.log('No class selected or class tree missing');
    return (
      <button 
        className={styles.skillTreeButton} 
        onClick={toggleSkillTree}
        onMouseDown={(e) => e.stopPropagation()}
        onMouseUp={(e) => e.stopPropagation()}
      >
        Skill Tree ({player.className})
      </button>
    );
  }

  const classTree = selectedClass ? CLASS_SKILL_TREES[selectedClass] : null;

  return (
    <>
      <button 
        className={styles.skillTreeButton} 
        onClick={toggleSkillTree}
        onMouseDown={(e) => e.stopPropagation()}
        onMouseUp={(e) => e.stopPropagation()}
      >
        Skill Tree
      </button>

      {isSkillTreeOpen && classTree && (
        <div 
          className={styles.skillTreeOverlay}
          onClick={(e) => e.stopPropagation()}
        >
          <div className={styles.skillTreeContainer}>
            <div className={styles.skillTreeHeader}>
              <h2>{classTree.className} Skill Tree</h2>
              <p>{classTree.description}</p>
              <p>Available Skill Points: {player.availableSkillPoints}</p>
              <button 
                className={styles.closeButton}
                onClick={toggleSkillTree}
              >
                Close
              </button>
            </div>

            <div className={styles.skillsContainer}>
              <div className={styles.unlockedSkills}>
                <h3>Unlocked Skills</h3>
                {player.unlockedSkills.length === 0 ? (
                  <p>No skills unlocked yet</p>
                ) : (
                  <div className={styles.skillsList}>
                    {player.unlockedSkills.map((skillId) => {
                      const skill = SKILLS[skillId];
                      return (
                        <div key={skillId} className={styles.skillItem}>
                          <img 
                            src={skillUtils.getSkillIconPath(skillId)} 
                            alt={skill.name} 
                            title={skill.description}
                      onDoubleClick={() => {
                        // When double-clicking a skill, assign it to the first available slot
                        console.log('Skill double-clicked:', skillId);
                        const availableSlotIndex = skillShortcuts.findIndex(skill => skill === null);
                        if (availableSlotIndex !== -1) {
                          console.log(`Assigning to first available slot: ${availableSlotIndex + 1}`);
                          setSkillShortcut(skillId, availableSlotIndex);
                        } else {
                          // If no empty slots, assign to slot 1
                          console.log('No empty slots, assigning to slot 1');
                          setSkillShortcut(skillId, 0);
                        }
                      }}
                      draggable={true}
                      onDragStart={(e) => {
                        // Make sure we have a valid skill ID to start the drag
                        if (!SKILLS[skillId]) {
                          console.error(`Attempting to drag invalid skill: ${skillId}`);
                          return;
                        }

                        console.log('Drag started with skill ID:', skillId);

                        // Store the skill ID in our global drag state
                        dragState.setDraggedSkill(skillId);

                        // Set the drag effect to copy
                        e.dataTransfer.effectAllowed = 'copy';

                        // Add custom drag image if available
                        try {
                          const img = new Image();
                          img.src = skillUtils.getSkillIconPath(skillId);
                          console.log('Using image for drag:', img.src);

                          img.onload = () => {
                            try {
                              e.dataTransfer.setDragImage(img, 25, 25);
                              console.log('Set drag image successfully');
                            } catch (imgErr) {
                              console.warn('Failed to set drag image after load:', imgErr);
                            }
                          };
                        } catch (err) {
                          console.warn('Failed to create drag image:', err);
                        }
                      }}
                      onDragEnd={() => {
                        console.log('Drag ended, clearing drag state');
                        clearDraggedSkill();
                      }}
                          />
                          <span>{skill.name}</span>
                          <div className={styles.skillDetails}>
                            <p>Level Required: {skill.levelRequired}</p>
                            <p>Mana Cost: {skill.manaCost}</p>
                            <p>Cooldown: {skill.cooldownMs}ms</p>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>

              <div className={styles.availableSkills}>
                <h3>Available to Learn</h3>
                {availableSkills.length === 0 ? (
                  <p>No skills available to learn</p>
                ) : (
                  <div className={styles.skillsList}>
                    {availableSkills.map((skillId) => {
                      const skill = SKILLS[skillId];
                      return (
                        <div key={skillId} className={styles.skillItem}>
                          <img 
                            src={skillUtils.getSkillIconPath(skillId)} 
                            alt={skill.name} 
                            title={skill.description}
                          />
                          <span>{skill.name}</span>
                          <div className={styles.skillDetails}>
                            <p>Level Required: {skill.levelRequired}</p>
                            <p>Mana Cost: {skill.manaCost}</p>
                            <p>Cooldown: {skill.cooldownMs}ms</p>
                          </div>
                          <button 
                            className={styles.learnButton}
                            disabled={player.availableSkillPoints <= 0}
                            onClick={() => learnSkill(skillId)}
                          >
                            Learn
                          </button>
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>
            </div>

            <div className={styles.activeSkillsSection}>
              <h3>Skill Shortcuts (1-9)</h3>
              <p>Click a skill then a number to assign it as a shortcut, or click directly to cast</p>
              
              {/* Shortcut slots */}
              <div className={styles.shortcutsPanel}>
                {skillShortcuts.map((skillId, index) => (
                  <div 
                    key={index} 
                    className={styles.shortcutSlot}
                    data-slot-index={index}
                    onClick={() => {
                      // If we have a selected skill and the user clicks a slot,
                      // set the skill to that slot (simpler alternative to drag and drop)
                      const selectedSkill = dragState.getDraggedSkill();
                      if (selectedSkill && SKILLS[selectedSkill as SkillId] &&
                          player?.unlockedSkills.includes(selectedSkill as SkillId)) {
                        console.log(`Slot ${index+1} clicked with skill ${selectedSkill} selected`);
                        setSkillShortcut(selectedSkill as SkillId, index);
                      }
                    }}
                    onTouchEnd={(e) => {
                      // Special handler for touch events where drag and drop might not work
                      e.preventDefault();
                      const draggedSkill = dragState.getDraggedSkill();
                      if (draggedSkill) {
                        const validSkill = skillUtils.validateSkillId(draggedSkill);
                        if (validSkill) {
                          console.log(`Touch ended on slot ${index+1} with skill ${validSkill}`);
                          setSkillShortcut(validSkill, index);
                          clearDraggedSkill();
                          
                          // Add visual feedback
                          e.currentTarget.classList.add(styles.dropSuccess);
                          setTimeout(() => {
                            e.currentTarget.classList.remove(styles.dropSuccess);
                          }, 500);
                        }
                      }
                    }}
                    onDragOver={(e) => {
                      e.preventDefault(); // Necessary to allow drop
                      e.stopPropagation();
                      e.dataTransfer.dropEffect = 'copy';
                      e.currentTarget.classList.add(styles.dragOver);
                    }}
                    onDragEnter={(e) => {
                      e.preventDefault();
                      e.currentTarget.classList.add(styles.dragOver);
                    }}
                    onDragLeave={(e) => {
                      e.preventDefault();
                      e.currentTarget.classList.remove(styles.dragOver);
                    }}
                    onDrop={(e) => {
                      e.preventDefault();
                      e.currentTarget.classList.remove(styles.dragOver);
                      
                      console.log('Drop event triggered on slot', index + 1);

                      const skillIdRaw = dragState.getDraggedSkill();
                      console.log('Raw skill ID from drag state:', skillIdRaw);
                      dragState.clearDraggedSkill();

                      // Validate and normalize the skill ID
                      const skillId = skillUtils.validateSkillId(skillIdRaw);
                      console.log('Validated skill ID:', skillId);
                      
                      if (skillId) {
                        console.log(`Valid skill found: ${skillId}, adding to slot ${index + 1}`);
                        // Add visual feedback for the drop
                        e.currentTarget.classList.add(styles.dropSuccess);
                        setTimeout(() => {
                          try {
                              e.currentTarget.classList.remove(styles.dropSuccess);
                          } catch (_err) {
                              // Ignoring errors when removing class if element no longer exists
                              console.debug('Failed to remove drop success class');
                          }
                        }, 500);
                        
                        // Set the shortcut with the validated skill ID
                        setSkillShortcut(skillId, index);
                        
                      } else {
                        console.error('Failed to get valid skill ID from drop event. Value:', skillIdRaw);
                        
                      }
                    }}
                  >
                    <div className={styles.keyNumber}>{index + 1}</div>
                    {skillId ? (
                      <img 
                        src={skillUtils.getSkillIconPath(skillId)} 
                        alt={SKILLS[skillId] ? SKILLS[skillId].name : skillId} 
                        title={SKILLS[skillId] ? SKILLS[skillId].description : skillId}
                      />
                    ) : (
                      <div className={styles.emptySlot} />
                    )}
                  </div>
                ))}
              </div>
              
            </div>
          </div>
        </div>
      )}
    </>
  );
};

export default SkillTreeUI;


// ==============================================================================
// FILE: app/game/components/StatusEffects.tsx
// ==============================================================================

'use client';

import React, { useCallback, useMemo } from 'react';
import { useGameStore, StatusEffect, selectStatusEffects } from '../systems/gameStore';
import Image from 'next/image';

interface StatusEffectsProps {
  targetId: string | 'player';
  position?: 'top' | 'right' | 'bottom' | 'left';
  inline?: boolean;
}

// Cache for status effects to ensure stable references across renders
const statusEffectsCache: {
  [key: string]: {
    effects: StatusEffect[];
    timestamp: number;
    signature: string;
  }
} = {};

// EXTREMELY simple hook for status effects with debugging
function useStatusEffects(targetId: string | 'player'): StatusEffect[] {
  // Add component instance identifier for tracking render cycles
  const instanceId = React.useRef(`${targetId}-${Math.random().toString(36).substring(2, 7)}`);
  
  console.log(`[DEBUG][StatusEffects][${instanceId.current}] Hook initializing for target: ${targetId}`);
  
  // Initialize with empty array instead of calling getter directly
  const [effects, setEffects] = React.useState<StatusEffect[]>([]);
  
  // Create a stable getter function that will always retrieve the latest effects
  const effectsGetter = useCallback(() => {
    const state = useGameStore.getState();
    
    if (targetId === 'player') {
      const playerId = state.myPlayerId;
      if (!playerId) {
        console.log(`[DEBUG][StatusEffects][${instanceId.current}] No player ID found in state`);
        return [];
      }
      const player = state.players[playerId];
      if (!player) {
        console.log(`[DEBUG][StatusEffects][${instanceId.current}] Player with ID ${playerId} not found in state`);
        return [];
      }
      return player?.statusEffects || [];
    } else {
      const enemy = state.enemies[targetId];
      if (!enemy) {
        console.log(`[DEBUG][StatusEffects][${instanceId.current}] Enemy with ID ${targetId} not found in state`);
        return [];
      }
      return enemy?.statusEffects || [];
    }
  }, [targetId, instanceId]);
  
  // Set up a simple interval to update the effects
  React.useEffect(() => {
    console.log(`[DEBUG][StatusEffects][${instanceId.current}] Effect setup for target: ${targetId}`);
    
    let isMounted = true;
    
    // Update immediately on mount
    try {
      const initialEffects = effectsGetter();
      console.log(`[DEBUG][StatusEffects][${instanceId.current}] Initial effects:`, initialEffects);
      if (isMounted) {
        setEffects(initialEffects);
      }
    } catch (err) {
      console.error(`[ERROR][StatusEffects][${instanceId.current}] Error getting initial effects:`, err);
    }
    
    // Update effects on a timer to avoid excessive re-renders
    const intervalId = setInterval(() => {
      try {
        if (isMounted) {
          const newEffects = effectsGetter();
          
          // Only update if there's a meaningful change
          const hasChanged = newEffects.length !== effects.length || 
            newEffects.some((effect, idx) => 
              !effects[idx] || effect.id !== effects[idx].id || 
              effect.durationMs !== effects[idx].durationMs);
          
          if (hasChanged) {
            console.log(`[DEBUG][StatusEffects][${instanceId.current}] Updating effects:`, newEffects);
            setEffects(newEffects);
          }
        }
      } catch (err) {
        console.error(`[ERROR][StatusEffects][${instanceId.current}] Error updating effects:`, err);
      }
    }, 1000); // Once per second is enough for effects display
    
    return () => {
      isMounted = false;
      clearInterval(intervalId);
      console.log(`[DEBUG][StatusEffects][${instanceId.current}] Cleanup for target: ${targetId}`);
    };
  }, [targetId, effectsGetter, instanceId, effects.length]);
  
  return effects;
}

const StatusEffects = React.memo(React.forwardRef<HTMLDivElement, StatusEffectsProps>(({ targetId, position = 'top', inline = false }, ref) => {
  // Format to show time remaining
  const formatTimeRemainingMs = useCallback((effect: StatusEffect) => {
    const currentTimeMs = Date.now();
    const elapsedTimeMs = currentTimeMs - effect.startTimeTs;
    const remainingTimeMs = Math.max(0, effect.durationMs - elapsedTimeMs);
    // Return actual millisecond value for precise display
    return remainingTimeMs;
  }, []);

  // Get position classes
  const getPositionClasses = useCallback(() => {
    if (inline) return "flex flex-wrap gap-1";
    
    switch(position) {
      case 'top': return "absolute -top-7 left-1/2 transform -translate-x-1/2 flex gap-1";
      case 'bottom': return "absolute -bottom-7 left-1/2 transform -translate-x-1/2 flex gap-1";
      case 'left': return "absolute top-1/2 -left-7 transform -translate-y-1/2 flex flex-col gap-1";
      case 'right': return "absolute top-1/2 -right-7 transform -translate-y-1/2 flex flex-col gap-1";
      default: return "absolute -top-7 left-1/2 transform -translate-x-1/2 flex gap-1";
    }
  }, [inline, position]);

  // Use the custom hook to get effects - this separates the store logic from the component
  const effects = useStatusEffects(targetId);
  
  if (effects.length === 0) return null;

  return (
    <div className={getPositionClasses()}>
      {effects.map((effect: StatusEffect) => {
        const effectClassName = `effect-${effect.type}`;
        
        return (
          <div 
            key={effect.id} 
            className={`bg-gray-600 w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold text-white relative overflow-hidden ${effectClassName}`}
            title={`${effect.type}: ${effect.value}% - ${formatTimeRemainingMs(effect)}ms remaining`}
            style={{
              backgroundColor: `var(--effect-${effect.type}-color, #6b7280)`
            }}
          >
            <img 
              src={`/game/skills/effect_${effect.type}.png`} 
              alt={effect.type} 
              className="w-full h-full object-cover"
              onError={(e) => {
                e.currentTarget.style.display = 'none';
                e.currentTarget.parentElement!.innerHTML = effect.type.charAt(0).toUpperCase();
              }}
            />
            <div className="absolute -bottom-4 left-1/2 transform -translate-x-1/2 text-[10px] bg-black/50 px-1 rounded">
              {formatTimeRemainingMs(effect)}ms
            </div>
          </div>
        );
      })}
    </div>
  );
}));

StatusEffects.displayName = 'StatusEffects';

export default StatusEffects;

// ==============================================================================
// FILE: app/game/components/TargetRing.tsx
// ==============================================================================

import { useGameStore } from '../systems/gameStore';
import { memo } from 'react';
import { Vector3 } from 'three';

export default memo(function TargetRing() {
  const pos = useGameStore(s => s.targetWorldPos);
  
  if (!pos) return null;
  
  return (
    <mesh position={[pos.x, pos.y, pos.z]} rotation={[-Math.PI/2, 0, 0]}>
      <ringGeometry args={[0.3, 0.5, 16]} />
      <meshBasicMaterial color="#ffff00" transparent opacity={0.6} />
    </mesh>
  );
});


// ==============================================================================
// FILE: app/game/components/UI.tsx
// ==============================================================================

'use client';

import React, { useEffect, useState, useRef, useCallback, useMemo } from 'react';
import { useGameStore } from '../systems/gameStore';
import { SKILLS, Skill, SkillId } from '../models/Skill';
import StatusEffects from './StatusEffects';
import ConnectionStatus from './ConnectionStatus';
import SkillTreeUI from './SkillTreeUI';
import CombatLog from './HUD/CombatLog';
import { GAME_ZONES } from '../systems/zoneSystem';
import Image from 'next/image';
import { tryStartCast } from '../systems/castController';

// Helper function to validate if a string is a valid SkillId
function isValidSkillId(id: string | null): id is SkillId {
  if (!id) return false;
  return id in SKILLS; // Check if the ID exists in the SKILLS object
}

interface PlayerState {
  id: string;
  name: string;
  level: number;
  experience: number;
  experienceToNextLevel: number;
  health: number;
  maxHealth: number;
  mana: number;
  maxMana: number;
  unlockedSkills: string[];
  skillShortcuts: (string | null)[];
  availableSkillPoints: number;
  className: string;
}

// Add explicit global window typings for our custom method
declare global {
  interface Window {
    castFireball?: () => void;
  }
}

interface XPBoostPanelProps {
  isAdmin?: boolean;
}

function XPBoostPanel({ isAdmin = false }: XPBoostPanelProps) {
  const getXpMultiplierInfo = useGameStore(state => state.getXpMultiplierInfo);
  const applyDonationBoost = useGameStore(state => state.applyDonationBoost);
  const clearDonationBoost = useGameStore(state => state.clearDonationBoost);
  const toggleXpEvent = useGameStore(state => state.toggleXpEvent);
  const bonusXpEventActive = useGameStore(state => state.bonusXpEventActive);
  const donationXpBoost = useGameStore(state => state.donationXpBoost);
  
  const xpInfo = getXpMultiplierInfo();
  const totalMultiplier = xpInfo.total;
  
  // Handler for donation boost
  const handleDonationBoost = useCallback((amount: number, durationMinutes: number, event: React.MouseEvent) => {
    event.stopPropagation();
    applyDonationBoost(amount, durationMinutes);
  }, [applyDonationBoost]);
  
  return (
    <div className="bg-gray-900/80 p-3 rounded-lg mb-3">
      <div className="flex justify-between items-center mb-2">
        <h3 className="text-white font-bold">XP Multipliers</h3>
        <div className="text-xl text-yellow-400 font-bold">{totalMultiplier.toFixed(2)}x</div>
      </div>
      
      <div className="space-y-1 mb-3 text-sm">
        <div className="flex justify-between">
          <span className="text-gray-300">Base Multiplier:</span>
          <span className="text-white">{xpInfo.base}x</span>
        </div>
        
        {xpInfo.donation > 0 && (
          <div className="flex justify-between">
            <span className="text-gray-300">Donation Boost:</span>
            <span className="text-green-400">+{(xpInfo.donation * 100).toFixed(0)}%</span>
          </div>
        )}
        
        {xpInfo.event > 1 && (
          <div className="flex justify-between">
            <span className="text-gray-300">Event Bonus:</span>
            <span className="text-purple-400">{xpInfo.event}x</span>
          </div>
        )}
      </div>
      
      {/* Donation boost panel - visible to all players */}
      <div className="mb-3">
        <div className="flex gap-2 justify-center">
          <button
            className="bg-green-600 hover:bg-green-700 text-white text-xs py-1 px-2 rounded pointer-events-auto transition-colors"
            onClick={(e) => handleDonationBoost(0.5, 60, e)}
          >
            +50% (1h) $5
          </button>
          <button
            className="bg-green-600 hover:bg-green-700 text-white text-xs py-1 px-2 rounded pointer-events-auto transition-colors"
            onClick={(e) => handleDonationBoost(1.0, 120, e)}
          >
            +100% (2h) $10
          </button>
          <button
            className="bg-green-600 hover:bg-green-700 text-white text-xs py-1 px-2 rounded pointer-events-auto transition-colors"
            onClick={(e) => handleDonationBoost(2.0, 240, e)}
          >
            +200% (4h) $20
          </button>
        </div>
      </div>
    </div>
  );
}

interface SkillButtonProps {
  skill: Skill;
  cooldownEndMs: number; // timestamp in milliseconds when cooldown ends
  isCasting: boolean;
  castProgressMs: number;
  onClick: (event: React.MouseEvent) => void;
  selectedTarget: any;
  isFlashing?: boolean; // Added to handle cast fail visual feedback
}

// Memoize SkillButton to prevent unnecessary re-renders
const SkillButton = React.memo(({ skill, cooldownEndMs, isCasting, castProgressMs, onClick, selectedTarget, isFlashing = false }: SkillButtonProps) => {
  const initial = Math.max(0, cooldownEndMs - Date.now());
  const [remainingCooldownMs, setRemainingCooldownMs] = useState(initial);
  const buttonRef = useRef<HTMLButtonElement>(null);
  
  useEffect(() => {
    const update = () => 
      setRemainingCooldownMs(Math.max(0, cooldownEndMs - Date.now()));
    
    update(); // Update immediately
    if (cooldownEndMs <= Date.now()) return; // Already over
    
    const interval = setInterval(update, 100); // Keep in sync
    
    return () => clearInterval(interval);
  }, [cooldownEndMs]);
  
  const isOnCooldown = remainingCooldownMs > 0;
  const isUsable = Boolean(selectedTarget) && !isOnCooldown;
  
  // Handle click with stopPropagation
  const handleClick = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (isUsable) {
      onClick(e);
    }
  }, [isUsable, onClick]);
  
  // Extract debuff effects from the skill
  const debuffEffects = useMemo(() => 
    skill.effects.filter(effect => effect.type !== 'damage' && effect.type !== 'dot'),
    [skill.effects]
  );

  useEffect(() => {
    const button = buttonRef.current;
    if (!button) return;
    
    const handleMouseEnter = () => {
      if (isUsable) {
        button.style.transform = 'scale(1.1)';
        button.style.boxShadow = '0 0 10px #9945FF';
      }
    };
    
    const handleMouseLeave = () => {
      button.style.transform = 'scale(1)';
      button.style.boxShadow = 'none';
    };
    
    button.addEventListener('mouseenter', handleMouseEnter);
    button.addEventListener('mouseleave', handleMouseLeave);
    
    return () => {
      button.removeEventListener('mouseenter', handleMouseEnter);
      button.removeEventListener('mouseleave', handleMouseLeave);
    };
  }, [isUsable]);

  // Map skill IDs to their correct image paths
  const getSkillImagePath = (skillId: string) => {
    // Special case mapping for waterSplash which uses the water image
    if (skillId === 'waterSplash') return '/game/skills/skill_water.png';
    return `/game/skills/skill_${skillId}.png`;
  };

  return (
    <div className="flex flex-col items-center">
      <button
        ref={buttonRef}
        className={`relative w-12 h-12 rounded transition-all duration-200 ${
          isFlashing ? 'bg-red-700 ring-2 ring-red-500' :
          isCasting ? 'bg-purple-700 ring-2 ring-purple-300' :
          isOnCooldown ? 'bg-gray-600' : 
          !selectedTarget ? 'bg-gray-500 opacity-50' :
          'bg-gray-800 hover:bg-gray-700'
        } flex items-center justify-center pointer-events-auto focus:outline-none overflow-hidden`}
        onClick={handleClick}
        disabled={!isUsable}
        style={{ transition: 'transform 0.2s, box-shadow 0.2s' }}
      >
        {/* Skill icon - using mapped path */}
        <Image 
          src={getSkillImagePath(skill.id)}
          alt={skill.name} 
          width={48}
          height={48}
          className="w-full h-full object-cover"
          onError={(e) => {
            // If image fails to load, show fallback
            if (e.currentTarget.parentElement) {
              e.currentTarget.style.display = 'none';
              // Create a text node with the first letter instead of using innerHTML
              const fallbackText = document.createTextNode(skill.id.charAt(0).toUpperCase());
              e.currentTarget.parentElement.appendChild(fallbackText);
            }
          }}
        />
        
        {/* Cooldown overlay */}
        {isOnCooldown && (
          <>
            <div 
              className="absolute inset-0 bg-gray-800 opacity-70"
              style={{ 
                // Reveal skill icon from top to bottom as cooldown progresses
                clipPath: `inset(${(1 - remainingCooldownMs / skill.cooldownMs) * 100}% 0 0 0)` 
              }}
            ></div>
            <div className="absolute text-white font-bold text-sm">
              {remainingCooldownMs}ms
            </div>
          </>
        )}
        
        {/* Tooltip */}
        <div className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 w-48 bg-gray-800 p-2 rounded text-xs text-white opacity-0 hover:opacity-100 transition-opacity z-50 pointer-events-none">
          <div className="font-bold">{skill.name}</div>
          <div className="mt-1">{skill.description}</div>
          <div className="mt-1">Mana: {skill.manaCost}</div>
          <div>Cooldown: {skill.cooldownMs}ms</div>
          {skill.castTimeMs > 0 && <div>Cast Time: {skill.castTimeMs}ms</div>}
          {skill.damage && <div>Damage: {skill.damage}</div>}
          
          {/* Show skill effects in tooltip */}
          {debuffEffects.length > 0 && (
            <div className="mt-1 pt-1 border-t border-gray-600">
              <div className="font-bold text-yellow-300">Effects:</div>
              <ul className="list-disc list-inside">
                {debuffEffects.map((effect, index) => (
                  <li key={index}>
                    {effect.type.charAt(0).toUpperCase() + effect.type.slice(1)}: 
                    {                    effect.type === 'burn' || effect.type === 'poison' ? 
                      ` ${effect.value}% damage over time` : 
                      effect.type === 'slow' || effect.type === 'waterWeakness' ? 
                      ` ${effect.value}%` : 
                      ` ${effect.value}`}
                    {effect.durationMs ? ` for ${effect.durationMs / 1000}s` : ''}
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>
      </button>
      
      {/* Debuff effects indicators - icons only, no labels */}
      {debuffEffects.length > 0 && (
        <div className="mt-1 flex space-x-1 justify-center">
          {debuffEffects.map((effect, index) => {
            // Generic emoji mapping for fallbacks (if needed)
            const defaultEmojis: Record<string, string> = {
              default: ""  // Default fallback
            };
            
            // Generate colored background dynamically based on effect type
            const effectClassName = `effect-${effect.type}`;
            
            return (
              <div
                key={index}
                className={`bg-gray-600 w-4 h-4 rounded-full flex items-center justify-center text-[10px] text-white overflow-hidden ${effectClassName}`}
                title={`${effect.type}: ${effect.value}%${effect.durationMs ? ` for ${effect.durationMs / 1000}s` : ''}`}
                style={{
                  // Dynamic background color based on effect type
                  backgroundColor: `var(--effect-${effect.type}-color, #6b7280)`
                }}
              >
                <Image 
                  src={`/game/skills/effect_${effect.type}.png`}
                  alt={effect.type} 
                  width={16}
                  height={16}
                  className="w-full h-full object-cover"
                  onError={(e) => {
                    // If image fails to load, use first character of effect type
                    e.currentTarget.style.display = 'none';
                    e.currentTarget.parentElement!.innerHTML = defaultEmojis[effect.type] || 
                      effect.type.charAt(0).toUpperCase();
                  }}
                />
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}, (prevProps, nextProps) => {
  // Custom comparison function for memo
  return prevProps.skill.id === nextProps.skill.id &&
    prevProps.cooldownEndMs === nextProps.cooldownEndMs &&
    prevProps.isCasting === nextProps.isCasting &&
    prevProps.castProgressMs === nextProps.castProgressMs &&
    prevProps.selectedTarget?.id === nextProps.selectedTarget?.id;
});

SkillButton.displayName = 'SkillButton';

export default React.memo(function UI() {
  const player = useGameStore((state) => state.getMyPlayer());
  const enemies = useGameStore((state) => state.enemies);
  const selectedTargetId = useGameStore((state) => state.selectedTargetId);
  const skillCooldownEndTs = player?.skillCooldownEndTs ?? {};
  const castingSkill = player?.castingSkill ?? null;
  const castingProgressMs = player?.castingProgressMs ?? 0;
  const socket = useGameStore(state => state.socket);
  const currentZoneId = useGameStore(state => state.currentZoneId);
  const flashingSkill = useGameStore(state => state.flashingSkill);
  
  const [isAdmin] = useState(false);
  
  // Memoize selected target lookup
  const selectedTarget = useMemo(() => 
    selectedTargetId ? enemies[selectedTargetId] : null,
    [selectedTargetId, enemies]
  );
  
  // Memoize available skills filtering
  const availableSkills = useMemo(() => {
    if (!player || !player.skillShortcuts) return [];
    
    // Filter out null values and map to skill objects
    return player.skillShortcuts
      .filter(skillId => skillId !== null && isValidSkillId(skillId))
      .map(skillId => SKILLS[skillId as SkillId])
      .filter((skill): skill is Skill => skill !== undefined);
  }, [player?.skillShortcuts]);

  // Debug log when skills panel renders
  useEffect(() => {
    console.log('Skills panel render:', {
      skillCount: availableSkills.length,
      skillIds: availableSkills.map(s => s.id),
      hasPlayer: !!player,
      selectedTargetId
    });
  }, [availableSkills, player, selectedTargetId]);
  
  const currentZone = useMemo(() => 
    GAME_ZONES.find(zone => zone.id === currentZoneId),
    [currentZoneId]
  );
  
  const handleSkillClick = useCallback((skillId: string) => (event: React.MouseEvent) => {
    event.stopPropagation();
    console.log('Attempting to cast skill via UI component');
    
    // Use the unified cast controller
    if (isValidSkillId(skillId)) {
      tryStartCast(skillId, selectedTargetId || undefined);
    } else {
      console.warn(`Invalid skill ID: ${skillId}`);
    }
  }, [selectedTargetId]);

  return (
    <div className="fixed inset-0 pointer-events-none">
      {/* Top UI - Target info */}
      {selectedTarget && (
        <div className="absolute top-5 left-1/2 transform -translate-x-1/2 bg-gray-900/80 p-3 rounded-lg flex items-center space-x-4">
          <div className="text-white font-bold">{selectedTarget.name}</div>
          <div className="w-48 h-2 bg-gray-700 rounded-full overflow-hidden">
            <div 
              className="h-full bg-red-600"
              style={{ width: `${(selectedTarget.health / selectedTarget.maxHealth) * 100}%` }}
            ></div>
          </div>
          <div className="text-white text-sm">
            {selectedTarget.health}/{selectedTarget.maxHealth} HP
          </div>
          {/* Display debuffs on target */}
          <div className="relative pl-2">
            <StatusEffects targetId={selectedTarget.id} position="right" />
          </div>
        </div>
      )}
      
      {/* Right UI - XP Boost Panel */}
      <div className="absolute top-20 right-5 w-64">
        <XPBoostPanel isAdmin={isAdmin} />
      </div>
      
      {/* Bottom UI - Player stats and skills */}
      <div className="absolute bottom-5 left-1/2 transform -translate-x-1/2 w-full max-w-3xl px-5">
        {/* Casting Bar */}
        {castingSkill && (
          <div className="mt-3 bg-gray-900/80 p-3 rounded-lg">
            <div className="flex justify-between text-sm text-white mb-1">
              <div>Casting: {SKILLS[castingSkill]?.name}</div>
              <div>{castingProgressMs}ms / {SKILLS[castingSkill]?.castTimeMs}ms</div>
            </div>
            <div className="w-full h-2 bg-gray-700 rounded-full overflow-hidden">
              <div 
                className="h-full bg-purple-600"
                style={{ 
                  width: `${(castingProgressMs / SKILLS[castingSkill]?.castTimeMs) * 100}%` 
                }}
              ></div>
            </div>
          </div>
        )}
        {/* Player Info */}
        <div className="bg-gray-900/80 p-3 rounded-lg mb-3">
          <div className="flex justify-between items-center mb-2">
            <div className="text-white font-bold">{player?.name || 'Player'} {player?.level || 1}</div>
            <div className="text-gray-300 text-sm">
              XP: {player?.experience || 0}/{player?.experienceToNextLevel || 100}
            </div>
          </div>
          
          {/* Experience Bar */}
          <div className="mb-2">
            <div className="w-full h-1 bg-gray-700 rounded-full overflow-hidden">
              <div 
                className="h-full bg-gray-400"
                style={{ width: `${player?.experience && player?.experienceToNextLevel ? (player.experience / player.experienceToNextLevel) * 100 : 0}%` }}
              ></div>
            </div>
          </div>
          
          {/* Health Bar */}
          <div className="mb-2">
            <div className="w-full h-2 bg-gray-700 rounded-full overflow-hidden">
              <div 
                className="h-full bg-red-600"
                style={{ width: `${player?.health && player?.maxHealth ? (player.health / player.maxHealth) * 100 : 0}%` }}
              ></div>
            </div>
            <div className="flex justify-between text-sm text-white mt-1">
              <div>HP</div>
              <div>{player ? Math.floor(player.health) : 0}/{player?.maxHealth || 100}</div>
            </div>
          </div>
          
          {/* Mana Bar */}
          <div>
            <div className="w-full h-2 bg-gray-700 rounded-full overflow-hidden">
              <div 
                className={`h-full ${useGameStore(state => state.manaBarFlash) ? 'bg-red-600' : 'bg-blue-600'}`}
                style={{ width: `${player?.mana && player?.maxMana ? (player.mana / player.maxMana) * 100 : 0}%` }}
              ></div>
            </div>
            <div className="flex justify-between text-sm text-white mt-1">
              <div>MP</div>
              <div>{player ? Math.floor(player.mana) : 0}/{player?.maxMana || 100}</div>
            </div>
          </div>
          
          {/* Player status effects */}
          <div className="mt-2">
            <StatusEffects targetId="player" inline={true} />
          </div>
        </div>
        
        {/* Skills */}
        <div className="bg-gray-900/80 p-3 rounded-lg">
          <div className="flex space-x-3">
            {availableSkills.map((skill, index) => (
              <SkillButton 
                key={`${skill.id}-${index}`} // Add index to ensure uniqueness
                skill={skill}
                cooldownEndMs={skillCooldownEndTs[skill.id] || 0}
                isCasting={castingSkill === skill.id}
                castProgressMs={castingProgressMs}
                onClick={handleSkillClick(skill.id)}
                selectedTarget={selectedTarget}
                isFlashing={flashingSkill === skill.id}
              />
            ))}
          </div>
        </div>
        
      </div>

      {/* Zone indicator */}
      <div className="absolute top-4 left-4 bg-black/50 text-white p-4 rounded-lg">
        <h2 className="text-xl font-bold">
          {currentZone?.name || 'Wilderness'}
        </h2>
        {currentZone && (
          <div className="text-sm opacity-80">
            <p>{currentZone.description}</p>
            <p className="mt-1">Level {currentZone.minLevel}-{currentZone.maxLevel}</p>
          </div>
        )}
      </div>
      
      {/* Skill Tree UI */}
      <SkillTreeUI />
      
      {/* Connection status indicator */}
      <ConnectionStatus />

      {/* Combat Log */}
      <CombatLog />
    </div>
  );
});

// ==============================================================================
// FILE: app/game/components/World.tsx
// ==============================================================================

'use client';

import { RigidBody } from '@react-three/rapier';
import { useRef, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { Billboard, Text } from '@react-three/drei';
import { useGameStore } from '../systems/gameStore';
import { zoneManager, GAME_ZONES } from '../systems/zoneSystem';
import * as THREE from 'three';

export default function World() {
  const terrainRef = useRef<THREE.Mesh>(null);
  const updatePlayerZone = useGameStore(state => state.updatePlayerZone);
  
  // Update player's current zone
  useFrame(() => {
    updatePlayerZone();
  });
  
  return (
    <>
      {/* Ground - Expanded to 10x size */}
      <RigidBody type="fixed" colliders="trimesh">
        <mesh 
          ref={terrainRef} 
          position={[0, -0.5, 0]} 
          rotation={[-Math.PI / 2, 0, 0]} 
          receiveShadow
        >
          <planeGeometry args={[1000, 1000, 64, 64]} />
          <meshStandardMaterial 
            color="#3a7e4c" 
            roughness={0.8}
          />
        </mesh>
      </RigidBody>
      
      {/* Zone Markers */}
      {GAME_ZONES.map(zone => (
        <group key={zone.id}>
          {/* Zone boundary indicator - semi-transparent circle */}
          <mesh 
            position={[zone.position.x, 0.1, zone.position.z]} 
            rotation={[-Math.PI / 2, 0, 0]}
          >
            <circleGeometry args={[zone.radius, 32]} />
            <meshBasicMaterial 
              color={getZoneColor(zone.id)} 
              transparent 
              opacity={0.1} 
            />
          </mesh>
          
          {/* Zone name text - Raised higher and made smaller */}
          <Billboard 
            position={[zone.position.x, 8, zone.position.z]}
            follow={true}
            lockX={false}
            lockY={false}
            lockZ={false}
          >
            <Text
              color="white"
              fontSize={3}
              outlineWidth={0.3}
              outlineColor="black"
              textAlign="center"
              material-transparent
              material-opacity={0.7}
            >
              {zone.name}
              {`\nLevel ${zone.minLevel}-${zone.maxLevel}`}
            </Text>
          </Billboard>
        </group>
      ))}
      
      {/* Environmental Objects */}
      <group>
        {/* Distribute environmental objects based on zones */}
        {GAME_ZONES.map(zone => (
          <group key={`env-${zone.id}`}>
            {zone.id === 'dark_forest' && (
              <Forest 
                position={[zone.position.x, 0, zone.position.z]} 
                count={50} 
                spread={zone.radius * 0.8} 
              />
            )}
            
            {zone.id === 'rocky_highlands' && (
              <>
                <Rocks 
                  position={[zone.position.x, 0, zone.position.z]} 
                  count={20} 
                  spread={zone.radius * 0.7} 
                />
                <BoulderField 
                  position={[zone.position.x, 0, zone.position.z]} 
                  count={15} 
                  spread={zone.radius * 0.6} 
                />
              </>
            )}
            
            {zone.id === 'misty_lake' && (
              <>
                <mesh 
                  position={[zone.position.x, -0.2, zone.position.z]} 
                  rotation={[-Math.PI / 2, 0, 0]}
                >
                  <circleGeometry args={[zone.radius * 0.6, 32]} />
                  <meshStandardMaterial 
                    color="#0077be" 
                    transparent 
                    opacity={0.8} 
                  />
                </mesh>
                <Bushes 
                  position={[zone.position.x, 0, zone.position.z]} 
                  count={30} 
                  spread={zone.radius * 0.8} 
                />
              </>
            )}
            
            {zone.id === 'starter_meadow' && (
              <>
                <Forest 
                  position={[zone.position.x, 0, zone.position.z]} 
                  count={20} 
                  spread={zone.radius * 0.7} 
                />
                <Bushes 
                  position={[zone.position.x, 0, zone.position.z]} 
                  count={40} 
                  spread={zone.radius * 0.8} 
                />
                <FallenLogs 
                  position={[zone.position.x, 0, zone.position.z]} 
                  count={8} 
                  spread={zone.radius * 0.6} 
                />
              </>
            )}
          </group>
        ))}
      </group>
    </>
  );
}

// Helper function to get color for zone visualization
function getZoneColor(zoneId: string): string {
  const colors: { [key: string]: string } = {
    starter_meadow: '#90EE90',    // Light green
    dark_forest: '#228B22',       // Forest green
    rocky_highlands: '#A0522D',   // Brown
    misty_lake: '#4682B4',        // Steel blue
    cursed_ruins: '#800080',      // Purple
    dragon_peaks: '#FF4500',      // Red-Orange
    shadow_valley: '#483D8B',     // Dark slate blue
    crystal_caverns: '#00CED1'    // Turquoise
  };
  return colors[zoneId] || '#FFFFFF';
}

// Helper component to create a forest with customizable spread
function Forest({ position = [0, 0, 0], count = 5, spread = 40 }) {
  const trees = [];
  
  for (let i = 0; i < count; i++) {
    const x = position[0] + (Math.random() - 0.5) * spread;
    const z = position[2] + (Math.random() - 0.5) * spread;
    
    trees.push(
      <Tree key={`tree-${i}`} position={[x, position[1], z]} scale={1.5 + Math.random() * 1.0} />
    );
  }
  
  return <group>{trees}</group>;
}

// Simple tree component - Made slightly larger
function Tree({ position = [0, 0, 0], scale = 1 }) {
  return (
    <group position={[position[0], position[1], position[2]]} scale={scale}>
      {/* Tree trunk */}
      <mesh position={[0, 1, 0]} castShadow>
        <cylinderGeometry args={[0.2, 0.4, 2]} />
        <meshStandardMaterial color="#8B4513" />
      </mesh>
      
      {/* Tree foliage */}
      <mesh position={[0, 3, 0]} castShadow>
        <coneGeometry args={[1.5, 3, 8]} />
        <meshStandardMaterial color="#2e8b57" />
      </mesh>
    </group>
  );
}

// Rock formation component with customizable spread
function Rocks({ position = [0, 0, 0], count = 3, spread = 20 }) {
  const rocks = [];
  
  for (let i = 0; i < count; i++) {
    const x = position[0] + (Math.random() - 0.5) * spread;
    const z = position[2] + (Math.random() - 0.5) * spread;
    const scale = 1.0 + Math.random() * 1.5; // Larger rocks
    
    rocks.push(
      <RigidBody key={`rock-${i}`} type="fixed" position={[x, position[1], z]}>
        <mesh castShadow>
          <dodecahedronGeometry args={[scale, 0]} />
          <meshStandardMaterial color="#808080" roughness={0.8} />
        </mesh>
      </RigidBody>
    );
  }
  
  return <group>{rocks}</group>;
}

// Larger boulders with more diverse shapes
function BoulderField({ position = [0, 0, 0], count = 5, spread = 30 }) {
  const boulders = [];
  
  for (let i = 0; i < count; i++) {
    const x = position[0] + (Math.random() - 0.5) * spread;
    const z = position[2] + (Math.random() - 0.5) * spread;
    const scale = 2.0 + Math.random() * 2.5; // Much larger than regular rocks
    const rotationY = Math.random() * Math.PI * 2;
    
    // Choose between different boulder shapes
    const shape = Math.floor(Math.random() * 3);
    
    boulders.push(
      <RigidBody key={`boulder-${i}`} type="fixed" position={[x, position[1] + scale/3, z]}>
        <mesh castShadow rotation={[Math.random() * 0.3, rotationY, Math.random() * 0.3]}>
          {shape === 0 && <icosahedronGeometry args={[scale, 0]} />}
          {shape === 1 && <octahedronGeometry args={[scale, 0]} />}
          {shape === 2 && <boxGeometry args={[scale, scale * 0.7, scale * 0.9]} />}
          <meshStandardMaterial color="#615e5d" roughness={0.9} />
        </mesh>
      </RigidBody>
    );
  }
  
  return <group>{boulders}</group>;
}

// Bushes and small vegetation
function Bushes({ position = [0, 0, 0], count = 15, spread = 30 }) {
  const bushes = [];
  
  for (let i = 0; i < count; i++) {
    const x = position[0] + (Math.random() - 0.5) * spread;
    const z = position[2] + (Math.random() - 0.5) * spread;
    const scale = 0.5 + Math.random() * 1.0;
    const rotationY = Math.random() * Math.PI * 2;
    
    // Randomize bush color slightly
    const greenHue = 0.3 + Math.random() * 0.1;
    const colorVariation = Math.random() * 0.2;
    const color = `rgb(${Math.floor((0.15 + colorVariation) * 255)}, 
                      ${Math.floor((greenHue + colorVariation) * 255)}, 
                      ${Math.floor((0.15 + colorVariation) * 255)})`;
    
    bushes.push(
      <group key={`bush-${i}`} position={[x, position[1], z]} rotation={[0, rotationY, 0]} scale={scale}>
        <mesh position={[0, 0.4, 0]} castShadow>
          <sphereGeometry args={[0.8, 8, 8]} />
          <meshStandardMaterial color={color} roughness={0.8} />
        </mesh>
        <mesh position={[0.4, 0.6, 0.4]} castShadow>
          <sphereGeometry args={[0.6, 8, 8]} />
          <meshStandardMaterial color={color} roughness={0.8} />
        </mesh>
        <mesh position={[-0.4, 0.5, 0.2]} castShadow>
          <sphereGeometry args={[0.7, 8, 8]} />
          <meshStandardMaterial color={color} roughness={0.8} />
        </mesh>
      </group>
    );
  }
  
  return <group>{bushes}</group>;
}

// Fallen logs scattered in the forest
function FallenLogs({ position = [0, 0, 0], count = 5, spread = 30 }) {
  const logs = [];
  
  for (let i = 0; i < count; i++) {
    const x = position[0] + (Math.random() - 0.5) * spread;
    const z = position[2] + (Math.random() - 0.5) * spread;
    const scaleX = 0.5 + Math.random() * 0.3;
    const scaleZ = 0.5 + Math.random() * 0.3;
    const length = 3 + Math.random() * 5;
    const rotationY = Math.random() * Math.PI * 2;
    
    logs.push(
      <RigidBody key={`log-${i}`} type="fixed" position={[x, position[1], z]}>
        <group rotation={[0, rotationY, Math.random() * 0.3 - 0.15]}>
          {/* Log body */}
          <mesh position={[0, 0.5 * scaleZ, 0]} castShadow>
            <cylinderGeometry args={[scaleX, scaleX, length, 8]} />
            <mesh rotation={[0, 0, Math.PI / 2]} />
            <meshStandardMaterial color="#654321" roughness={0.9} />
          </mesh>
          
          {/* End caps */}
          <mesh position={[length/2, 0.5 * scaleZ, 0]} rotation={[0, 0, Math.PI / 2]} castShadow>
            <circleGeometry args={[scaleX, 8]} />
            <meshStandardMaterial color="#5a3a1a" roughness={0.95} />
          </mesh>
          
          <mesh position={[-length/2, 0.5 * scaleZ, 0]} rotation={[0, 0, -Math.PI / 2]} castShadow>
            <circleGeometry args={[scaleX, 8]} />
            <meshStandardMaterial color="#5a3a1a" roughness={0.95} />
          </mesh>
        </group>
      </RigidBody>
    );
  }
  
  return <group>{logs}</group>;
}

// Hills and elevated terrain
function Hill({ position = [0, 0, 0], radius = 30, height = 10 }) {
  return (
    <RigidBody type="fixed" position={[position[0], position[1], position[2]]}>
      <mesh castShadow receiveShadow>
        <coneGeometry args={[radius, height, 32]} />
        <meshStandardMaterial color="#4a8f5c" roughness={0.8} />
      </mesh>
    </RigidBody>
  );
}

// ==============================================================================
// FILE: app/game/models/Character.ts
// ==============================================================================

import { StatusEffect } from '../systems/gameStore';
import { CharacterClass } from '../../../shared/classSystem';
import { SkillId } from '../../../shared/skillsDefinition';

export interface Character {
  id: string;
  name: string;
  level: number;
  position: { x: number; y: number; z: number };
  rotation: { x: number; y: number; z: number };
  health: number;
  maxHealth: number;
  mana: number;
  maxMana: number;
  className: CharacterClass;
  unlockedSkills: SkillId[];     // All skills the player has learned
  availableSkillPoints: number;  // Points available to learn new skills
  activeSkill: string | null;    // ID of currently selected skill
  skillShortcuts?: (SkillId | null)[];  // Skills assigned to number keys 1-9
  isAlive?: boolean;             // Character alive status
  experience?: number;           // Current experience points
  experienceToNextLevel?: number; // Experience needed for next level
  statusEffects?: StatusEffect[]; // Active status effects
}

export const createCharacter = (name: string): Character => {
  return {
    id: `character-${Math.random().toString(36).substring(2, 9)}`,
    name,
    level: 1,
    position: { x: 0, y: 0, z: 0 },
    rotation: { x: 0, y: 0, z: 0 },
    health: 100,
    maxHealth: 100,
    mana: 50,
    maxMana: 50,
    className: 'mage',
    unlockedSkills: ['fireball'],
    availableSkillPoints: 0,
    activeSkill: 'fireball',
    skillShortcuts: ['fireball', null, null, null, null, null, null, null, null]
  };
};

// ==============================================================================
// FILE: app/game/models/Enemy.ts
// ==============================================================================

import { StatusEffect } from '../systems/gameStore';

// Configuration object for experience and other game settings
export const GameConfig = {
  experience: {
    baseMultiplier: 2.5,
    levelScaling: 0.25,
    donationBoost: 0.0,
    bonusEvents: {
      active: false,
      multiplier: 1.0
    }
  }
};

export interface Enemy {
  id: string;
  type: string;
  name: string;
  level: number;
  position: { x: number; y: number; z: number };
  spawnPosition: { x: number; y: number; z: number }; // Track original spawn position
  rotation: { x: number; y: number; z: number };
  health: number;
  maxHealth: number;
  isAlive: boolean;
  attackDamage: number;
  attackRange: number;
  baseExperienceValue: number; // Store the base value without multipliers
  experienceValue: number; // Store the final calculated value with multipliers
  statusEffects: StatusEffect[]; // Active status effects (made non-optional)
  targetId?: string | null; // Which player the enemy is targeting
  markedForRemoval?: boolean; // Flag for client-side cleanup
  deathTimeTs?: number; // Timestamp when the enemy died
  attackCooldown?: boolean; // Whether the enemy is in attack cooldown
}


// ==============================================================================
// FILE: app/game/models/Skill.ts
// ==============================================================================

import { SKILLS as SHARED_SKILLS, SkillId, SkillEffect as SharedSkillEffect, SkillEffectType as SharedSkillEffectType } from '../../../shared/skillsDefinition';

// Client-side skill interface that extends the shared definition
// with additional client-specific properties
export interface Skill {
  id: string;
  name: string;
  description: string;
  icon: string; // Path to icon image
  damage?: number;
  manaCost: number;
  cooldownMs: number; // time in milliseconds
  range: number;
  areaOfEffect?: number;
  levelRequired: number;
  effects: SkillEffect[];
  castTimeMs: number; // 0 for instant cast, in ms
  projectileSpeed?: number; // for projectile-based skills
  durationMs?: number; // for skills with duration effects, in ms
}

// Re-export shared types
export type { SkillId };
export type SkillEffectType = SharedSkillEffectType;

// Client-side skill effect interface - explicitly add client-side property
export interface SkillEffect extends SharedSkillEffect {
  clientRendered?: boolean;
}

// Map shared skills to client-side format
function mapSharedSkillToClient(skillId: SkillId): Skill {
  const sharedSkill = SHARED_SKILLS[skillId];
  
  return {
    id: sharedSkill.id,
    name: sharedSkill.name,
    description: sharedSkill.description,
    icon: sharedSkill.icon,
    damage: sharedSkill.dmg,
    manaCost: sharedSkill.manaCost,
    cooldownMs: sharedSkill.cooldownMs,
    range: sharedSkill.range || 10,
    areaOfEffect: sharedSkill.area,
    levelRequired: sharedSkill.levelRequired,
    castTimeMs: sharedSkill.castMs,
    projectileSpeed: sharedSkill.speed,
    effects: sharedSkill.effects
  };
}

// Generate client-side skills from shared definitions
export const SKILLS: Record<string, Skill> = Object.fromEntries(
  Object.keys(SHARED_SKILLS).map(skillId => [
    skillId, 
    mapSharedSkillToClient(skillId as SkillId)
  ])
);

// Special case handling for iceBolt/icebolt name mismatch
SKILLS['icebolt'] = SKILLS['iceBolt'];

// ==============================================================================
// FILE: app/game/skills/Fireball.tsx
// ==============================================================================

'use client';

import { useRef, useState, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { Vector3, MathUtils } from 'three';
import * as THREE from 'three';
import { useGameStore } from '../systems/gameStore';
import { SKILLS } from '../models/Skill';

interface FireballProps {
  startPosition: Vector3;
  targetPosition: Vector3;
  onHit: () => void;
}

export function FireballProjectile({ startPosition, targetPosition, onHit }: FireballProps) {
  const meshRef = useRef<THREE.Mesh>(null);
  const groupRef = useRef<THREE.Group>(null);
  const direction = new Vector3().subVectors(targetPosition, startPosition).normalize();
  const speed = SKILLS.fireball.projectileSpeed || 10;
  const [reachedTarget, setReachedTarget] = useState(false);
  const initialPositionSet = useRef(false);
  const timeOffset = useRef(Math.random() * Math.PI * 2);
  const [intensity, setIntensity] = useState(2);
  
  // Trail particles
  const particles = useRef<Array<{
    position: Vector3;
    scale: number;
    opacity: number;
    lifetimeMs: number;
    rotationSpeed: Vector3;
  }>>([]);
  
  useEffect(() => {
    console.log("Fireball created: From", startPosition, "To", targetPosition);
    
    // Immediately set the initial position when the component mounts
    if (meshRef.current) {
      meshRef.current.position.copy(startPosition);
      initialPositionSet.current = true;
    }
    
    // Clean up particles when component unmounts
    return () => {
      particles.current = [];
    };
  }, [startPosition, targetPosition]);
  
  useFrame((state, delta) => {
    if (reachedTarget || !meshRef.current) return;
    
    // Set initial position only once
    if (!initialPositionSet.current && meshRef.current) {
      meshRef.current.position.copy(startPosition);
      initialPositionSet.current = true;
    }
    
    // Ensure we have a ref before attempting to move
    if (!meshRef.current) return;
    
    // Move projectile toward target
    const moveAmount = direction.clone().multiplyScalar(speed * delta);
    meshRef.current.position.add(moveAmount);
    
    // Make the fireball pulsate
    const pulseFactor = MathUtils.lerp(0.9, 1.1, Math.sin(state.clock.elapsedTime * 8 + timeOffset.current));
    meshRef.current.scale.set(pulseFactor, pulseFactor, pulseFactor);
    
    // Random wobble movement for more dynamic feel
    if (groupRef.current) {
      groupRef.current.position.x += Math.sin(state.clock.elapsedTime * 15) * 0.02;
      groupRef.current.position.y += Math.cos(state.clock.elapsedTime * 12) * 0.02;
    }
    
    // Varying light intensity
    const newIntensity = 2 + Math.sin(state.clock.elapsedTime * 10 + timeOffset.current) * 0.5;
    setIntensity(newIntensity);
    
    // Add trail particles at varying rates based on speed
    const particleChance = 0.5 + (speed / 30);
    if (Math.random() > (1 - particleChance)) {
      particles.current.push({
        position: meshRef.current.position.clone().add(
          new Vector3(
            (Math.random() - 0.5) * 0.3,
            (Math.random() - 0.5) * 0.3,
            (Math.random() - 0.5) * 0.3
          )
        ),
        scale: 0.1 + Math.random() * 0.3,
        opacity: 0.8,
        lifetimeMs: 800 + Math.random() * 300, // 0.5 + 0.3 seconds in ms
        rotationSpeed: new Vector3(
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2
        )
      });
    }
    
    // Update trail particles
    for (let i = particles.current.length - 1; i >= 0; i--) {
      const particle = particles.current[i];
      particle.lifetimeMs -= delta * 1000;
      particle.opacity = Math.max(0, particle.lifetimeMs / 500); // fade out over 0.5s
      particle.scale *= 0.97;
      if (particle.lifetimeMs <= 0) {
        particles.current.splice(i, 1);
      }
    }
    
    // Check if we reached the target
    const currentDist = meshRef.current.position.distanceTo(targetPosition);
    if (currentDist < 0.8) {
      console.log("Fireball hit target");
      setReachedTarget(true);
      onHit();
    }
    
    // Rotate to face direction
    meshRef.current.lookAt(
      meshRef.current.position.clone().add(direction)
    );
    
    // Spin the fireball around its forward axis
    meshRef.current.rotateZ(delta * 5);
  });
  
  if (reachedTarget) {
    return <FireballImpact position={targetPosition} />;
  }
  
  return (
    <group ref={groupRef}>
      {/* Main fireball */}
      <mesh ref={meshRef}>
        <sphereGeometry args={[0.3, 16, 16]} />
        <meshStandardMaterial
          emissive="#ff6600"
          emissiveIntensity={intensity}
          color="#ff0000"
          toneMapped={false}
        />
        <pointLight color="#ff6600" intensity={intensity} distance={5} />
      </mesh>
      
      {/* Inner core - more intense glow */}
      <mesh position={meshRef.current ? meshRef.current.position : startPosition} scale={0.7}>
        <sphereGeometry args={[0.2, 12, 12]} />
        <meshStandardMaterial
          emissive="#ffff00"
          emissiveIntensity={intensity * 1.2}
          color="#ffcc00"
          toneMapped={false}
        />
      </mesh>
      
      {/* Trail particles */}
      {particles.current.map((particle, index) => (
        <mesh key={index} position={particle.position}>
          <sphereGeometry args={[particle.scale, 8, 8]} />
          <meshStandardMaterial
            emissive="#ff6600"
            emissiveIntensity={1}
            color="#ff4500"
            transparent
            opacity={particle.opacity}
          />
        </mesh>
      ))}
    </group>
  );
}

interface ImpactProps {
  position: Vector3;
}

function FireballImpact({ position }: ImpactProps) {
  const [lifetimeMs, setLifetimeMs] = useState(2500);
  const meshRef = useRef<THREE.Mesh>(null);
  const fragments = useRef<Array<{
    position: Vector3;
    velocity: Vector3;
    scale: number;
    opacity: number;
    rotationSpeed: Vector3;
  }>>([]);
  
  // Create explosion fragments
  useEffect(() => {
    // Create fragments that fly outward
    for (let i = 0; i < 15; i++) {
      const angle = Math.random() * Math.PI * 2;
      const height = Math.random() * Math.PI - Math.PI / 2;
      const speed = 2 + Math.random() * 5;
      
      fragments.current.push({
        position: position.clone(),
        velocity: new Vector3(
          Math.cos(angle) * Math.cos(height) * speed,
          Math.sin(height) * speed,
          Math.sin(angle) * Math.cos(height) * speed
        ),
        scale: 0.1 + Math.random() * 0.2,
        opacity: 1.0,
        rotationSpeed: new Vector3(
          Math.random() * 5,
          Math.random() * 5, 
          Math.random() * 5
        )
      });
    }
  }, [position]);
  
  useFrame((state, delta) => {
    // Cap delta to prevent large jumps with low frame rates
    const cappedDelta = Math.min(delta, 0.1);
    
    if (meshRef.current) {
      // Expand impact with controlled scaling instead of additive
      const maxScale = 5.0;
      const currentProgress = 1 - (lifetimeMs / 2500);
      const targetScale = 1 + (maxScale * currentProgress);
      
      // Use lerp for smoother scaling regardless of frame rate
      meshRef.current.scale.set(targetScale, targetScale, targetScale);
      
      // Decrease opacity over time matched to the new lifetime
      if (meshRef.current.material instanceof THREE.Material) {
        (meshRef.current.material as THREE.MeshStandardMaterial).opacity = lifetimeMs / 2500;
      }
    }
    
    // Update fragments
    for (const fragment of fragments.current) {
      // Apply gravity
      fragment.velocity.y -= delta * 4;
      
      // Update position
      fragment.position.addScaledVector(fragment.velocity, delta);
      
      // Fade out more slowly
      fragment.opacity = Math.max(0, fragment.opacity - delta * 0.7);
      
      // Shrink slightly, but more slowly
      fragment.scale *= 0.99;
    }
    
    // Update lifetime at a slower rate
    setLifetimeMs(prev => Math.max(0, prev - delta * 800));
  });
  
  if (lifetimeMs <= 0) return null;
  
  return (
    <group>
      {/* Main impact shockwave */}
      <mesh ref={meshRef} position={position}>
        <sphereGeometry args={[0.5, 16, 16]} />
        <meshStandardMaterial
          emissive="#ff6600"
          emissiveIntensity={2}
          color="#ff4500"
          transparent
          opacity={lifetimeMs / 2500}
        />
        <pointLight color="#ff6600" intensity={4 * (lifetimeMs / 2500)} distance={10} />
      </mesh>
      
      {/* Secondary flash */}
      <mesh position={position} scale={lifetimeMs < 500 ? (lifetimeMs / 500) * 2 : 1}>
        <sphereGeometry args={[0.8, 12, 12]} />
        <meshStandardMaterial
          emissive="#ffff00"
          emissiveIntensity={3}
          color="#ffcc00"
          transparent
          opacity={Math.min(1, (lifetimeMs / 833))}
        />
      </mesh>
      
      {/* Flying fragments */}
      {fragments.current.map((fragment, index) => (
        <mesh
          key={index}
          position={fragment.position}
          scale={fragment.scale}
        >
          <dodecahedronGeometry args={[1, 0]} />
          <meshStandardMaterial
            emissive="#ff6600"
            emissiveIntensity={2}
            color="#ff4500"
            transparent
            opacity={fragment.opacity}
          />
        </mesh>
      ))}
    </group>
  );
}

// ==============================================================================
// FILE: app/game/skills/IceBolt.tsx
// ==============================================================================

'use client';

import { useRef, useState, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { Vector3, MathUtils } from 'three';
import * as THREE from 'three';
import { useGameStore } from '../systems/gameStore';
import { SKILLS } from '../models/Skill';

interface IceBoltProps {
  startPosition: Vector3;
  targetPosition: Vector3;
  onHit: () => void;
}

export function IceBoltProjectile({ startPosition, targetPosition, onHit }: IceBoltProps) {
  const meshRef = useRef<THREE.Mesh>(null);
  const groupRef = useRef<THREE.Group>(null);
  const direction = new Vector3().subVectors(targetPosition, startPosition).normalize();
  const speed = SKILLS.icebolt.projectileSpeed || 15;
  const [reachedTarget, setReachedTarget] = useState(false);
  const initialPositionSet = useRef(false);
  const spiralOffset = useRef(Math.random() * Math.PI * 2);
  const spiralRadius = useRef(0.1 + Math.random() * 0.1);
  const [intensity, setIntensity] = useState(1.5);
  
  // Ice crystal particles
  const crystals = useRef<Array<{
    position: Vector3;
    scale: number;
    opacity: number;
    lifetimeMs: number;
    rotation: { x: number, y: number, z: number };
  }>>([]);
  
  useEffect(() => {
    console.log("Ice Bolt created: From", startPosition, "To", targetPosition);
    // Clean up particles when component unmounts
    return () => {
      crystals.current = [];
    };
  }, [startPosition, targetPosition]);
  
  useFrame((state, delta) => {
    if (reachedTarget || !meshRef.current) return;
    
    // Set initial position only once
    if (!initialPositionSet.current && meshRef.current) {
      meshRef.current.position.copy(startPosition);
      initialPositionSet.current = true;
    }
    
    // Calculate the spiral path around the direct line to target
    const spiralTime = state.clock.elapsedTime * 5;
    const spiralVector = new Vector3();
    
    // Find perpendicular vectors to create a spiral around the direction vector
    const up = new Vector3(0, 1, 0);
    const right = new Vector3().crossVectors(direction, up).normalize();
    if (right.lengthSq() === 0) {
      right.set(1, 0, 0); // Fallback if direction is parallel to up
    }
    const perpendicular = new Vector3().crossVectors(direction, right).normalize();
    
    // Create a spiral motion
    spiralVector.addScaledVector(right, Math.cos(spiralTime + spiralOffset.current) * spiralRadius.current);
    spiralVector.addScaledVector(perpendicular, Math.sin(spiralTime + spiralOffset.current) * spiralRadius.current);
    
    // Move projectile toward target with spiral offset
    const directMove = direction.clone().multiplyScalar(speed * delta);
    meshRef.current.position.add(directMove);
    meshRef.current.position.add(spiralVector.clone().multiplyScalar(0.1));
    
    // Pulsating ice effect
    const pulseFactor = MathUtils.lerp(0.9, 1.1, Math.sin(state.clock.elapsedTime * 10) * 0.5 + 0.5);
    if (meshRef.current) {
      meshRef.current.scale.set(pulseFactor, pulseFactor, pulseFactor);
    }
    
    // Rotate the ice bolt for a spinning effect with wobble
    if (meshRef.current) {
      meshRef.current.rotation.z += delta * 12;
      meshRef.current.rotation.x += delta * Math.sin(state.clock.elapsedTime * 3) * 0.2;
    }
    
    // Varying light intensity
    const newIntensity = 1.5 + Math.sin(state.clock.elapsedTime * 8) * 0.3;
    setIntensity(newIntensity);
    
    // Add trail crystal at varying rates
    const crystalChance = 0.4 + (speed / 40);
    if (Math.random() > (1 - crystalChance)) {
      crystals.current.push({
        position: meshRef.current.position.clone().add(
          new Vector3(
            (Math.random() - 0.5) * 0.3,
            (Math.random() - 0.5) * 0.3,
            (Math.random() - 0.5) * 0.3
          )
        ),
        scale: 0.05 + Math.random() * 0.15,
        opacity: 0.9,
        lifetimeMs: 700 + Math.random() * 300, // 0.4 + 0.3 seconds in ms
        rotation: {
          x: Math.random() * Math.PI,
          y: Math.random() * Math.PI,
          z: Math.random() * Math.PI
        }
      });
    }
    
    // Update trail crystals
    for (let i = crystals.current.length - 1; i >= 0; i--) {
      const crystal = crystals.current[i];
      crystal.lifetimeMs -= delta * 1000;
      crystal.opacity = Math.max(0, crystal.lifetimeMs / 450); // fade out over 0.45s
      crystal.scale *= 0.97;
      if (crystal.lifetimeMs <= 0) {
        crystals.current.splice(i, 1);
      }
    }
    
    // Check if we reached the target
    const currentDist = meshRef.current.position.distanceTo(targetPosition);
    if (currentDist < 0.8) {
      console.log("Ice Bolt hit target");
      setReachedTarget(true);
      onHit();
    }
    
    // Look in direction of travel
    meshRef.current.lookAt(
      meshRef.current.position.clone().add(direction)
    );
  });
  
  if (reachedTarget) {
    return <IceBoltImpact position={targetPosition} />;
  }
  
  return (
    <group ref={groupRef}>
      {/* Main ice bolt */}
      <mesh ref={meshRef}>
        <coneGeometry args={[0.2, 0.9, 8]} />
        <meshStandardMaterial
          emissive="#88cfff"
          emissiveIntensity={intensity}
          color="#ffffff"
          toneMapped={false}
          transparent
          opacity={0.8}
        />
        <pointLight color="#88cfff" intensity={intensity} distance={4} />
      </mesh>
      
      {/* Secondary ice shard components */}
      <group position={meshRef.current ? meshRef.current.position : startPosition}>
        <mesh rotation={[Math.PI / 4, 0, Math.PI / 6]} scale={0.6}>
          <octahedronGeometry args={[0.3, 0]} />
          <meshStandardMaterial
            emissive="#a0d8ff"
            emissiveIntensity={intensity * 0.7}
            color="#ffffff"
            transparent
            opacity={0.7}
          />
        </mesh>
        <mesh rotation={[-Math.PI / 4, Math.PI / 2, -Math.PI / 6]} scale={0.5} position={[0, 0.2, 0]}>
          <octahedronGeometry args={[0.25, 0]} />
          <meshStandardMaterial
            emissive="#cceeff"
            emissiveIntensity={intensity * 0.5}
            color="#ffffff"
            transparent
            opacity={0.6}
          />
        </mesh>
      </group>
      
      {/* Frost aura */}
      <mesh position={meshRef.current ? meshRef.current.position : startPosition} scale={1.2}>
        <sphereGeometry args={[0.3, 12, 12]} />
        <meshStandardMaterial
          emissive="#88cfff"
          emissiveIntensity={0.5}
          color="#ffffff"
          transparent
          opacity={0.2}
        />
      </mesh>
      
      {/* Trail crystals */}
      {crystals.current.map((crystal, index) => (
        <mesh 
          key={index} 
          position={crystal.position}
          rotation={[crystal.rotation.x, crystal.rotation.y, crystal.rotation.z]}
        >
          <octahedronGeometry args={[crystal.scale, 0]} />
          <meshStandardMaterial
            emissive="#88cfff"
            emissiveIntensity={1}
            color="#b0e0ff"
            transparent
            opacity={crystal.opacity}
          />
        </mesh>
      ))}
    </group>
  );
}

interface ImpactProps {
  position: Vector3;
}

function IceBoltImpact({ position }: ImpactProps) {
  const [lifetimeMs, setLifetimeMs] = useState(3000);
  const mainImpactRef = useRef<THREE.Mesh>(null);
  const iceCrystalsRef = useRef<Array<{
    position: Vector3;
    scale: number;
    opacity: number;
    rotation: Vector3;
    velocity: Vector3;
  }>>([]);
  
  // Create ice crystal explosion
  useEffect(() => {
    // Create outward crystals
    for (let i = 0; i < 20; i++) {
      const angle = (i / 20) * Math.PI * 2;
      const height = (Math.random() - 0.5) * Math.PI;
      const distance = 0.2 + Math.random() * 0.4;
      const speed = 1 + Math.random() * 3;
      
      const direction = new Vector3(
        Math.cos(angle) * Math.cos(height),
        Math.sin(height),
        Math.sin(angle) * Math.cos(height)
      ).normalize();
      
      iceCrystalsRef.current.push({
        position: position.clone().add(direction.clone().multiplyScalar(distance)),
        scale: 0.05 + Math.random() * 0.15,
        opacity: 1.0,
        rotation: new Vector3(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        ),
        velocity: direction.multiplyScalar(speed)
      });
    }
  }, [position]);
  
  useFrame((state, delta) => {
    // Update lifetime at a slower rate
    setLifetimeMs(prev => Math.max(0, prev - delta * 800));
    
    // Expand the main impact effect
    if (mainImpactRef.current) {
      const expansionScale = Math.min(2, 0.5 + (1 - lifetimeMs / 3000) * 3); 
      mainImpactRef.current.scale.set(expansionScale, expansionScale, expansionScale);
      
      if (mainImpactRef.current.material instanceof THREE.Material) {
        (mainImpactRef.current.material as THREE.MeshStandardMaterial).opacity = Math.min(1, lifetimeMs / 600);
      }
    }      // Update crystal fragments
    for (const crystal of iceCrystalsRef.current) {
      // Apply movement and some gravity, but slower
      crystal.velocity.y -= delta * 1.5; // Gentler gravity
      crystal.position.addScaledVector(crystal.velocity, delta * 0.7); // Slower movement
      
      // Add some rotation, slightly slower
      crystal.rotation.x += delta * (Math.random() * 0.3 + 0.3);
      crystal.rotation.y += delta * (Math.random() * 0.3 + 0.3);
      crystal.rotation.z += delta * (Math.random() * 0.3 + 0.3);
      
      // Set opacity based on lifetime, slower fade-out
      crystal.opacity = Math.max(0, lifetimeMs * 0.6 / 3000);
      
      // Shrink more gradually
      crystal.scale *= 0.995;
    }
  });
  
  if (lifetimeMs <= 0) return null;
  
  return (
    <group>
      {/* Initial flash */}
      <mesh position={position}>
        <sphereGeometry args={[0.6, 16, 16]} />
        <meshStandardMaterial
          emissive="#ffffff"
          emissiveIntensity={3}
          color="#88cfff"
          transparent
          opacity={Math.min(1, lifetimeMs / 300)}
        />
      </mesh>
      
      {/* Main frost sphere */}
      <mesh ref={mainImpactRef} position={position}>
        <sphereGeometry args={[0.5, 16, 16]} />
        <meshStandardMaterial
          emissive="#88cfff"
          emissiveIntensity={2}
          color="#ffffff"
          transparent
          opacity={lifetimeMs * 0.7 / 1000}
        />
        <pointLight color="#88cfff" intensity={2 * (lifetimeMs / 1000)} distance={8} />
      </mesh>
      
      {/* Frost ring */}
      <mesh position={position} rotation={[Math.PI / 2, 0, 0]} scale={0.3 + (1 - lifetimeMs / 1500) * 2.5}>
        <torusGeometry args={[1, 0.1, 16, 36]} />
        <meshStandardMaterial
          emissive="#88cfff"
          emissiveIntensity={1}
          color="#ffffff"
          transparent
          opacity={Math.max(0, lifetimeMs * 0.7 / 1000)}
        />
      </mesh>
      
      {/* Ice crystal fragments */}
      {iceCrystalsRef.current.map((crystal, index) => (
        <mesh 
          key={index} 
          position={crystal.position}
          rotation={[crystal.rotation.x, crystal.rotation.y, crystal.rotation.z]}
          scale={crystal.scale}
        >
          <octahedronGeometry args={[1, 0]} />
          <meshStandardMaterial
            emissive="#88cfff"
            emissiveIntensity={0.5}
            color="#ffffff"
            transparent
            opacity={crystal.opacity}
          />
        </mesh>
      ))}
      
      {/* Ground frost effect (appears to spread on ground) */}
      <mesh position={[position.x, 0.05, position.z]} rotation={[-Math.PI / 2, 0, 0]} scale={1 + (1 - lifetimeMs / 1500) * 3}>
        <circleGeometry args={[1, 32]} />
        <meshStandardMaterial
          emissive="#88cfff"
          emissiveIntensity={0.5}
          color="#ffffff"
          transparent
          opacity={Math.max(0, lifetimeMs * 0.4 / 1000)}
        />
      </mesh>
    </group>
  );
}

// ==============================================================================
// FILE: app/game/skills/Petrify.tsx
// ==============================================================================

'use client';

import { useRef, useState, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { Vector3, MathUtils } from 'three';
import * as THREE from 'three';
import { SKILLS } from '../models/Skill';

interface PetrifyProps {
  startPosition: Vector3;
  targetPosition: Vector3;
  onHit: () => void;
}

export function PetrifyProjectile({ startPosition, targetPosition, onHit }: PetrifyProps) {
  const meshRef = useRef<THREE.Mesh>(null);
  const coreRef = useRef<THREE.Mesh>(null);
  const orbitRef = useRef<THREE.Group>(null);
  const [reachedTarget, setReachedTarget] = useState(false);
  const initialPositionSet = useRef(false);
  const [intensity, setIntensity] = useState(2.2);
  const timeOffset = useRef(Math.random() * 10);

  // Dust particles that orbit the main projectile
  const particles = useRef<Array<{
    position: Vector3;
    scale: number;
    opacity: number;
    lifetimeMs: number;
    orbitSpeed: number;
    orbitRadius: number;
    orbitOffset: number;
    height: number;
  }>>([]);

  const direction = new Vector3().subVectors(targetPosition, startPosition).normalize();
  const speed = 12; // Slightly slower than ice bolt for a weightier feel

  useEffect(() => {
    console.log("Petrify created: From", startPosition, "To", targetPosition);
    
    // Create initial orbiting dust particles
    for (let i = 0; i < 12; i++) {
      particles.current.push({
        position: new Vector3(),
        scale: 0.05 + Math.random() * 0.12,
        opacity: 0.7 + Math.random() * 0.3,
        lifetimeMs: 1000,
        orbitSpeed: 1.0 + Math.random() * 2.0,
        orbitRadius: 0.3 + Math.random() * 0.4,
        orbitOffset: Math.random() * Math.PI * 2,
        height: Math.random() * 0.4 - 0.2
      });
    }
    
    // Clean up particles when component unmounts
    return () => {
      particles.current = [];
    };
  }, [startPosition, targetPosition]);

  useFrame((state, delta) => {
    if (reachedTarget || !meshRef.current) return;

    // Set initial position only once
    if (!initialPositionSet.current && meshRef.current) {
      meshRef.current.position.copy(startPosition);
      initialPositionSet.current = true;
    }

    // Move projectile toward target
    const moveAmount = direction.clone().multiplyScalar(speed * delta);
    meshRef.current.position.add(moveAmount);

    // Orbital rotation effect
    if (orbitRef.current) {
      orbitRef.current.rotation.y += delta * 2.0;
      orbitRef.current.rotation.z += delta * 1.2;
    }

    // Pulsate the core
    if (coreRef.current) {
      const pulseFactor = MathUtils.lerp(0.8, 1.2, Math.sin(state.clock.elapsedTime * 5 + timeOffset.current) * 0.5 + 0.5);
      coreRef.current.scale.set(pulseFactor, pulseFactor, pulseFactor);
    }

    // Varying light intensity
    const newIntensity = 2.2 + Math.sin(state.clock.elapsedTime * 6 + timeOffset.current) * 0.3;
    setIntensity(newIntensity);

    // Update orbiting particles
    for (const particle of particles.current) {
      const time = state.clock.elapsedTime * particle.orbitSpeed + particle.orbitOffset;
      
      // Orbit around the projectile
      particle.position.x = Math.cos(time) * particle.orbitRadius;
      particle.position.z = Math.sin(time) * particle.orbitRadius;
      particle.position.y = Math.sin(time * 1.5) * 0.1 + particle.height;
    }

    // Check if we reached the target
    const currentDist = meshRef.current.position.distanceTo(targetPosition);
    if (currentDist < 0.8) {
      console.log("Petrify hit target");
      setReachedTarget(true);
      onHit();
    }

    // Look in direction of travel
    meshRef.current.lookAt(meshRef.current.position.clone().add(direction));
  });

  if (reachedTarget) {
    return <PetrifyImpact position={targetPosition} />;
  }

  return (
    <group>
      {/* Main petrify projectile body */}
      <mesh ref={meshRef}>
        <dodecahedronGeometry args={[0.35, 0]} />
        <meshStandardMaterial
          emissive="#aaaaaa"
          emissiveIntensity={intensity * 0.3}
          color="#444444"
          roughness={0.7}
          metalness={0.2}
        />

        {/* Inner glowing core */}
        <mesh ref={coreRef} scale={0.6}>
          <sphereGeometry args={[0.5, 16, 16]} />
          <meshStandardMaterial
            emissive="#c0c0c0"
            emissiveIntensity={intensity}
            color="#606060"
            transparent={true}
            opacity={0.9}
          />
        </mesh>

        {/* Stone fragments orbiting the core */}
        <group ref={orbitRef}>
          <mesh position={[0.25, 0, 0]} scale={0.2}>
            <tetrahedronGeometry args={[1, 0]} />
            <meshStandardMaterial
              color="#505050"
              roughness={1.0}
              metalness={0.1}
            />
          </mesh>
          <mesh position={[-0.2, 0.15, 0.2]} rotation={[0.5, 0.3, 0.2]} scale={0.15}>
            <dodecahedronGeometry args={[1, 0]} />
            <meshStandardMaterial
              color="#606060"
              roughness={1.0}
              metalness={0.1}
            />
          </mesh>
          <mesh position={[0, -0.2, -0.2]} rotation={[0.2, 0.5, 0]} scale={0.18}>
            <octahedronGeometry args={[1, 0]} />
            <meshStandardMaterial
              color="#555555"
              roughness={0.9}
              metalness={0.1}
            />
          </mesh>
        </group>

        {/* Light source */}
        <pointLight color="#e0e0e0" intensity={intensity * 0.6} distance={4} />
      </mesh>

      {/* Dust particles orbiting the projectile */}
      {particles.current.map((particle, index) => (
        <mesh 
          key={index} 
          position={[
            meshRef.current ? meshRef.current.position.x + particle.position.x : startPosition.x,
            meshRef.current ? meshRef.current.position.y + particle.position.y : startPosition.y,
            meshRef.current ? meshRef.current.position.z + particle.position.z : startPosition.z
          ]}
          scale={particle.scale}
        >
          <dodecahedronGeometry args={[1, 0]} />
          <meshStandardMaterial
            color="#909090"
            transparent={true}
            opacity={particle.opacity * 0.7}
            roughness={1.0}
          />
        </mesh>
      ))}
    </group>
  );
}

interface ImpactProps {
  position: Vector3;
}

function PetrifyImpact({ position }: ImpactProps) {
  const [lifetimeMs, setLifetimeMs] = useState(4000);
  const waveRef = useRef<THREE.Mesh>(null);
  const crystalsRef = useRef<THREE.Group>(null);
  const centralPillarRef = useRef<THREE.Mesh>(null);
  const [initialScale] = useState(() => 0.1 + Math.random() * 0.2);
  
  // Stone fragments that emerge from the ground
  const fragments = useRef<Array<{
    position: Vector3;
    rotation: Vector3;
    initialScale: number;
    targetScale: number;
    currentScale: number;
    velocity: Vector3;
    rotationSpeed: Vector3;
    riseDelayMs: number;
    lifetime: number;
    retreating: boolean;
  }>>([]);
  
  // Dust particles for the impact
  const dustParticles = useRef<Array<{
    position: Vector3;
    initialY: number;
    scale: number;
    opacity: number;
    velocity: Vector3;
    rotationSpeed: Vector3;
    rotation: Vector3;
    lifetimeMs: number;
    maxLifetimeMs: number;
  }>>([]);

  useEffect(() => {
    // Create stone fragments that emerge from the ground in a circular pattern
    for (let i = 0; i < 24; i++) {
      const angle = (i / 24) * Math.PI * 2;
      const distance = 0.5 + Math.random() * 0.8;
      const delay = (distance / 2.0) * 0.5; // Outer fragments rise later
      
      fragments.current.push({
        position: new Vector3(
          position.x + Math.cos(angle) * distance,
          0, // Start at ground level
          position.z + Math.sin(angle) * distance
        ),
        rotation: new Vector3(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        ),
        initialScale: 0,
        targetScale: 0.1 + Math.random() * 0.2,
        currentScale: 0,
        velocity: new Vector3(0, 1 + Math.random() * 2, 0),
        rotationSpeed: new Vector3(
          Math.random() * 0.5,
          Math.random() * 0.5,
          Math.random() * 0.5
        ),
        riseDelayMs: delay,
        lifetime: 2.5,
        retreating: false
      });
    }
    
    // Create dust particles that burst outward
    for (let i = 0; i < 30; i++) {
      const angle = Math.random() * Math.PI * 2;
      const height = Math.random() * Math.PI - Math.PI / 2;
      const speed = 1 + Math.random() * 3;
      const maxLifetime = 1.0 + Math.random() * 1.0;
      
      const direction = new Vector3(
        Math.cos(angle) * Math.cos(height),
        Math.abs(Math.sin(height)) * 1.5, // Ensure dust goes upward
        Math.sin(angle) * Math.cos(height)
      ).normalize();
      
      dustParticles.current.push({
        position: position.clone().add(
          new Vector3(
            (Math.random() - 0.5) * 0.2,
            0,
            (Math.random() - 0.5) * 0.2
          )
        ),
        initialY: position.y,
        scale: 0.05 + Math.random() * 0.15,
        opacity: 0.5 + Math.random() * 0.5,
        velocity: direction.multiplyScalar(speed),
        rotationSpeed: new Vector3(
          Math.random() * 5,
          Math.random() * 5,
          Math.random() * 5
        ),
        rotation: new Vector3(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        ),
        lifetimeMs: maxLifetime,
        maxLifetimeMs: maxLifetime
      });
    }
    
  }, [position]);
  
  useFrame((state, delta) => {
    const cappedDeltaMs = Math.min(delta, 0.1) * 1000;
    setLifetimeMs(prev => Math.max(0, prev - cappedDeltaMs));
    
    // Expand stone wave on ground
    if (waveRef.current) {
      // Calculate wave scale based on lifetime (grows quickly, then slows)
      const waveProgress = 1 - (lifetimeMs / 4000);
      const waveScale = Math.min(4, waveProgress * 5);
      waveRef.current.scale.set(waveScale, 1, waveScale);
      
      // Adjust opacity to fade out over time
      if (waveRef.current.material instanceof THREE.Material) {
        (waveRef.current.material as THREE.MeshStandardMaterial).opacity = Math.max(0, lifetimeMs * 0.4 / 1600);
      }
    }
    
    // Rise and rotate central pillar
    if (centralPillarRef.current) {
      if (lifetimeMs > 2400) {
        const riseProgress = (4000 - lifetimeMs) * 2 / 1600;
        const targetHeight = Math.min(0.8, riseProgress * 0.5);
        centralPillarRef.current.position.y = targetHeight / 2;
        centralPillarRef.current.scale.y = targetHeight;
      } else if (lifetimeMs > 800) {
        // Hold the pillar up for longer
        centralPillarRef.current.position.y = 0.4;
        centralPillarRef.current.scale.y = 0.8;
      } else {
        // Sink back down in final phase
        const sinkProgress = (lifetimeMs / 800);
        const targetHeight = Math.max(0, sinkProgress * 0.8);
        centralPillarRef.current.position.y = targetHeight / 2;
        centralPillarRef.current.scale.y = targetHeight;
      }
      
      // Rotate slowly
      centralPillarRef.current.rotation.y += cappedDeltaMs * 0.5;
    }
    
    // Animate central crystals
    if (crystalsRef.current) {
      // Rotate crystal group, but slower for longer effect
      crystalsRef.current.rotation.y += cappedDeltaMs * 0.6;
      
      // Pulse scale
      const pulsePhase = Math.sin(state.clock.elapsedTime * 2) * 0.1 + 0.9;
      
      // Scale based on lifetime
      let scaleMultiplier;
      if (lifetimeMs > 2400) {
        // Growing phase - slower growth for longer duration
        scaleMultiplier = ((4000 - lifetimeMs) / 1600) * pulsePhase;
      } else if (lifetimeMs > 800) {
        // Maintain full size during middle of animation
        scaleMultiplier = pulsePhase;
      } else {
        // Shrinking phase at the end
        scaleMultiplier = (lifetimeMs / 800) * pulsePhase;
      }
      crystalsRef.current.scale.set(
        scaleMultiplier, 
        scaleMultiplier, 
        scaleMultiplier
      );
    }
    
    // Update stone fragments
    for (const fragment of fragments.current) {
      // Handle delay
      if (fragment.riseDelayMs > 0) {
        fragment.riseDelayMs -= cappedDeltaMs;
        continue;
      }
      
      if (!fragment.retreating) {
        // Rising from the ground
        if (fragment.position.y < (0.3 + Math.random() * 0.3)) {
          fragment.position.addScaledVector(fragment.velocity, cappedDeltaMs * 0.4); // Slower rise
          
          // Gradually grow to target size
          fragment.currentScale = MathUtils.lerp(
            fragment.currentScale,
            fragment.targetScale,
            cappedDeltaMs * 2.5 // Slower scaling
          );
        } else {
          // Hover and rotate at peak
          fragment.position.y += Math.sin(state.clock.elapsedTime * 1.5) * cappedDeltaMs * 0.03;
        }
        
        // Start retreating when lifetime is below threshold
        if (lifetimeMs < 1500) { // Later retreat time
          fragment.retreating = true;
          // Reverse velocity for retreat
          fragment.velocity.multiplyScalar(-0.3); // Slower retreat
        }
      } else {
        // Retreating back into ground
        if (fragment.position.y > 0) {
          fragment.position.addScaledVector(fragment.velocity, cappedDeltaMs * 0.8); // Slower descent
          
          // Shrink as it retreats
          fragment.currentScale = MathUtils.lerp(
            fragment.currentScale,
            0,
            cappedDeltaMs * 4
          );
        }
      }
      
      // Apply rotation
      fragment.rotation.x += fragment.rotationSpeed.x * cappedDeltaMs;
      fragment.rotation.y += fragment.rotationSpeed.y * cappedDeltaMs;
      fragment.rotation.z += fragment.rotationSpeed.z * cappedDeltaMs;
    }
    
    // Update dust particles
    for (let i = dustParticles.current.length - 1; i >= 0; i--) {
      const dust = dustParticles.current[i];
      
      // Apply gravity
      dust.velocity.y -= cappedDeltaMs * 3;
      
      // Update position
      dust.position.addScaledVector(dust.velocity, cappedDeltaMs);
      
      // Update rotation
      dust.rotation.x += dust.rotationSpeed.x * cappedDeltaMs;
      dust.rotation.y += dust.rotationSpeed.y * cappedDeltaMs;
      dust.rotation.z += dust.rotationSpeed.z * cappedDeltaMs;
      
      // Update lifetime
      dust.lifetimeMs -= cappedDeltaMs;
      dust.opacity = Math.max(0, dust.lifetimeMs / dust.maxLifetimeMs) * 0.5;
      
      // Remove dead particles
      if (dust.lifetimeMs <= 0) {
        dustParticles.current.splice(i, 1);
      }
    }
  });
  
  if (lifetimeMs <= 0) return null;
  
  return (
    <group>
      {/* Ground circular wave that expands outward */}
      <mesh 
        ref={waveRef} 
        position={[position.x, 0.02, position.z]} 
        rotation={[-Math.PI / 2, 0, 0]}
      >
        <ringGeometry args={[0.2, 0.7, 32]} />
        <meshStandardMaterial
          color="#757575"
          transparent={true}
          opacity={0.6}
          depthWrite={false}
        />
      </mesh>
      
      {/* Central pillar of stone that rises up */}
      <mesh
        ref={centralPillarRef}
        position={[position.x, 0, position.z]}
        scale={[0.4, 0, 0.4]}
      >
        <cylinderGeometry args={[1, 1.3, 1, 6, 1]} />
        <meshStandardMaterial
          color="#5a5a5a"
          roughness={0.9}
          metalness={0.2}
        />
      </mesh>
      
      {/* Crystal formation at the center */}
      <group
        ref={crystalsRef}
        position={[position.x, 0.4, position.z]}
      >
        <mesh rotation={[0.5, 0, 0.3]}>
          <octahedronGeometry args={[0.3, 0]} />
          <meshStandardMaterial
            color="#444444"
            emissive="#a0a0a0"
            emissiveIntensity={0.2}
            roughness={0.7}
            metalness={0.3}
          />
        </mesh>
        
        <mesh position={[0.1, 0.15, 0]} rotation={[-0.3, 0.5, 0.1]}>
          <octahedronGeometry args={[0.2, 0]} />
          <meshStandardMaterial
            color="#555555"
            emissive="#a0a0a0"
            emissiveIntensity={0.2}
            roughness={0.7}
            metalness={0.3}
          />
        </mesh>
        
        <mesh position={[-0.15, 0.08, 0.05]} rotation={[0.2, -0.3, 0.5]}>
          <octahedronGeometry args={[0.25, 0]} />
          <meshStandardMaterial
            color="#505050"
            emissive="#a0a0a0"
            emissiveIntensity={0.2}
            roughness={0.7}
            metalness={0.3}
          />
        </mesh>
      </group>
      
      {/* Initial flash */}
      <mesh position={[position.x, position.y, position.z]}>
        <sphereGeometry args={[0.5, 16, 16]} />
        <meshStandardMaterial
          emissive="#ffffff"
          emissiveIntensity={2}
          color="#aaaaaa"
          transparent={true}
          opacity={Math.min(1, lifetimeMs * 5 / 1000)}
        />
        <pointLight color="#ffffff" intensity={Math.min(3, lifetimeMs * 10 / 1000)} distance={5} decay={2} />
      </mesh>
      
      {/* Stone fragments rising from ground */}
      {fragments.current.map((fragment, index) => (
        <mesh
          key={`fragment-${index}`}
          position={fragment.position}
          rotation={[fragment.rotation.x, fragment.rotation.y, fragment.rotation.z]}
          scale={fragment.currentScale}
        >
          <dodecahedronGeometry args={[1, 0]} />
          <meshStandardMaterial
            color={`rgb(${70 + Math.floor(Math.random() * 30)}, ${70 + Math.floor(Math.random() * 30)}, ${70 + Math.floor(Math.random() * 30)})`}
            roughness={0.9}
            metalness={0.1}
          />
        </mesh>
      ))}
      
      {/* Dust particles */}
      {dustParticles.current.map((dust, index) => (
        <mesh
          key={`dust-${index}`}
          position={dust.position}
          rotation={[dust.rotation.x, dust.rotation.y, dust.rotation.z]}
          scale={dust.scale}
        >
          <dodecahedronGeometry args={[1, 0]} />
          <meshStandardMaterial
            color="#808080"
            transparent={true}
            opacity={dust.opacity}
            depthWrite={false}
          />
        </mesh>
      ))}
    </group>
  );
}

// ==============================================================================
// FILE: app/game/skills/WaterSplash.tsx
// ==============================================================================

import * as THREE from 'three';
import { useRef, useState, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { Vector3, Color, MathUtils } from 'three';

interface WaterSplashProps {
  position: Vector3;
  radius?: number; // Area of effect radius
  onComplete: () => void;
}

export function WaterSplash({ position, radius = 5, onComplete }: WaterSplashProps) {
  const [lifetimeMs, setLifetimeMs] = useState(3500);
  const rippleRef = useRef<THREE.Mesh>(null);
  const isCompletingRef = useRef(false);
  
  // Water droplet particles
  const [particles, setParticles] = useState(() => {
    const particleCount = 35;
    return Array.from({ length: particleCount }, () => ({
      position: position.clone().add(
        new Vector3(
          (Math.random() - 0.5) * radius * 0.6, // Spread particles based on radius
          Math.random() * 0.5,
          (Math.random() - 0.5) * radius * 0.6  // Spread particles based on radius
        )
      ),
      initialY: position.y,
      velocity: new Vector3(
        (Math.random() - 0.5) * 10,
        Math.random() * 8 + 6,
        (Math.random() - 0.5) * 10
      ),
      scale: 0.1 + Math.random() * 0.25,
      opacity: 1.0,
      color: new Color().setHSL(0.58 + Math.random() * 0.05, 0.8, 0.5 + Math.random() * 0.2),
      rotationSpeed: new Vector3(
        Math.random() * 5, 
        Math.random() * 5, 
        Math.random() * 5
      ),
      rotation: new Vector3(),
      stretching: 1.0
    }));
  });
  
  // Water vapor/mist particles
  const mistParticles = useRef<Array<{
    position: Vector3;
    scale: number;
    opacity: number;
    velocity: Vector3;
    lifetimeMs: number;
    maxLifetimeMs: number;
  }>>([]);

  // Create initial mist particles
  useEffect(() => {
    // Clear existing mist particles to prevent duplicates
    mistParticles.current = [];
    
    // Create more mist particles for larger radius
    const mistCount = Math.floor(25 * (radius / 3));
    
    for (let i = 0; i < mistCount; i++) {
      const angle = Math.random() * Math.PI * 2;
      const height = Math.random() * 0.5;
      const distance = (0.3 + Math.random() * 0.7) * radius;
      const maxLifetimeMs = 500 + Math.random() * 1500;
      mistParticles.current.push({
        position: position.clone().add(new Vector3(
          Math.cos(angle) * distance * 0.7,
          height,
          Math.sin(angle) * distance * 0.7
        )),
        scale: 0.3 + Math.random() * 0.4,
        opacity: 0.4 + Math.random() * 0.3,
        velocity: new Vector3(
          Math.cos(angle) * (0.5 + Math.random()),
          0.7 + Math.random() * 0.5,
          Math.sin(angle) * (0.5 + Math.random())
        ),
        lifetimeMs: maxLifetimeMs,
        maxLifetimeMs
      });
    }
    
    // Reset the completing state when a new splash is created
    isCompletingRef.current = false;
    
    return () => {
      // Ensure particles are cleared when component unmounts
      mistParticles.current = [];
    };
    
  }, [position, radius]);

  useFrame((state, delta) => {
    // Use a smaller delta cap to prevent large time steps that can cause visual glitches
    const cappedDelta = Math.min(delta, 0.1);
    
    // Create time-based ripple with radius reflecting the area of effect
    const rippleScale = MathUtils.lerp(0.2, radius * 2, 1 - lifetimeMs / 3500);
    const rippleOpacity = MathUtils.lerp(0, 0.6, lifetimeMs / 3500);
    
    if (rippleRef.current) {
      rippleRef.current.scale.set(rippleScale, 1, rippleScale);
      if (rippleRef.current.material) {
        const material = rippleRef.current.material as THREE.Material;
        if (material.transparent !== undefined && material.opacity !== undefined) {
          material.opacity = rippleOpacity;
        }
      }
    }

    // Update water droplet particles
    setParticles(prevParticles => 
      prevParticles.map(particle => {
        // Apply gravity
        particle.velocity.y -= 15 * cappedDelta;
        
        // Update position
        particle.position.add(
          particle.velocity.clone().multiplyScalar(cappedDelta)
        );
        
        // Calculate stretching based on vertical velocity (for water droplet effect)
        particle.stretching = MathUtils.lerp(
          1.0, 
          1.5,
          Math.min(1, Math.abs(particle.velocity.y) / 10)
        );

        // Update rotation
        particle.rotation.x += particle.rotationSpeed.x * cappedDelta;
        particle.rotation.y += particle.rotationSpeed.y * cappedDelta;
        particle.rotation.z += particle.rotationSpeed.z * cappedDelta;

        // Bounce off ground with dampening
        if (particle.position.y < 0.1) {
          particle.position.y = 0.1;
          
          // Create splash mist when hitting ground with force
          if (-particle.velocity.y > 8) {
            for (let i = 0; i < 2; i++) {
              const angle = Math.random() * Math.PI * 2;
              const maxLifetimeMs = 300 + Math.random() * 600;
              
              // Distribute splash particles throughout the area of effect
              const splashDistance = Math.random() * radius * 0.8;
              
              mistParticles.current.push({
                position: particle.position.clone().add(new Vector3(
                  Math.cos(angle) * splashDistance,
                  0.1,
                  Math.sin(angle) * splashDistance
                )),
                scale: 0.2 + Math.random() * 0.2,
                opacity: 0.3 + Math.random() * 0.2,
                velocity: new Vector3(
                  Math.cos(angle) * (0.3 + Math.random() * 0.7),
                  0.3 + Math.random() * 0.4,
                  Math.sin(angle) * (0.3 + Math.random() * 0.7)
                ),
                lifetimeMs: maxLifetimeMs,
                maxLifetimeMs
              });
            }
          }
          
          // Reflect velocity with dampening
          particle.velocity.y = Math.abs(particle.velocity.y) * 0.3;
          
          // Add some horizontal movement on bounce
          particle.velocity.x *= 0.9;
          particle.velocity.z *= 0.9;
          
          // Reduce scale slightly on impact
          particle.scale *= 0.95;
        }

        // Update opacity based on lifetime and altitude
        // Water droplets fade as they reach maximum height or as lifetime ends
        const heightFactor = Math.max(0, 1 - Math.abs(particle.position.y - particle.initialY) / 6);
        particle.opacity = Math.min(lifetimeMs / 1000, heightFactor) * 0.9;

        return particle;
      })
    );
    
    // Update mist particles
    for (let i = mistParticles.current.length - 1; i >= 0; i--) {
      const mist = mistParticles.current[i];
      mist.lifetimeMs -= cappedDelta * 1000;
      mist.position.addScaledVector(mist.velocity, cappedDelta);
      mist.velocity.multiplyScalar(0.97);
      mist.scale = MathUtils.lerp(
        mist.scale,
        mist.scale * 1.1,
        cappedDelta * 2
      );
      const normalizedLife = mist.lifetimeMs / mist.maxLifetimeMs;
      mist.opacity = Math.sin(normalizedLife * Math.PI) * 0.5;
      if (mist.lifetimeMs <= 0) {
        mistParticles.current.splice(i, 1);
      }
    }

    // Update lifetime more slowly
    setLifetimeMs(prev => {
      const newLifetime = Math.max(0, prev - cappedDelta * 800);
      if (newLifetime <= 0 && !isCompletingRef.current) {
        isCompletingRef.current = true;
        setTimeout(() => {
          onComplete();
        }, 50);
      }
      return newLifetime;
    });
  });

  // If no lifetime left, don't render anything
  if (lifetimeMs <= 0) return null;

  return (
    <group>
      {/* Initial splash burst */}
      <mesh position={position}>
        <sphereGeometry args={[radius * 0.3, 16, 16]} />
        <meshStandardMaterial
          key={`splash-${position.x}-${position.z}`}
          color="#80c0ff"
          emissive="#4080ff"
          emissiveIntensity={0.5}
          transparent={true}
          opacity={Math.min(0.7, lifetimeMs * 2 / 1000)}
        />
        <pointLight
          color="#60a0ff"
          intensity={Math.min(2, lifetimeMs * 5 / 1000)}
          distance={radius * 2}
          decay={2}
        />
      </mesh>

      {/* Area of effect indicator on ground */}
      <mesh ref={rippleRef} position={[position.x, 0.05, position.z]} rotation={[-Math.PI / 2, 0, 0]}>
        <ringGeometry args={[0.3, 1, 32]} />
        <meshStandardMaterial
          key={`ripple-${position.x}-${position.z}`}
          color="#80c0ff"
          emissive="#4080ff"
          emissiveIntensity={0.3}
          transparent={true}
          opacity={0.6}
          depthWrite={false}
        />
      </mesh>

      {/* Water column base - scale with radius */}
      <mesh position={[position.x, position.y * 0.5, position.z]} scale={[radius * 0.4, Math.min(1.5, lifetimeMs * 4 / 1000), radius * 0.4]}>
        <cylinderGeometry args={[0.4, 0.7, 0.5, 16]} />
        <meshStandardMaterial
          key={`column-${position.x}-${position.z}`}
          color="#60a0ff"
          emissive="#4080ff"
          emissiveIntensity={0.3}
          transparent={true}
          opacity={Math.min(0.8, lifetimeMs * 2 / 1000)}
        />
      </mesh>

      {/* Water droplets */}
      {particles.map((particle, i) => (
        <mesh 
          key={`droplet-${i}-${position.x}-${position.z}`}
          position={particle.position}
          rotation={[particle.rotation.x, particle.rotation.y, particle.rotation.z]}
          scale={[particle.scale, particle.scale * particle.stretching, particle.scale]}
        >
          <sphereGeometry args={[1, 8, 8]} />
          <meshStandardMaterial
            color={particle.color}
            emissive="#4080ff"
            emissiveIntensity={0.2}
            transparent={true}
            opacity={particle.opacity}
          />
        </mesh>
      ))}

      {/* Mist/vapor particles */}
      {mistParticles.current.map((mist, i) => (
        <mesh
          key={`mist-${i}-${position.x}-${position.z}`}
          position={mist.position}
          scale={mist.scale}
        >
          <sphereGeometry args={[1, 8, 8]} />
          <meshStandardMaterial
            color="#b0e0ff"
            emissive="#80c0ff"
            emissiveIntensity={0.1}
            transparent={true}
            opacity={mist.opacity}
            depthWrite={false}
          />
        </mesh>
      ))}
      
      {/* Area of effect indicator */}
      <mesh position={[position.x, 0.1, position.z]} rotation={[-Math.PI / 2, 0, 0]}>
        <ringGeometry args={[radius * 0.9, radius, 32]} />
        <meshBasicMaterial
          color="#40a0ff"
          transparent={true}
          opacity={lifetimeMs * 0.3 / 1000}
          depthWrite={false}
        />
      </mesh>
    </group>
  );
}

// ==============================================================================
// FILE: app/game/stores/useCombatLogStore.ts
// ==============================================================================

import { create } from 'zustand';
import { persist } from 'zustand/middleware';

export interface LogEntry {
  id: number;        // unique, incremental
  text: string;      // already formatted
  ts: number;        // Date.now()
}

interface State {
  list: LogEntry[];
  push: (e: LogEntry) => void;
  trim: () => void;
}

let nextId = 1;

export const useCombatLogStore = create<State>()(
  persist(
    (set, get) => ({
      list: [],
      push: (e) => set({ list: [...get().list, e] }),
      trim: () => set({ list: get().list.slice(-40) }) // keep last 40
    }),
    { 
      name: 'combat-log',
      // For tests, we'll use a storage that quietly fails instead of throwing errors
      // This helps avoid errors in tests while keeping the code simple
      storage: {
        getItem: () => null,
        setItem: () => {},
        removeItem: () => {}
      }
    }
  )
);


// ==============================================================================
// FILE: app/game/systems/SocketManager.tsx
// ==============================================================================

'use client';

import { useEffect, useCallback, useRef } from 'react';
import { io } from 'socket.io-client';
import { useGameStore } from './gameStore';
import { GROUND_Y } from './moveSimulation';
import { SnapBuffer } from './interpolation';
import { hookVfx } from './vfxDispatcher';
import { initProjectileListeners, useProjectileStore } from './projectileManager';
import { 
  MoveStart, 
  MoveSync, 
  CastReq, 
  PosSnap, 
  VecXZ,
  ProjSpawn2,
  ProjHit2,
  CastSnapshotMsg,
  EffectSnapshotMsg
} from '../../../shared/messages';
import { SkillId } from '../../../shared/skillsDefinition';
import { CastState } from '../../../shared/types';
import { useCombatLogStore } from '../stores/useCombatLogStore';

// Variable for generating unique log entry IDs
let nextId = 1;

export default function SocketManager() {
  // Use individual selectors to prevent unnecessary re-renders
  const setSocket = useGameStore(state => state.setSocket);
  const setMyPlayerId = useGameStore(state => state.setMyPlayerId);
  const setGameState = useGameStore(state => state.setGameState);
  const addPlayer = useGameStore(state => state.addPlayer);
  const removePlayer = useGameStore(state => state.removePlayer);
  const updatePlayer = useGameStore(state => state.updatePlayer);
  const updateEnemy = useGameStore(state => state.updateEnemy);
  
  // Add snapBuffers for each remote player
  const snapBuffers = useRef<Record<string, SnapBuffer>>({});
  
  // Get connection status update functions
  const setConnectionStatus = useCallback((isConnected: boolean) => {
    useGameStore.setState({ 
      isConnected, 
      lastConnectionChangeTs: Date.now() 
    });
  }, []);

  // Memoize event handlers to prevent recreating them on every render
  const handlePlayerLeft = useCallback((playerId: string) => {
    removePlayer(playerId);
  }, [removePlayer]);

  const handlePlayerUpdated = useCallback((playerData: any) => {
    updatePlayer(playerData);
  }, [updatePlayer]);

  // Add a more efficient player move handler that directly updates player positions
  // without triggering full state updates
  const handlePlayerMoved = useCallback((moveData: { 
    id: string; 
    x: number; 
    y: number; 
    z: number; 
    ry: number;
  }) => {
    // Get current state and players
    const state = useGameStore.getState();
    const players = state.players;
    const player = players[moveData.id];
    
    if (player) {
      // Directly update the position and rotation without triggering a full state update
      player.position.x = moveData.x;
      player.position.y = moveData.y;
      player.position.z = moveData.z;
      player.rotation.y = moveData.ry;
    }
  }, []);

  // Handle movement start events from server
  const handlePlayerMoveStart = useCallback((data: MoveStart) => {
    if (!data.path || data.path.length === 0) return;
    
    updatePlayer({ 
      id: data.id, 
      movement: { 
        isMoving: true,
        targetPos: data.path[0],
        path: data.path,
        pos: data.path[0], // Default to first point in path
        lastUpdateTime: performance.now(),
        speed: data.speed
      } 
    });
  }, [updatePlayer]);

  // Handle position snapshot from server
  const handlePosSnap = useCallback((data: { snaps: PosSnap[] }) => {
    if (!data.snaps || !Array.isArray(data.snaps)) {
      console.warn("Invalid snaps data received:", data);
      return;
    }
    
    data.snaps.forEach(s => {
      try {
        if (!s || !s.id || !s.pos || !s.vel || typeof s.ts !== 'number') {
          console.warn("Invalid snap entry:", s);
          return;
        }
        
        const state = useGameStore.getState();
        const player = state.players[s.id];
        
        if (player) {
          // Store in snap buffer
          if (!snapBuffers.current[s.id]) snapBuffers.current[s.id] = new SnapBuffer();
          snapBuffers.current[s.id].push({
            pos: s.pos,
            vel: s.vel,
            rot: player.rotation?.y || 0,
            snapTs: s.ts
          });
        }
      } catch (err) {
        console.error("Error processing position snapshot:", err);
      }
    });
  }, []);

  // Handle skill cast failure
  const handleCastFail = useCallback((data: { clientSeq: number, reason: 'cooldown' | 'nomana' | 'invalid' }) => {
    const state = useGameStore.getState();
    const myPlayerId = state.myPlayerId;
    const players = state.players;
    const player = myPlayerId ? players[myPlayerId] : null;
    
    if (player) {
      // Get the skill that failed (if we can identify it from clientSeq)
      // For now we just reset the skill state in case it was locally set
      
      // Revert any local mana or cooldown changes
      if (data.reason === 'nomana') {
        // Flash mana bar red briefly
        useGameStore.setState({ manaBarFlash: true });
        setTimeout(() => useGameStore.setState({ manaBarFlash: false }), 300);
      }
      
      // Flash the skill icon red
      const skillId = state.lastCastSkillId || null;
      if (skillId) {
        useGameStore.setState({ flashingSkill: skillId });
        setTimeout(() => useGameStore.setState({ flashingSkill: null }), 300);
      }
      
      // Log the failure reason
      const reasons = {
        cooldown: 'Skill is on cooldown',
        nomana: 'Not enough mana',
        invalid: 'Invalid target or range'
      };
      console.log(`Cast failed: ${reasons[data.reason]}`);
    }
  }, []);

  const handleEnemyUpdated = useCallback((enemyData: any) => {
    updateEnemy(enemyData);
  }, [updateEnemy]);
  
  // Handle cast snapshot updates
  const handleCastSnapshot = useCallback((data: CastSnapshotMsg) => {
    const castData = data.data;
    
    // Update player casting state based on cast state
    if (castData.state === CastState.Casting) {
      // Skill is being cast (equivalent to old CastStart)
      updatePlayer({
        id: castData.casterId,
        castingSkill: castData.skillId as string,
        castingProgressMs: 1000 // Default cast time, should come from skill definition
      });
    } else if (castData.state === CastState.Impact) {
      // Skill cast has completed (equivalent to old CastEnd)
      updatePlayer({
        id: castData.casterId,
        castingSkill: null,
        castingProgressMs: 0
      });
    }
    
    // Pass the cast snapshot to any system that needs it
    window.dispatchEvent(new CustomEvent('castsnapshot', { detail: castData }));
  }, [updatePlayer]);

  // Memoize the socket connection handler
  const handleConnect = useCallback(() => {
    // Connect to WebSocket server with improved configuration
    const socket = io('http://localhost:3001', {
      path: '/socket.io',
      transports: ['websocket'],
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      reconnectionAttempts: 5
    });

    socket.on('connect', () => {
      console.log('Connected to game server, setting socket in game store');
      setConnectionStatus(true);
      setSocket(socket);  // Make sure we set the socket in the game store
      
      // Hook up VFX event system
      hookVfx(socket);
      
      // Initialize projectile manager listeners
      initProjectileListeners();

      // Removed automatic joinGame emission to prevent duplicate player IDs

      // Set up skill-related event handlers - will be deprecated after migration
      socket.on('skillEffect', (data: { skillId: string, sourceId: string, targetId: string }) => {
        // Update game state based on skill effects
        console.log('Legacy skillEffect received from server:', data);
        
        // This handler will be removed after the new projectile system is confirmed working
        const gameState = useGameStore.getState();
        const sourcePlayer = gameState.players[data.sourceId];
        const targetEnemy = gameState.enemies[data.targetId];
        
        if (sourcePlayer && targetEnemy) {
          // Dispatch a custom event that ActiveSkills can listen for
          window.dispatchEvent(new CustomEvent('skillTriggered', { 
            detail: {
              id: `effect-${Math.random().toString(36).substring(2, 9)}`,
              skillId: data.skillId as string,
              sourceId: data.sourceId,
              targetId: data.targetId,
              startPosition: sourcePlayer.position,
              targetPosition: targetEnemy.position,
              createdAtTs: Date.now()
            }
          }));
        } else {
          console.warn('Could not find source player or target enemy for skill effect:', {
            skillId: data.skillId,
            sourceId: data.sourceId,
            targetId: data.targetId,
            sourceMissing: !sourcePlayer,
            targetMissing: !targetEnemy,
            playerCount: Object.keys(gameState.players).length,
            enemyCount: Object.keys(gameState.enemies).length
          });
        }
      });

      socket.on('skillCooldownUpdate', (data: { skillId: string, cooldownEndTime: number }) => {
        // Update skill cooldowns in game state
        console.log('Cooldown update received:', data);
      });

      // Handle existing events...
      socket.on('gameState', (gameState: any) => {
        const myPlayerId = useGameStore.getState().myPlayerId;
        console.log('Received game state:', {
          enemyCount: Object.keys(gameState.enemies || {}).length,
          playerCount: Object.keys(gameState.players || {}).length,
          playerSkills: myPlayerId ? gameState.players[myPlayerId]?.skills : []
        });
        setGameState(gameState);
      });

      socket.on('joinGame', (data: { playerId: string }) => {
        console.log('Joined game with player ID:', data.playerId);
        setMyPlayerId(data.playerId);
        // Request full game state after setting ID
        socket.emit('requestGameState');
      });

      // Handle new players joining
      socket.on('playerJoined', (player: any) => {
        console.log('New player joined:', player);
        addPlayer(player);
      });
      
      // Handle when other players update their state
      socket.on('playerUpdated', (playerData: any) => {
        console.log('Player updated:', playerData);
        updatePlayer(playerData);
      });

      socket.on('newPlayer', (player: any) => {
        addPlayer(player);
      });

      socket.on('msg', (msg: any) => {
        switch (msg.type) {
          case 'MoveStart':
            handlePlayerMoveStart(msg);
            break;
          case 'PosSnap':
            handlePosSnap(msg);
            break;
          case 'CastFail':
            handleCastFail(msg);
            break;
          case 'SkillShortcutUpdated':
            // Update local shortcuts to match server state
            console.log('Skill shortcut updated:', msg);
            try {
              if (typeof msg.slotIndex !== 'number' || msg.slotIndex < 0 || msg.slotIndex > 8) {
                console.error('Invalid slot index in SkillShortcutUpdated message:', msg.slotIndex);
                break;
              }
              
              const player = useGameStore.getState().getMyPlayer();
              if (!player) {
                console.error('Cannot update skill shortcuts: No player data available');
                break;
              }
              
              if (!player.skillShortcuts) {
                console.error('Cannot update skill shortcuts: Player has no skillShortcuts array');
                break;
              }
              
              // Create a new array from existing shortcuts to avoid reference issues
              const updatedShortcuts = [...player.skillShortcuts];
              updatedShortcuts[msg.slotIndex] = msg.skillId;
              
              // Update player in store
              useGameStore.getState().updatePlayer({
                id: player.id,
                skillShortcuts: updatedShortcuts
              });
              
              console.log(`Successfully updated skill shortcut at slot ${msg.slotIndex+1} to ${msg.skillId}`);
            } catch (error) {
              console.error('Error processing SkillShortcutUpdated message:', error);
            }
            break;
          case 'SkillLearned':
            // Handle skill learned confirmation from server
            console.log('Skill learned:', msg);
            if (useGameStore.getState().myPlayerId) {
              const player = useGameStore.getState().getMyPlayer();
              if (player) {
                // Create a new array of unlocked skills with the new skill
                const updatedUnlockedSkills = [...player.unlockedSkills, msg.skillId];
                // Update the player with the new skill and remaining points
                useGameStore.getState().updatePlayer({
                  id: player.id,
                  unlockedSkills: updatedUnlockedSkills,
                  availableSkillPoints: msg.remainingPoints
                });
              }
            }
            break;
          case 'ProjSpawn2':
            // Call store method first and then dispatch event for legacy VFX
            useProjectileStore.getState().addEnhancedProjectile(msg as ProjSpawn2);
            window.dispatchEvent(new CustomEvent('projspawn2', {detail: msg}));
            break;
          case 'ProjHit2':
            // Call store method first and then dispatch event for VFX
            useProjectileStore.getState().handleEnhancedHit(msg as ProjHit2);
            window.dispatchEvent(new CustomEvent('projhit2', {detail: msg}));
            
            // Add combat log entry for hit
            const hitMsg = msg as ProjHit2;
            const player = useGameStore.getState().getMyPlayer();
            const playerId = player?.id || '';
            
            // Check if there's damage information
            if (hitMsg.dmg && hitMsg.dmg.length > 0 && hitMsg.hitIds && hitMsg.hitIds.length > 0) {
              // For each hit target
              hitMsg.hitIds.forEach((id, index) => {
                const damage = hitMsg.dmg[index];
                const total = damage;
                const crit = damage > 200; // crude crit flag
                
                useCombatLogStore.getState().push({
                  id: nextId++,
                  text: `${hitMsg.src === playerId ? 'You' : 'Enemy'} hit ${
                    id === playerId ? 'YOU' : 'enemy'
                  } for ${total}${crit ? ' (CRIT!)' : ''}`,
                  ts: Date.now()
                });
                
                // Trim the log after adding entries
                useCombatLogStore.getState().trim();
              });
            }
            break;
          case 'CastSnapshot':
            handleCastSnapshot(msg as CastSnapshotMsg);
            break;
          case 'EffectSnapshot':
            handleEffectSnapshot(msg as EffectSnapshotMsg);
            break;
          default:
            console.log('Unknown message type:', msg.type);
        }
      });

      // Keep old handlers for compatibility during transition
      socket.on('playerLeft', handlePlayerLeft);
      socket.on('playerUpdated', handlePlayerUpdated);
      socket.on('enemyUpdated', handleEnemyUpdated);
      socket.on('playerMoved', handlePlayerMoved);
    });

    return socket;
  }, [
    setSocket, 
    setMyPlayerId, 
    setGameState, 
    addPlayer, 
    handlePlayerLeft, 
    handlePlayerUpdated, 
    handlePlayerMoved, 
    handleEnemyUpdated, 
    handlePlayerMoveStart,
    handlePosSnap,
    handleCastFail,
    handleCastSnapshot,
    setConnectionStatus
  ]);

  useEffect(() => {
    const socket = handleConnect();
    
    // Cleanup on unmount
    return () => {
      if (socket) {
        socket.disconnect();
      }
    };
  }, [handleConnect]);

  // Add debugging to socket updates
  useEffect(() => {
    // Get the current socket from the game store
    const socket = useGameStore.getState().socket;
    if (!socket) return;
    
    const debugSocketEvents = (eventName: string) => {
      const originalOn = socket.on.bind(socket);
      socket.on = function(event: string, callback: (...args: any[]) => any) {
        if (event === eventName) {
          const wrappedCallback = function(this: any, ...args: any[]) {
            console.log(`[Socket] ${event} received:`, ...args);
            return callback.apply(this, args);
          };
          return originalOn(event, wrappedCallback);
        }
        return originalOn(event, callback);
      };
    };
    
    // Debug specific events
    debugSocketEvents('playerJoined');
    debugSocketEvents('playerUpdated');
    debugSocketEvents('gameState');
    debugSocketEvents('msg');
    
    // Log outgoing messages
    const originalEmit = socket.emit.bind(socket);
    socket.emit = function(event: string, ...args: any[]) {
      if (event === 'msg' || event === 'joinGame' || event === 'requestGameState') {
        console.log(`[Socket] Emitting ${event}:`, args);
      }
      return originalEmit(event, ...args);
    };
    
  }, []);

  // Function to send MoveStart message
  const sendMoveStart = useCallback((path: VecXZ[], speed: number) => {
    const socket = useGameStore.getState().socket;
    const myPlayerId = useGameStore.getState().myPlayerId;
    
    if (!socket || !myPlayerId) return;
    
    const moveStart: MoveStart = {
      type: 'MoveStart',
      id: myPlayerId,
      path,
      speed,
      clientTs: Date.now()
    };
    
    socket.emit('msg', moveStart);
    
    // Also update local player immediately for prediction
    updatePlayer({ 
      id: myPlayerId, 
      movement: { 
        isMoving: true,
        targetPos: path[0],
        path: path,
        pos: path[0], // Default to first point in path
        lastUpdateTime: performance.now(),
        speed
      } 
    });
  }, [updatePlayer]);
  
  // Function to send MoveSync message
  const sendMoveSync = useCallback(() => {
    const socket = useGameStore.getState().socket;
    const myPlayerId = useGameStore.getState().myPlayerId;
    const players = useGameStore.getState().players;
    
    if (!socket || !myPlayerId || !players[myPlayerId]) return;
    
    const player = players[myPlayerId];
    
    const moveSync: MoveSync = {
      type: 'MoveSync',
      id: myPlayerId,
      pos: { x: player.position.x, z: player.position.z },
      clientTs: Date.now()
    };
    
    socket.emit('msg', moveSync);
  }, []);
  
  // Function to send CastReq message
  const sendCastReq = useCallback((skillId: string, targetId?: string, targetPos?: VecXZ) => {
    const socket = useGameStore.getState().socket;
    const myPlayerId = useGameStore.getState().myPlayerId;
    
    if (!socket || !myPlayerId) return;
    
    const castReq: CastReq = {
      type: 'CastReq',
      id: myPlayerId,
      skillId: skillId as SkillId,
      targetId,
      targetPos,
      clientTs: Date.now()
    };
    
    socket.emit('msg', castReq);
  }, []);
  
  // Add these functions to the game store for components to use
  useEffect(() => {
    useGameStore.setState({
      sendMoveStart,
      sendMoveSync,
      sendCastReq
    });
  }, [sendMoveStart, sendMoveSync, sendCastReq]);
  
  // Set up periodic MoveSync messages
  useEffect(() => {
    const syncInterval = setInterval(sendMoveSync, 2000);
    return () => clearInterval(syncInterval);
  }, [sendMoveSync]);

  // Handle effect snapshots from server
  const handleEffectSnapshot = useCallback((msg: EffectSnapshotMsg) => {
    const targetId = msg.id;
    const sourceId = msg.src;
    const effectId = msg.effectId;
    const stacks = msg.stacks;
    const remainingMs = msg.remainingMs;
    
    console.log(`Effect snapshot: ${effectId} on ${targetId} from ${sourceId}, stacks: ${stacks}, remaining: ${remainingMs}ms`);
    
    // Add to combat log when effect is first applied
    if (remainingMs > 0 && stacks === 1) {
      const player = useGameStore.getState().getMyPlayer();
      const playerId = player?.id || '';
      
      useCombatLogStore.getState().push({
        id: nextId++,
        text: `>>> ${effectId.toUpperCase()} applied`,
        ts: Date.now()
      });
      
      // Trim the log after adding entries
      useCombatLogStore.getState().trim();
    }
    
    // Check if this is a player effect
    const players = useGameStore.getState().players;
    if (players[targetId]) {
      // Update player with new status effect info
      updatePlayer({
        id: targetId,
        statusEffects: [
          ...players[targetId].statusEffects.filter(e => e.type !== effectId), // Remove old effect of same type
          {
            id: `${effectId}-${sourceId}-${Date.now()}`,
            type: effectId,
            value: 0, // The actual value will be determined by the effect definition
            durationMs: remainingMs,
            startTimeTs: Date.now() - (remainingMs * (1 - stacks / 5)), // Approximate start time based on remaining duration
            sourceSkill: effectId,
            stacks
          }
        ]
      });
    }
    
    // Check if this is an enemy effect
    const enemies = useGameStore.getState().enemies;
    if (enemies[targetId]) {
      // Update enemy with new status effect info
      updateEnemy({
        id: targetId,
        statusEffects: [
          ...enemies[targetId].statusEffects.filter(e => e.type !== effectId), // Remove old effect of same type
          {
            id: `${effectId}-${sourceId}-${Date.now()}`,
            type: effectId,
            value: 0, // The actual value will be determined by the effect definition
            durationMs: remainingMs,
            startTimeTs: Date.now() - (remainingMs * (1 - stacks / 5)), // Approximate start time based on remaining duration
            sourceSkill: effectId,
            stacks
          }
        ]
      });
      
      // Trigger visual effect on the target
      if (stacks === 1) {
        // Only spawn the VFX on first application
        console.log(`VFX for effect ${effectId} on enemy ${targetId}`);
        const enemy = enemies[targetId];
        const position = enemy ? { x: enemy.position.x, y: enemy.position.y, z: enemy.position.z } : undefined;
        
        if (position) {
          // For burn effects
          if (effectId === 'burn') {
            window.dispatchEvent(new CustomEvent('spawnSplash', {
              detail: { position, radius: 1.2, effectType: 'fire' }
            }));
          }
          // For bleed effects
          else if (effectId === 'bleed') {
            window.dispatchEvent(new CustomEvent('spawnSplash', {
              detail: { position, radius: 0.8, effectType: 'blood' }
            }));
          }
        }
      }
    }
  }, [updatePlayer, updateEnemy]);

  return null;
}


// ==============================================================================
// FILE: app/game/systems/castController.ts
// ==============================================================================

'use client';

import { useGameStore } from './gameStore';
import { SkillId } from '../../../shared/skillsDefinition';
import { VecXZ } from '../../../shared/messages';

/**
 * Tries to start casting a skill. This is a unified entry point for skill casting
 * that replaces the legacy path via CastStart messages.
 * 
 * @param skillId The ID of the skill to cast
 * @param targetId Optional ID of the target entity
 * @param targetPos Optional position to target the skill at
 */
export function tryStartCast(skillId: SkillId, targetId?: string, targetPos?: VecXZ) {
  // Get the selected target from the game store if not explicitly provided
  const selectedTargetId = targetId || useGameStore.getState().selectedTargetId;
  
  console.log(`Attempting to cast skill: ${skillId}`, {
    targetId: selectedTargetId,
    targetPos
  });
  
  // Use the existing sendCastReq implementation
  useGameStore.getState().sendCastReq(skillId, selectedTargetId || undefined, targetPos);
  
  // Set this as the selected skill for UI state
  useGameStore.getState().setSelectedSkill(skillId);
}


// ==============================================================================
// FILE: app/game/systems/dragState.ts
// ==============================================================================

'use client';

/**
 * Simple drag state manager to reliably track currently dragged skill
 * This helps work around cross-browser drag and drop limitations
 */

let currentlyDraggedSkillId: string | null = null;

function setDraggedSkill(skillId: string | null) {
  console.log('Setting dragged skill to:', skillId);
  currentlyDraggedSkillId = skillId;
}

function getDraggedSkill() {
  console.log('Getting dragged skill:', currentlyDraggedSkillId);
  return currentlyDraggedSkillId;
}

function clearDraggedSkill() {
  console.log('Clearing dragged skill');
  currentlyDraggedSkillId = null;
}

const dragState = {
  setDraggedSkill,
  getDraggedSkill,
  clearDraggedSkill
};

export default dragState;


// ==============================================================================
// FILE: app/game/systems/gameStore.ts
// ==============================================================================

'use client';

import { create } from 'zustand';
import { Character } from '../models/Character';
import { Enemy } from '../models/Enemy';
import { Skill, SkillId } from '../models/Skill';
import { PlayerState as ServerPlayerState, VecXZ, PlayerMovementState } from '../../../shared/types';

// StatusEffect interface for tracking active effects
export interface StatusEffect {
  id: string;
  type: string;
  value: number;
  durationMs: number;
  startTimeTs: number;
  sourceSkill: string;
  stacks?: number;  // Optional stacks field for stackable effects
}

// Define the structure for player state received from the server
interface PlayerState extends Character {
  socketId?: string;
  experience: number;
  experienceToNextLevel: number;
  statusEffects: StatusEffect[];
  skillCooldownEndTs: Record<string, number>;
  castingSkill: string | null;
  castingProgressMs: number;
  isAlive: boolean;
  movement?: PlayerMovementState;
}

// Define the structure for the overall game state received from the server
interface ServerGameState {
  players: Record<string, PlayerState>;
  enemies: Record<string, Enemy>;
}

interface GameState {
  // --- State ---
  myPlayerId: string | null;
  players: Record<string, PlayerState>;
  enemies: Record<string, Enemy>;
  selectedTargetId: string | null;
  lastCastSkillId: string | null;
  flashingSkill: string | null;  // Skill ID that should flash red (for failures)
  manaBarFlash: boolean;         // Whether mana bar should flash red
  currentZoneId: string | null;
  donationXpBoost: number;
  donationBoostEndTimeTs: number | null;
  bonusXpEventActive: boolean;
  player: PlayerState | null;
  experience: number;
  experienceToNextLevel: number;
  skillCooldownEndTs: Record<string, number>;
  castingSkill: string | null;
  castingProgressMs: number;
  isConnected: boolean;
  lastConnectionChangeTs: number;
  socket: any | null;
  hasJoinedGame: boolean;
  selectedSkill: string | null;
  targetWorldPos: { x: number, y: number, z: number } | null;
  lastMoveSentTimeMs: number | null; // Track the last time we sent a movement update

  // --- Methods ---
  setSocket: (socketInstance: any) => void;
  setGameState: (newState: ServerGameState) => void;
  setMyPlayerId: (id: string) => void;
  addPlayer: (player: PlayerState) => void;
  removePlayer: (playerId: string) => void;
  updatePlayer: (playerData: Partial<PlayerState> & { id: string }) => void;
  updateEnemy: (enemyData: Partial<Enemy> & { id: string }) => void;
  // Intent-based movement - new message format
  sendMoveStart: (path: VecXZ[], speed: number) => void;
  sendMoveSync: () => void;
  sendCastReq: (skillId: string, targetId?: string, targetPos?: VecXZ) => void;
  // Legacy methods for backward compatibility
  sendPlayerMove: (position: { x: number; y: number; z: number }, rotationY: number) => void;
  sendMoveSyncImmediate: (pos: VecXZ) => void;
  // Other methods
  sendSelectTarget: (targetId: string | null) => void;
  selectTarget: (targetId: string | null) => void;
  setSelectedSkill: (skillId: string | null) => void;
  setTargetWorldPos: (pos: { x: number, y: number, z: number } | null) => void;
  getMyPlayer: () => PlayerState | null;
  getSelectedTarget: () => Enemy | null;
  getStatusEffects: (targetId: string | 'player') => StatusEffect[];
  getXpMultiplierInfo: () => { base: number; donation: number; event: number; total: number };
  applyDonationBoost: (amount: number, durationMinutes: number) => void;
  clearDonationBoost: () => void;
  toggleXpEvent: () => void;
  updatePlayerZone: () => void;
  applySkillEffect: (targetId: string, effects: any[]) => void;
  setHasJoinedGame: (joined: boolean) => void;
  handleSkillHotkey: (key: string) => void;
  setActiveSkill: (skillId: string | null) => void;
}

// --- Memoized selectors ---
// We ensure selectors are stable by declaring them outside the store
const selectPlayers = (state: GameState) => state.players;
const selectPlayerIds = (state: GameState) => {
  const players = selectPlayers(state);
  
  // Only recompute if players object has changed
  if (players !== previousPlayers) {
    playerIdsCache = Object.keys(players);
    previousPlayers = players;
  }
  
  return playerIdsCache;
};

// Ensure stable reference by caching the array instance
let playerIdsCache: string[] = [];
let previousPlayers: Record<string, PlayerState> | null = null;

// Create a stable memoized selector for status effects
const selectStatusEffects = (targetId: string | 'player') => {
  const selector = (state: GameState) => {
    if (targetId === 'player') {
      const player = state.myPlayerId ? state.players[state.myPlayerId] : null;
      return player?.statusEffects || [];
    }
    const enemy = state.enemies[targetId];
    return enemy?.statusEffects || [];
  };
  // Add metadata for stable referencing
  selector.store = { targetId };
  return selector;
};

const selectMyPlayerId = (state: GameState) => state.myPlayerId;
const selectEnemies = (state: GameState) => state.enemies;
const selectEnemyCount = (state: GameState) => Object.keys(state.enemies).length;
const selectSelectedTargetId = (state: GameState) => state.selectedTargetId;

// Memoized player selector using a stable function
const selectPlayer = (id: string) => {
  const selector = (state: GameState) => selectPlayers(state)[id];
  // Using Object.is for referential equality check
  selector.store = { id };
  return selector;
};

const selectSendPlayerMove = (state: GameState) => state.sendPlayerMove;
const selectGetPlayer = (state: GameState) => state.getMyPlayer;

export {
  selectPlayers,
  selectPlayerIds,
  selectMyPlayerId,
  selectEnemies,
  selectEnemyCount,
  selectSelectedTargetId,
  selectPlayer,
  selectSendPlayerMove,
  selectGetPlayer,
  selectStatusEffects,
};

export const useGameStore = create<GameState>((set, get) => ({
  // --- Initial State ---
  myPlayerId: null,
  players: {},
  enemies: {},
  selectedTargetId: null,
  lastCastSkillId: null,
  flashingSkill: null,
  manaBarFlash: false,
  currentZoneId: null,
  donationXpBoost: 0,
  donationBoostEndTimeTs: null,
  bonusXpEventActive: false,
  player: null,
  experience: 0,
  experienceToNextLevel: 100,
  skillCooldownEndTs: {},
  castingSkill: null,
  castingProgressMs: 0,
  isConnected: false,
  lastConnectionChangeTs: Date.now(),
  socket: null,
  hasJoinedGame: false,
  selectedSkill: null,
  targetWorldPos: null,
  lastMoveSentTimeMs: null,

  // --- Methods ---
  setSocket: (socketInstance: any) => {
    set({ socket: socketInstance });
  },
  
  // New method to handle keyboard shortcuts for skills
  handleSkillHotkey: (key: string) => {
    const player = get().getMyPlayer();
    const selectedTarget = get().selectedTargetId;
    
    if (!player || !player.skillShortcuts) return;
    
    // Convert key to index (keys 1-9 map to array indices 0-8)
    const keyNum = parseInt(key);
    if (isNaN(keyNum) || keyNum < 1 || keyNum > 9) return;
    
    const shortcutIndex = keyNum - 1;
    const skillId = player.skillShortcuts[shortcutIndex];
    
    if (skillId) {
      console.log(`Using skill hotkey ${keyNum} to cast ${skillId}`);
      get().setSelectedSkill(skillId);
      
      // If there's a selected target, cast immediately
      if (selectedTarget) {
        get().sendCastReq(skillId, selectedTarget);
      }
    }
  },

  setGameState: (newState: ServerGameState) => {
    set({ 
      players: newState.players,
      enemies: newState.enemies,
      selectedTargetId: newState.enemies[get().selectedTargetId ?? ''] ? get().selectedTargetId : null,
    });
  },

  setMyPlayerId: (id: string) => {
    set({ myPlayerId: id });
  },

  addPlayer: (player: PlayerState) => {
    set(state => ({
      players: { ...state.players, [player.id]: player }
    }));
  },

  removePlayer: (playerId: string) => {
    set(state => {
      const newPlayers = { ...state.players };
      delete newPlayers[playerId];
      return { players: newPlayers };
    });
  },

  updatePlayer: (playerData: Partial<PlayerState> & { id: string }) => {
    set(state => {
      const currentPlayer = state.players[playerData.id];
      if (!currentPlayer) return state;
      
      // Check if this is the locally controlled player
      const isSelf = playerData.id === state.myPlayerId;
      
      if (isSelf && playerData.position) {
        // For self-controlled player, only accept server position corrections 
        // when the error is significant (> 0.5 units)
        const dx = currentPlayer.position.x - playerData.position.x;
        const dz = currentPlayer.position.z - playerData.position.z;
        const error = Math.sqrt(dx * dx + dz * dz);
        
        // Ignore minor position updates from server for self-controlled player
        if (error < 0.5) {
          // Still update other properties, just not position
          const { position, ...otherProps } = playerData;
          
          // If we only had position update, return unchanged state
          if (Object.keys(otherProps).length === 1) { // Only 'id' remains
            return state;
          }
          
          // Update other properties
          return {
            players: {
              ...state.players,
              [playerData.id]: { ...currentPlayer, ...otherProps }
            }
          };
        }
      }
      
      // For other players or significant corrections, process normally
      // Check if any values are actually different before updating
      const hasChanges = Object.keys(playerData).some(key => 
        playerData[key as keyof typeof playerData] !== currentPlayer[key as keyof typeof currentPlayer]
      );
      
      if (!hasChanges) return state;
      
      return {
        players: {
          ...state.players,
          [playerData.id]: { ...currentPlayer, ...playerData }
        }
      };
    });
  },

  updateEnemy: (enemyData: Partial<Enemy> & { id: string }) => {
    set(state => {
      if (!state.enemies[enemyData.id]) return state;
      return {
        enemies: {
          ...state.enemies,
          [enemyData.id]: { ...state.enemies[enemyData.id], ...enemyData }
        }
      };
    });
  },

  // Legacy movement method - keep for compatibility but mark as deprecated
  sendPlayerMove: (position: { x: number; y: number; z: number }, rotationY: number) => {
    console.warn('sendPlayerMove is deprecated. Use intent-based movement instead.');
    const socket = get().socket;
    if (!socket) {
      console.warn('Cannot send player move: Socket not connected');
      return;
    }
    
    // Throttle outbound messages to reduce network traffic
    const now = performance.now();
    const lastSent = get().lastMoveSentTimeMs || 0;
    
    // Limit to 13Hz (roughly 75ms between updates)
    if (now - lastSent < 75) {
      return;
    }
    
    // Update the last sent timestamp
    set({ lastMoveSentTimeMs: now });
    
    socket.emit('playerMove', { position, rotationY });
  },

  // New intent-based movement methods with the new protocol
  sendMoveStart: (path: VecXZ[], speed: number) => {
    const socket = get().socket;
    const myPlayerId = get().myPlayerId;
    
    if (!socket || !myPlayerId) {
      console.warn('Cannot send move start: Socket not connected or player ID unknown');
      return;
    }
    
    socket.emit('msg', {
      type: 'MoveStart',
      id: myPlayerId,
      path,
      speed,
      clientTs: Date.now()
    });
    
    // Also update local player immediately for smoother prediction
    const player = get().players[myPlayerId];
    if (player && path.length > 0) {
      const dest = path[0];
      set(state => ({
        players: {
          ...state.players,
          [myPlayerId]: {
            ...player,
            movement: {
              isMoving: true,
              path: path,
              pos: { x: player.position.x, z: player.position.z },
              targetPos: dest,
              speed,
              lastUpdateTime: performance.now()
            }
          }
        }
      }));
    }
  },
  
  sendMoveSync: () => {
    const socket = get().socket;
    const myPlayerId = get().myPlayerId;
    
    if (!socket || !myPlayerId) {
      return;
    }
    
    const player = get().players[myPlayerId];
    if (!player) return;
    
    socket.emit('msg', {
      type: 'MoveSync',
      id: myPlayerId,
      pos: { x: player.position.x, z: player.position.z },
      clientTs: Date.now()
    });
  },
  
  sendCastReq: (skillId: string, targetId?: string, targetPos?: VecXZ) => {
    const socket = get().socket;
    const myPlayerId = get().myPlayerId;
    
    if (!socket || !myPlayerId) {
      console.warn('Cannot send cast request: Socket not connected or player ID unknown');
      return;
    }
    
    // Store the skill ID for reconciliation with CastFail responses
    set({ lastCastSkillId: skillId });
    
    socket.emit('msg', {
      type: 'CastReq',
      id: myPlayerId,
      skillId,
      targetId,
      targetPos,
      clientTs: Date.now()
    });
  },

  sendSelectTarget: (targetId: string | null) => {
    const socket = get().socket;
    if (!socket) {
      console.warn('Cannot select target: Socket not connected');
      return;
    }
    socket.emit('selectTargetRequest', targetId);
    get().selectTarget(targetId);
  },

  // --- Actions ---
  castSkill: (skillId: string) => {
    const state = get();
    if (!state.myPlayerId || !state.selectedTargetId) return;
    
    // Use the new CastReq protocol
    get().sendCastReq(skillId, state.selectedTargetId);
  },

  setActiveSkill: (skillId: string | null) => {
    set({ selectedSkill: skillId });
  },

  selectTarget: (targetId: string | null) => {
    if (targetId === null || get().enemies[targetId]) {
      set({ selectedTargetId: targetId });
    } else {
      set({ selectedTargetId: null });
    }
  },

  setSelectedSkill: (skillId: string | null) => {
    set({ selectedSkill: skillId });
  },

  setTargetWorldPos: (pos: { x: number, y: number, z: number } | null) => {
    set({ targetWorldPos: pos });
  },

  getMyPlayer: () => {
    const state = get();
    return state.myPlayerId ? state.players[state.myPlayerId] : null;
  },

  getSelectedTarget: () => {
    const state = get();
    return state.selectedTargetId ? state.enemies[state.selectedTargetId] : null;
  },

  getStatusEffects: (targetId: string | 'player') => {
    const state = get();
    if (targetId === 'player') {
      const player = state.myPlayerId ? state.players[state.myPlayerId] : null;
      return player?.statusEffects || [];
    }
    const enemy = state.enemies[targetId];
    return enemy?.statusEffects || [];
  },

  getXpMultiplierInfo: () => {
    const state = get();
    const base = 1.0;
    const donation = state.donationXpBoost > 0 && state.donationBoostEndTimeTs !== null && state.donationBoostEndTimeTs > Date.now() ? state.donationXpBoost : 0;
    const event = state.bonusXpEventActive ? 0.5 : 0;
    return { base, donation, event, total: base + donation + event };
  },

  applyDonationBoost: (amount: number, durationMinutes: number) => {
    set({
      donationXpBoost: amount,
      donationBoostEndTimeTs: Date.now() + (durationMinutes * 60 * 1000)
    });
  },

  clearDonationBoost: () => {
    set({
      donationXpBoost: 0,
      donationBoostEndTimeTs: null
    });
  },

  toggleXpEvent: () => {
    set(state => ({ bonusXpEventActive: !state.bonusXpEventActive }));
  },

  updatePlayerZone: () => {
    // Placeholder to be implemented when zones are added
  },
  
  applySkillEffect: (targetId: string, effects: any[]) => {
    // Get the socket to communicate with the server
    const socket = get().socket;
    if (!socket) return;
    
    // Send the effects to be applied on the server
    socket.emit('applyEffects', { targetId, effects });
    
    console.log('Applying skill effects to target:', targetId, effects);
    
    // For client-side feedback, we could also update the local state
    // This is optional as the server will broadcast the updated state anyway
    const enemy = get().enemies[targetId];
    if (enemy) {
      // For visual feedback only - the server will handle the actual logic
      set(state => ({
        enemies: {
          ...state.enemies,
          [targetId]: {
            ...enemy,
            // You might want to add a temporary visual effect here
            // This is just for immediate feedback while waiting for the server update
          }
        }
      }));
    }
  },

  setHasJoinedGame: (joined: boolean) => set({ hasJoinedGame: joined }),

  // Move sync function - tells server our current position
  sendMoveSyncImmediate: (pos: VecXZ) => {
    const socket = get().socket;
    const myPlayerId = get().myPlayerId;
    
    if (!socket || !myPlayerId) {
      console.warn('Cannot send move sync: Socket not connected or player ID unknown');
      return;
    }
    
    // Send MoveSync with current position
    socket.emit('msg', {
      type: 'MoveSync',
      id: myPlayerId,
      pos,
      clientTs: Date.now()
    });
    
    // Update local player state
    const player = get().players[myPlayerId];
    if (player) {
      set(state => ({
        players: {
          ...state.players,
          [myPlayerId]: {
            ...player,
            movement: {
              dest: null,
              speed: 0,
              startTs: 0
            },
            position: { 
              ...player.position,
              x: pos.x, 
              z: pos.z 
            }
          }
        }
      }));
    }
  },
}));


// ==============================================================================
// FILE: app/game/systems/interpolation.ts
// ==============================================================================

export interface Snap { pos:{x:number,z:number}; rot:number; vel:{x:number,z:number}; snapTs:number }

export class SnapBuffer {
  private buf: Snap[] = [];
  
  push(s:Snap){ 
    // Skip invalid entries
    if (s === null || s === undefined || isNaN(s.snapTs)) {
      console.warn("Skipping invalid snap entry:", s);
      return;
    }
    
    this.buf.push(s); 
    while(this.buf.length > 20) this.buf.shift(); 
  }
  
  /**
   * Returns interpolated {x,z,rot} or extrapolated position if we're outside range 
   */
  sample(renderTs:number, speedCap:number){
    try {
      if(this.buf.length===0) return null;
  
      // Safety check for NaN values
      if (isNaN(renderTs)) {
        console.error("Invalid renderTs:", renderTs);
        return null;
      }
  
      // Find first snap with snapTs > renderTs
      const i = this.buf.findIndex(s => s && !isNaN(s.snapTs) && s.snapTs > renderTs);
  
      /* Case A  we're *before* the first snap (shouldn't happen after lag),
          just show that first snap. */
      if(i===0){
          const s=this.buf[0];
          return {x:s.pos.x,z:s.pos.z,rot:s.rot};
      }
  
      /* Case B  we're *between* two snaps  normal lerp. */
      if(i>0){
          const s0=this.buf[i-1], s1=this.buf[i];
          const t=(renderTs-s0.snapTs)/(s1.snapTs-s0.snapTs);
          return {
              x: s0.pos.x + (s1.pos.x-s0.pos.x)*t,
              z: s0.pos.z + (s1.pos.z-s0.pos.z)*t,
              rot: lerpAngle(s0.rot,s1.rot,t)
          };
      }
  
      /* Case C  we're *after* the newest snap  **extrapolate** a bit. */
      const sLast=this.buf[this.buf.length-1];
      const dt = (renderTs - sLast.snapTs)/1000;
      const maxDist = speedCap * dt * 1.2;
      const dx = clamp(sLast.vel.x * dt, -maxDist, maxDist);
      const dz = clamp(sLast.vel.z * dt, -maxDist, maxDist);
      return { x: sLast.pos.x+dx, z: sLast.pos.z+dz, rot: sLast.rot };
    } catch (err) {
      console.error("Error in SnapBuffer.sample:", err);
      return null;
    }
  }
}

/**
 * Clamps a value between a minimum and maximum value
 */
function clamp(v:number, min:number, max:number){ 
  return Math.min(max, Math.max(min, v)); 
}

/**
 * Lerps between two angles with wrapping around 2PI
 */
function lerpAngle(a:number, b:number, t:number){
  let d = b-a;
  if(d > Math.PI) d -= 2*Math.PI;
  if(d < -Math.PI) d += 2*Math.PI;
  return a + d*t;
}


// ==============================================================================
// FILE: app/game/systems/moveSimulation.ts
// ==============================================================================

'use client';

import { Vector3 } from 'three';

// Ground position constant
export const GROUND_Y = 0.5;

// Vector interface for XZ positions
export interface VecXZ {
  x: number;
  z: number;
}

/**
 * Simulates movement for a physics body towards a destination
 * 
 * @param body The physics body to move
 * @param dest The destination position (can be null if no movement)
 * @param speed The movement speed in units per second
 * @param delta Time elapsed since last frame in seconds
 * @returns true if movement is still in progress, false if arrived or no destination
 */
export function simulateMovement(
  body: any, // Using any for RigidBodyApi to avoid dependency issues
  dest: VecXZ | null,
  speed: number,
  delta: number
): boolean {
  // No movement if no destination
  if (!dest) return false;
  
  // Get current position
  const pos = body.translation();
  
  // Calculate direction vector to destination
  const dir = new Vector3(dest.x - pos.x, 0, dest.z - pos.z);
  
  // Calculate distance to destination
  const dist = dir.length();
  
  // If we're close enough to destination, consider it reached
  if (dist < 0.05) return false;
  
  // Normalize and scale by speed and delta time
  dir.normalize().multiplyScalar(speed * delta);
  
  // Prevent overshooting
  if (dir.length() > dist) dir.setLength(dist);
  
  // Set next position
  body.setNextKinematicTranslation({ 
    x: pos.x + dir.x, 
    y: GROUND_Y, 
    z: pos.z + dir.z 
  });
  
  // Movement is still in progress
  return true;
}

/**
 * Checks if a player has reached their destination
 * 
 * @param currentPos Current position
 * @param destPos Destination position
 * @returns true if destination is reached (or close enough)
 */
export function hasReachedDestination(currentPos: {x: number, z: number}, destPos: VecXZ | null): boolean {
  if (!destPos) return true;
  
  const dx = destPos.x - currentPos.x;
  const dz = destPos.z - currentPos.z;
  const dist = Math.sqrt(dx * dx + dz * dz);
  
  return dist < 0.05;
}


// ==============================================================================
// FILE: app/game/systems/projectileManager.ts
// ==============================================================================

import { create } from 'zustand';
import { ProjSpawn2, ProjHit2 } from '../../../shared/messages';

// Define interfaces for our state
export interface ProjectileState {
  id: string;
  skillId: string;
  origin: {x: number; y: number; z: number};
  dir: {x: number; y: number; z: number};
  speed: number;
  launchTs: number;
  fadeOutStartTs?: number;
  opacity: number;
  castId?: string; // For the enhanced system
}

// Enhanced projectile live state
export interface ProjectileLive {
  projId: string;
  startPos: {x: number; z: number};
  dirXZ: {x: number; z: number};
  speed: number;
  launchTs: number;
  hitRadius?: number;
  casterId?: string;
  skillId: string;
  state: 'active' | 'hit';
  fadeOutStartTs?: number;
  opacity: number;
  travelMs?: number; // Travel time in milliseconds for accurate client-side animation
}

interface ProjectileStore {
  projectiles: Record<string, ProjectileState>;
  enhanced: Record<string, ProjectileLive>; // New map for enhanced projectiles
  updateOpacity: () => void;
  
  // New methods for the enhanced system
  addEnhancedProjectile: (data: ProjSpawn2) => void;
  handleEnhancedHit: (data: ProjHit2) => void;
}

// Duration of fade-out effect in milliseconds
const FADE_OUT_DURATION_MS = 500; // Increased from 300ms to 500ms for smoother fade-out

export const useProjectileStore = create<ProjectileStore>((set, get) => ({
  projectiles: {},
  enhanced: {}, // Initialize the enhanced projectiles map
  
  updateOpacity: () => {
    const now = Date.now();
    
    set(state => {
      const updatedProjectiles: Record<string, ProjectileState> = {};
      const updatedEnhanced: Record<string, ProjectileLive> = {};
      let hasChanges = false;
      let enhancedChanges = false;
      
      // Process each projectile
      Object.values(state.projectiles).forEach(proj => {
        // If projectile is fading out
        if (proj.fadeOutStartTs) {
          const elapsedFadeTime = now - proj.fadeOutStartTs;
          
          // If fade complete, don't include in updated list (remove it)
          if (elapsedFadeTime >= FADE_OUT_DURATION_MS) {
            hasChanges = true;
            return;
          }
          
          // Calculate new opacity
          const newOpacity = Math.max(0, 1 - (elapsedFadeTime / FADE_OUT_DURATION_MS));
          
          // Only update if opacity changed significantly
          if (Math.abs(newOpacity - proj.opacity) > 0.01) {
            hasChanges = true;
            updatedProjectiles[proj.id] = {
              ...proj,
              opacity: newOpacity
            };
          } else {
            updatedProjectiles[proj.id] = proj;
          }
        } else {
          // Keep active projectiles
          updatedProjectiles[proj.id] = proj;
        }
      });
      
      // Process each enhanced projectile
      Object.values(state.enhanced).forEach(proj => {
        if (proj.fadeOutStartTs) {
          const elapsedFadeTime = now - proj.fadeOutStartTs;
          
          // If fade complete, don't include in updated list (remove it)
          if (elapsedFadeTime >= FADE_OUT_DURATION_MS) {
            enhancedChanges = true;
            return;
          }
          
          // Calculate new opacity
          const newOpacity = Math.max(0, 1 - (elapsedFadeTime / FADE_OUT_DURATION_MS));
          
          // Only update if opacity changed significantly
          if (Math.abs(newOpacity - proj.opacity) > 0.01) {
            enhancedChanges = true;
            updatedEnhanced[proj.projId] = {
              ...proj,
              opacity: newOpacity
            };
          } else {
            updatedEnhanced[proj.projId] = proj;
          }
        } else {
          // Keep active projectiles
          updatedEnhanced[proj.projId] = proj;
        }
      });
      
      // Only update state if changes occurred
      return (hasChanges || enhancedChanges) ? { 
        projectiles: updatedProjectiles,
        enhanced: updatedEnhanced
      } : state;
    });
  },
  
  addEnhancedProjectile: (data: ProjSpawn2) => {
    set(state => ({
      enhanced: {
        ...state.enhanced,
        [data.castId]: {
          projId: data.castId,
          startPos: data.origin,
          dirXZ: data.dir,
          speed: data.speed,
          launchTs: data.launchTs,
          hitRadius: data.hitRadius,
          casterId: data.casterId || 'unknown', // Handle potential undefined casterId
          skillId: data.skillId || 'unknown',  // Handle potential undefined skillId
          state: 'active',
          opacity: 1.0,
          travelMs: data.travelMs // Store the server-provided travel time
        }
      }
    }));
  },
  
  handleEnhancedHit: (data: ProjHit2) => {
    // Mark the projectile as hit and start fade-out
    set(state => {
      const projectile = state.enhanced[data.castId];
      if (!projectile) return state;
      
      return {
        enhanced: {
          ...state.enhanced,
          [data.castId]: {
            ...projectile,
            state: 'hit',
            fadeOutStartTs: Date.now(),
          }
        }
      };
    });
  },
}));  // Export the function directly
export function initProjectileListeners() {
  // Legacy event listeners removed
  
  // New enhanced event listeners - using custom events to match existing pattern
  window.addEventListener('projspawn2', (event: any) => {
    useProjectileStore.getState().addEnhancedProjectile(event.detail);
  });
  
  window.addEventListener('projhit2', (event: any) => {
    useProjectileStore.getState().handleEnhancedHit(event.detail);
  });
  
  // Set up opacity updates using requestAnimationFrame for smoother animations
  let animationFrameId: number;
  
  function updateLoop() {
    useProjectileStore.getState().updateOpacity();
    animationFrameId = requestAnimationFrame(updateLoop);
  }
  
  // Start the animation loop
  animationFrameId = requestAnimationFrame(updateLoop);
  
  // Return a cleanup function that can be used if needed
  return () => {
    cancelAnimationFrame(animationFrameId);
  };
}


// ==============================================================================
// FILE: app/game/systems/skillEffects.ts
// ==============================================================================

'use client';

// This is a utility file to help handle skill effects
// It provides a simple implementation of the missing applySkillEffect function

// Function to apply a skill effect to a target
export function applySkillEffect(targetId: string, effects: any[]) {
  // Get the socket from localStorage or another source that doesn't depend on the store
  // This is a workaround to avoid dependencies on the store which could cause cyclic issues
  try {
    // Log the request for debugging
    console.log(`Applying effects to target ${targetId}:`, effects);
    
    // Here we would normally send this to the server
    // For now, just log it and let the server handle the actual effect application
    // through its normal update cycle
    
    // If we had access to the socket, we'd do something like:
    // socket.emit('applyEffect', { targetId, effects });
    
    // Since this is just a utility function, we'll return true to indicate success
    return true;
  } catch (error) {
    console.error('Error applying skill effect:', error);
    return false;
  }
}

export default {
  applySkillEffect
};


// ==============================================================================
// FILE: app/game/systems/skillUtils.ts
// ==============================================================================

'use client';

import { SKILLS, SkillId } from '../models/Skill';

/**
 * Utility functions for skill management that can be used across components
 */

/**
 * Helper function to validate and normalize a skill ID
 * @param skillId - A potential skill ID that needs validation
 * @returns A valid SkillId or null if invalid
 */
export function validateSkillId(skillId: any): SkillId | null {
  if (!skillId) return null;
  
  // If it's already a valid skill ID
  if (typeof skillId === 'string' && SKILLS[skillId as SkillId]) {
    return skillId as SkillId;
  }
  
  // Try to extract from a string that might contain a skill ID
  if (typeof skillId === 'string') {
    // Check if any known skill ID is part of this string
    const possibleMatch = Object.keys(SKILLS).find(id => 
      skillId.includes(id) || id.includes(skillId)
    );
    
    if (possibleMatch) {
      console.log(`Found matching skill: ${possibleMatch} from ${skillId}`);
      return possibleMatch as SkillId;
    }
  }
  
  return null;
}

/**
 * Get the proper skill icon path based on skill ID
 * @param skillId - The ID of the skill
 * @returns Path to the skill icon
 */
function getSkillIconPath(skillId: string) {
  // Special cases
  if (skillId === 'iceBolt') return '/game/skills/skill_icebolt.png';
  if (skillId === 'waterSplash') return '/game/skills/skill_water.png';
  
  // Default case - convert from skill ID to image path
  return `/game/skills/skill_${skillId}.png`;
}

const skillUtils = {
  validateSkillId,
  getSkillIconPath
};

export default skillUtils;


// ==============================================================================
// FILE: app/game/systems/vfxDispatcher.ts
// ==============================================================================

import { Socket } from 'socket.io-client';
import { InstantHit } from '../../../shared/messages';

type Msg = InstantHit;

export function hookVfx(socket:Socket){
  const emit = (name:string, detail:any) =>
    window.dispatchEvent(new CustomEvent(name.toLowerCase(), {detail}));

  socket.on('msg',(m:Msg)=>{
    switch(m.type){
      case 'InstantHit': emit('instanthit', m); break;
    }
  });
}


// ==============================================================================
// FILE: app/game/systems/zoneSystem.ts
// ==============================================================================

interface ZoneConfig {
  id: string;
  name: string;
  description: string;
  position: { x: number; y: number; z: number };
  radius: number;
  minLevel: number;
  maxLevel: number;
  mobs: {
    type: string;
    weight: number; // Spawn weight/probability
    minCount: number; // Minimum number of mobs
    maxCount: number; // Maximum number of mobs
  }[];
}

// Define different zones in the game world
export const GAME_ZONES: ZoneConfig[] = [
  {
    id: 'starter_meadow',
    name: 'Peaceful Meadows',
    description: 'A tranquil starting area with gentle slopes and scattered trees',
    position: { x: 0, y: 0, z: 0 },
    radius: 100,
    minLevel: 1,
    maxLevel: 3,
    mobs: [
      { type: 'goblin', weight: 70, minCount: 5, maxCount: 8 },
      { type: 'wolf', weight: 30, minCount: 2, maxCount: 4 }
    ]
  },
  {
    id: 'dark_forest',
    name: 'Dark Forest',
    description: 'A dense forest with challenging enemies',
    position: { x: 200, y: 0, z: 200 },
    radius: 150,
    minLevel: 3,
    maxLevel: 5,
    mobs: [
      { type: 'wolf', weight: 40, minCount: 4, maxCount: 8 },
      { type: 'skeleton', weight: 40, minCount: 4, maxCount: 6 },
      { type: 'orc', weight: 20, minCount: 2, maxCount: 4 }
    ]
  },
  {
    id: 'rocky_highlands',
    name: 'Rocky Highlands',
    description: 'Elevated rocky terrain with strong enemies',
    position: { x: -200, y: 0, z: -200 },
    radius: 120,
    minLevel: 4,
    maxLevel: 7,
    mobs: [
      { type: 'troll', weight: 40, minCount: 3, maxCount: 6 },
      { type: 'orc', weight: 60, minCount: 5, maxCount: 8 }
    ]
  },
  {
    id: 'misty_lake',
    name: 'Misty Lake',
    description: 'A mysterious lake area with unique creatures',
    position: { x: -150, y: 0, z: 250 },
    radius: 100,
    minLevel: 2,
    maxLevel: 4,
    mobs: [
      { type: 'goblin', weight: 50, minCount: 4, maxCount: 7 },
      { type: 'skeleton', weight: 50, minCount: 3, maxCount: 6 }
    ]
  },
  // New high-level zones
  {
    id: 'cursed_ruins',
    name: 'Cursed Ruins',
    description: 'Ancient ruins teeming with undead creatures',
    position: { x: 400, y: 0, z: -100 },
    radius: 130,
    minLevel: 6,
    maxLevel: 9,
    mobs: [
      { type: 'skeleton', weight: 50, minCount: 6, maxCount: 10 },
      { type: 'wraith', weight: 30, minCount: 3, maxCount: 5 },
      { type: 'necromancer', weight: 20, minCount: 1, maxCount: 3 }
    ]
  },
  {
    id: 'dragon_peaks',
    name: 'Dragon Peaks',
    description: 'Treacherous mountain peaks where dragons roam',
    position: { x: -400, y: 0, z: 300 },
    radius: 160,
    minLevel: 8,
    maxLevel: 11,
    mobs: [
      { type: 'wyvern', weight: 40, minCount: 3, maxCount: 5 },
      { type: 'drake', weight: 40, minCount: 4, maxCount: 6 },
      { type: 'dragon', weight: 20, minCount: 1, maxCount: 2 }
    ]
  },
  {
    id: 'shadow_valley',
    name: 'Shadow Valley',
    description: 'A dark valley filled with dangerous shadow creatures',
    position: { x: 300, y: 0, z: 400 },
    radius: 140,
    minLevel: 10,
    maxLevel: 12,
    mobs: [
      { type: 'shadowbeast', weight: 50, minCount: 5, maxCount: 8 },
      { type: 'darkstalker', weight: 30, minCount: 3, maxCount: 5 },
      { type: 'voidwalker', weight: 20, minCount: 2, maxCount: 4 }
    ]
  },
  {
    id: 'crystal_caverns',
    name: 'Crystal Caverns',
    description: 'Mysterious caverns filled with powerful crystal entities',
    position: { x: -300, y: 0, z: -400 },
    radius: 130,
    minLevel: 11,
    maxLevel: 14,
    mobs: [
      { type: 'crystal_golem', weight: 40, minCount: 4, maxCount: 7 },
      { type: 'crystal_elemental', weight: 40, minCount: 3, maxCount: 6 },
      { type: 'crystal_guardian', weight: 20, minCount: 1, maxCount: 3 }
    ]
  }
];

export class ZoneManager {
  private zones: Map<string, {
    config: ZoneConfig;
    currentMobs: {
      id: string;
      type: string;
      level: number;
      position: { x: number; y: number; z: number };
    }[];
  }> = new Map();

  constructor() {
    // Initialize zones
    GAME_ZONES.forEach(zoneConfig => {
      this.zones.set(zoneConfig.id, {
        config: zoneConfig,
        currentMobs: []
      });
    });
  }

  // Get zone by position
  getZoneAtPosition(position: { x: number; y: number; z: number }): ZoneConfig | null {
    for (const zone of GAME_ZONES) {
      const dx = zone.position.x - position.x;
      const dz = zone.position.z - position.z;
      const distanceSquared = dx * dx + dz * dz;
      if (distanceSquared <= zone.radius * zone.radius) {
        return zone;
      }
    }
    return null;
  }

  // Get random position within a zone
  getRandomPositionInZone(zoneId: string): { x: number; y: number; z: number } | null {
    const zone = this.zones.get(zoneId)?.config;
    if (!zone) return null;

    const angle = Math.random() * Math.PI * 2;
    const distance = Math.random() * zone.radius;
    return {
      x: zone.position.x + Math.cos(angle) * distance,
      y: 0,
      z: zone.position.z + Math.sin(angle) * distance
    };
  }

  // Get mobs needed to spawn in a zone
  getMobsToSpawn(zoneId: string): { type: string; count: number }[] {
    const zone = this.zones.get(zoneId);
    if (!zone) return [];

    const currentCounts = new Map<string, number>();
    zone.currentMobs.forEach(mob => {
      currentCounts.set(mob.type, (currentCounts.get(mob.type) || 0) + 1);
    });

    return zone.config.mobs.map(mobConfig => {
      const current = currentCounts.get(mobConfig.type) || 0;
      const needed = Math.max(0, mobConfig.minCount - current);
      return { type: mobConfig.type, count: needed };
    });
  }

  // Update mob counts for a zone
  updateZoneMobs(zoneId: string, mobs: { id: string; type: string; level: number; position: { x: number; y: number; z: number } }[]) {
    const zone = this.zones.get(zoneId);
    if (zone) {
      zone.currentMobs = mobs;
    }
  }

  // Get appropriate level for a mob in a zone
  getMobLevel(zoneId: string): number {
    const zone = this.zones.get(zoneId)?.config;
    if (!zone) return 1;

    return Math.floor(zone.minLevel + Math.random() * (zone.maxLevel - zone.minLevel + 1));
  }

  // Get all zones
  getAllZones(): ZoneConfig[] {
    return GAME_ZONES;
  }
}

export const zoneManager = new ZoneManager();

// ==============================================================================
// FILE: app/game/vfx/FireballProjectile.tsx
// ==============================================================================

import { useRef, useState, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { Vector3, Mesh, Color, Group, Material, MeshBasicMaterial } from 'three';

interface FireballProjectileProps {
  id: string;
  origin: {x: number; y: number; z: number};
  dir: {x: number; y: number; z: number};
  speed: number;
  launchTs?: number; // Add launch timestamp
}

interface FireParticle {
  id: string;
  position: Vector3;
  scale: number;
  opacity: number;
  velocity: Vector3;
  lifetimeMs: number;
  color: Color;
}

export function FireballProjectile({ id = `fireball-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`, origin, dir, speed, launchTs }: FireballProjectileProps) {
  const coreRef = useRef<Mesh>(null);
  const groupRef = useRef<Group>(null);
  const pos = useRef(new Vector3(origin.x, origin.y, origin.z));
  const originalOrigin = useRef(new Vector3(origin.x, origin.y, origin.z));
  const originalDir = useRef(new Vector3(dir.x, dir.y, dir.z));
  const originalSpeed = useRef(speed);
  const originalLaunchTs = useRef(launchTs || performance.now());
  
  const [particles, setParticles] = useState<FireParticle[]>([]);
  const timeOffset = useRef(Math.random() * Math.PI * 2);
  
  // Generate initial fire particles only once on component mount
  useEffect(() => {
    const initialParticles: FireParticle[] = [];
    for (let i = 0; i < 15; i++) {
      initialParticles.push({
        id: `flame-${id}-initial-${i}-${Math.random().toString(36).substr(2, 9)}`,
        position: new Vector3(
          origin.x + (Math.random() - 0.5) * 0.3,
          origin.y + (Math.random() - 0.5) * 0.3,
          origin.z + (Math.random() - 0.5) * 0.3
        ),
        scale: 0.05 + Math.random() * 0.15,
        opacity: 0.6 + Math.random() * 0.4,
        velocity: new Vector3(
          (Math.random() - 0.5) * 1,
          (Math.random() - 0.5) * 1,
          (Math.random() - 0.5) * 1
        ),
        lifetimeMs: 100 + Math.random() * 300,
        color: new Color().setHSL(
          0.05 + Math.random() * 0.06, // orange-red hue
          0.7 + Math.random() * 0.3,   // saturation
          0.5 + Math.random() * 0.5    // lightness
        )
      });
    }
    setParticles(initialParticles);
  }, []); // Empty dependency array ensures this only runs once on mount
  
  useFrame((state, delta) => {
    if (!coreRef.current) return;
    
    // Calculate position based on server parameters and elapsed time
    // This ensures the projectile follows exactly the path determined by the server
    const elapsedTimeSec = (performance.now() - originalLaunchTs.current) / 1000;
    
    // Calculate the exact position based on origin, direction, speed, and time
    const distanceTraveled = originalSpeed.current * elapsedTimeSec;
    pos.current.x = originalOrigin.current.x + originalDir.current.x * distanceTraveled;
    pos.current.y = originalOrigin.current.y + originalDir.current.y * distanceTraveled;
    pos.current.z = originalOrigin.current.z + originalDir.current.z * distanceTraveled;
    
    // Apply the calculated position to the mesh
    coreRef.current.position.copy(pos.current);
    
    // Fire core pulsing
    const pulseFactor = Math.sin(state.clock.elapsedTime * 15 + timeOffset.current) * 0.15 + 1;
    coreRef.current.scale.set(pulseFactor, pulseFactor, pulseFactor);
    
    // Random fire flickering through material opacity
    if (coreRef.current.material instanceof MeshBasicMaterial) {
      const flickerOpacity = 0.8 + Math.sin(state.clock.elapsedTime * 20) * 0.2;
      coreRef.current.material.opacity = flickerOpacity;
    }
    
    // Add fire trail particles
    if (Math.random() > 0.4) {
      const newParticle: FireParticle = {
        id: `flame-${id}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        position: pos.current.clone().add(
          new Vector3(
            (Math.random() - 0.5) * 0.3,
            (Math.random() - 0.5) * 0.3,
            (Math.random() - 0.5) * 0.3 - 0.2 // bias toward trail behind
          )
        ),
        scale: 0.05 + Math.random() * 0.15,
        opacity: 0.6 + Math.random() * 0.4,
        velocity: new Vector3(
          (Math.random() - 0.5) * 1,
          (Math.random() * 1), // upward bias
          (Math.random() - 0.5) * 1
        ),
        lifetimeMs: 200 + Math.random() * 300,
        color: new Color().setHSL(
          0.05 + Math.random() * 0.06, // orange-red hue
          0.7 + Math.random() * 0.3,   // saturation
          0.5 + Math.random() * 0.5    // lightness
        )
      };
      
      setParticles(prev => [...prev, newParticle]);
    }
    
    // Update fire particles
    setParticles(prev => 
      prev.map(particle => {
        // Rise and drift
        particle.position.x += particle.velocity.x * delta;
        particle.position.y += particle.velocity.y * delta;
        particle.position.z += particle.velocity.z * delta;
        
        // Make particles rise faster as they age
        particle.velocity.y += delta * 0.5;
        
        // Expand slightly as they rise
        const newScale = particle.scale * (1 + delta * 0.3);
        
        return {
          ...particle,
          scale: newScale,
          lifetimeMs: particle.lifetimeMs - delta * 1000,
          opacity: Math.max(0, particle.lifetimeMs / 300) // fade out
        };
      }).filter(p => p.lifetimeMs > 0 && p.opacity > 0.05)
    );
  });
  
  return (
    <group ref={groupRef}>
      {/* Main fire core */}
      <mesh key={`core-${id}`} ref={coreRef}>
        <sphereGeometry key={`core-geo-${id}`} args={[0.25, 16, 16]} />
        <meshBasicMaterial 
          key={`core-mat-${id}`}
          color={new Color(0xff5500)}
          transparent={true}
          opacity={0.9}
        />
      </mesh>
      
      {/* Outer glow */}
      <mesh key={`glow-${id}`} position={pos.current.toArray()}>
        <sphereGeometry key={`glow-geo-${id}`} args={[0.4, 16, 16]} />
        <meshBasicMaterial 
          key={`glow-mat-${id}`}
          color={new Color(0xff8800)}
          transparent={true}
          opacity={0.4}
        />
      </mesh>
      
      {/* Fire particles */}
      {particles.map((particle) => (
        <mesh
          key={particle.id}
          position={[particle.position.x, particle.position.y, particle.position.z]}
          scale={[particle.scale, particle.scale, particle.scale]}
        >
          <sphereGeometry key={`geo-${particle.id}`} args={[0.1, 8, 8]} />
          <meshBasicMaterial 
            key={`mat-${particle.id}`}
            color={particle.color}
            transparent={true}
            opacity={particle.opacity}
          />
        </mesh>
      ))}
    </group>
  );
}

// Make sure to export both as named and default export for compatibility
export default FireballProjectile;


// ==============================================================================
// FILE: app/game/vfx/IceBoltProjectile.tsx
// ==============================================================================

import { useRef, useState } from 'react';
import { useFrame } from '@react-three/fiber';
import { Vector3, Mesh, Color, Group } from 'three';

interface IceBoltProjectileProps {
  id: string;
  origin: {x: number; y: number; z: number};
  dir: {x: number; y: number; z: number};
  speed: number;
}

interface IceParticle {
  position: Vector3;
  scale: number;
  opacity: number;
  velocity: Vector3;
  lifetimeMs: number;
  rotation: Vector3;
  rotationSpeed: Vector3;
}

export function IceBoltProjectile({ id, origin, dir, speed }: IceBoltProjectileProps) {
  const coreRef = useRef<Mesh>(null);
  const groupRef = useRef<Group>(null);
  const pos = useRef(new Vector3(origin.x, origin.y, origin.z));
  const [particles, setParticles] = useState<IceParticle[]>([]);
  const timeOffset = useRef(Math.random() * Math.PI * 2);
  
  useFrame((state, delta) => {
    if (!coreRef.current) return;
    
    // Move projectile
    pos.current.x += dir.x * speed * delta;
    pos.current.y += dir.y * speed * delta;
    pos.current.z += dir.z * speed * delta;
    coreRef.current.position.copy(pos.current);
    
    // Rotate core
    coreRef.current.rotation.x += delta * 2;
    coreRef.current.rotation.z += delta * 3;
    
    // Subtle pulsing
    const pulseFactor = Math.sin(state.clock.elapsedTime * 8 + timeOffset.current) * 0.05 + 1;
    coreRef.current.scale.set(pulseFactor, pulseFactor, pulseFactor);
    
    // Add ice trail particles
    if (Math.random() > 0.6) {
      const newParticle: IceParticle = {
        position: pos.current.clone().add(
          new Vector3(
            (Math.random() - 0.5) * 0.2,
            (Math.random() - 0.5) * 0.2,
            (Math.random() - 0.5) * 0.2
          )
        ),
        scale: 0.03 + Math.random() * 0.08,
        opacity: 0.7 + Math.random() * 0.3,
        velocity: new Vector3(
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5
        ),
        lifetimeMs: 400 + Math.random() * 300,
        rotation: new Vector3(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        ),
        rotationSpeed: new Vector3(
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2
        )
      };
      
      setParticles(prev => [...prev, newParticle]);
    }
    
    // Update ice particles
    setParticles(prev => 
      prev.map(particle => {
        // Drift slowly
        particle.position.x += particle.velocity.x * delta;
        particle.position.y += particle.velocity.y * delta;
        particle.position.z += particle.velocity.z * delta;
        
        // Update rotation
        particle.rotation.x += particle.rotationSpeed.x * delta;
        particle.rotation.y += particle.rotationSpeed.y * delta;
        particle.rotation.z += particle.rotationSpeed.z * delta;
        
        return {
          ...particle,
          lifetimeMs: particle.lifetimeMs - delta * 1000,
          opacity: Math.max(0, particle.lifetimeMs / 500) // fade out
        };
      }).filter(p => p.lifetimeMs > 0 && p.opacity > 0.05)
    );
  });
  
  return (
    <group ref={groupRef}>
      {/* Main ice core - using an icosahedron for crystalline look */}
      <mesh ref={coreRef}>
        <icosahedronGeometry args={[0.2, 1]} />
        <meshStandardMaterial 
          color={new Color(0xaad4ff)}
          transparent={true}
          opacity={0.7}
          roughness={0.1}
          metalness={0.9}
          emissive={new Color(0x84b9ff)}
          emissiveIntensity={0.5}
        />
      </mesh>
      
      {/* Outer glow */}
      <mesh position={pos.current.toArray()}>
        <sphereGeometry args={[0.35, 16, 16]} />
        <meshBasicMaterial 
          color={new Color(0xc7e0ff)}
          transparent={true}
          opacity={0.3}
        />
      </mesh>
      
      {/* Ice particles - using boxGeometry for crystal-like shards */}
      {particles.map((particle, index) => (
        <mesh
          key={`ice-${id}-${index}`}
          position={[particle.position.x, particle.position.y, particle.position.z]}
          rotation={[particle.rotation.x, particle.rotation.y, particle.rotation.z]}
          scale={[particle.scale, particle.scale, particle.scale]}
        >
          <boxGeometry args={[0.1, 0.1, 0.1]} />
          <meshStandardMaterial 
            color={new Color(0xd1e6ff)}
            transparent={true}
            opacity={particle.opacity}
            roughness={0.1}
            metalness={0.8}
          />
        </mesh>
      ))}
    </group>
  );
}

// Make sure to export both as named and default export for compatibility
export default IceBoltProjectile;


// ==============================================================================
// FILE: app/game/vfx/IceBoltVfx.tsx
// ==============================================================================

'use client';

import { useRef, useState } from 'react';
import { useFrame } from '@react-three/fiber';
import { Vector3, Mesh } from 'three';

interface IceBoltVfxProps {
  id?: string;
  origin: {x: number; y: number; z: number};
  dir: {x: number; y: number; z: number};
  speed: number;
}

// Define as a named function first
export function IceBoltVfx({ id = `icebolt-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`, origin, dir, speed }: IceBoltVfxProps) {
  const ref = useRef<Mesh>(null);
  const pos = useRef(new Vector3(origin.x, origin.y, origin.z));
  
  useFrame((_, d) => { 
    if (ref.current) { 
      pos.current.addScaledVector(new Vector3(dir.x, dir.y, dir.z), speed * d);
      ref.current.position.copy(pos.current);
    } 
  });
  
  return (
    <mesh ref={ref}>
      <coneGeometry key={`icebolt-geo-${id}`} args={[0.25, 1]} />
      <meshBasicMaterial key={`icebolt-mat-${id}`} color="skyblue" />
    </mesh>
  );
}

// Also export as default
export default IceBoltVfx;


// ==============================================================================
// FILE: app/game/vfx/PetrifyFlash.tsx
// ==============================================================================

'use client';

import { useState } from 'react';
import { useFrame } from '@react-three/fiber';

interface Vec3 {
  x: number;
  y: number;
  z: number;
}

// Export as named export
export function PetrifyFlash({ pos }: { pos: Vec3 }) {
  const [scale, setScale] = useState(0);
  
  useFrame((_, d) => {
    setScale(s => s < 2 ? s + 5 * d : 0);
  });
  
  if (scale === 0) return null;
  
  return (
    <mesh position={[pos.x, pos.y + 1, pos.z]} scale={scale}>
      <icosahedronGeometry args={[0.5, 1]} />
      <meshBasicMaterial color="yellow" transparent opacity={1 - scale / 2} />
    </mesh>
  );
}

// Also export as default for consistency
export default PetrifyFlash;


// ==============================================================================
// FILE: app/game/vfx/ProjectileVfx.tsx
// ==============================================================================

import { useFrame } from '@react-three/fiber';
import { useRef, useState, useMemo, useEffect } from 'react';
import { Vector3, Mesh, Material, MathUtils, Color, Group } from 'three';
import { useProjectileStore } from '../systems/projectileManager';

interface ProjectileVfxProps {
  id: string;
  origin: {x: number; y: number; z: number};
  dir: {x: number; y: number; z: number};
  speed: number;
  launchTs?: number; // Add launch timestamp
  travelMs?: number; // Travel time for client-side animation
}

interface TrailParticle {
  position: Vector3;
  scale: number;
  opacity: number;
  lifetimeMs: number;
  rotationSpeed: Vector3;
  rotation: Vector3;
}

function ProjectileVfx({id = `proj-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`, origin, dir, speed, launchTs, travelMs}: ProjectileVfxProps) {
  const ref = useRef<Mesh>(null);
  const groupRef = useRef<Group>(null);
  const pos = useRef(new Vector3(origin.x, origin.y, origin.z));
  const originalOrigin = useRef(new Vector3(origin.x, origin.y, origin.z));
  const originalDir = useRef(new Vector3(dir.x, dir.y, dir.z));
  const originalSpeed = useRef(speed);
  const originalLaunchTs = useRef(launchTs || performance.now());
  const originalTravelMs = useRef(travelMs || null);
  
  const timeOffset = useRef(Math.random() * Math.PI * 2);
  const [intensity, setIntensity] = useState(2);
  const [trailParticles, setTrailParticles] = useState<TrailParticle[]>([]);
  
  // Get projectile opacity from store
  const projectileState = useProjectileStore(state => state.projectiles[id]);
  const opacity = projectileState?.opacity ?? 1.0;
  const isFadingOut = projectileState?.fadeOutStartTs !== undefined;
  
  // Normalize direction vector if needed
  const normalizedDir = useMemo(() => {
    const length = Math.sqrt(dir.x * dir.x + dir.y * dir.y + dir.z * dir.z);
    if (length === 0) return { x: 0, y: 0, z: 0 };
    return {
      x: dir.x / length,
      y: dir.y / length,
      z: dir.z / length
    };
  }, [dir]);
  
  useFrame((state, delta) => {
    if (!ref.current) return;
    
    // If fading out, don't update position
    if (!isFadingOut) {
      // Calculate position based on server parameters and elapsed time
      // This ensures the projectile follows exactly the path determined by the server
      const elapsedTimeSec = (performance.now() - originalLaunchTs.current) / 1000;
      
      // Calculate the exact position based on origin, direction, speed, and time
      const distanceTraveled = originalSpeed.current * elapsedTimeSec;
      pos.current.x = originalOrigin.current.x + originalDir.current.x * distanceTraveled;
      pos.current.y = originalOrigin.current.y + originalDir.current.y * distanceTraveled;
      pos.current.z = originalOrigin.current.z + originalDir.current.z * distanceTraveled;
      
      // Apply the calculated position to the mesh
      ref.current.position.copy(pos.current);
    }
    
    // Update material opacity
    if (ref.current.material instanceof Material) {
      (ref.current.material as any).opacity = opacity;
    }
    
    // Make the projectile pulsate
    const pulseFactor = MathUtils.lerp(0.9, 1.1, Math.sin(state.clock.elapsedTime * 8 + timeOffset.current));
    ref.current.scale.set(pulseFactor, pulseFactor, pulseFactor);
    
    // Random wobble movement
    if (groupRef.current) {
      groupRef.current.position.x += Math.sin(state.clock.elapsedTime * 15) * 0.015;
      groupRef.current.position.y += Math.cos(state.clock.elapsedTime * 12) * 0.015;
    }
    
    // Varying light intensity (reduced when fading out)
    const baseIntensity = 2 * opacity;
    const newIntensity = baseIntensity + Math.sin(state.clock.elapsedTime * 10 + timeOffset.current) * 0.5 * opacity;
    setIntensity(newIntensity);
    
    // Add trail particles (fewer when fading out)
    if (Math.random() > 0.6 && (!isFadingOut || Math.random() > 0.8)) {
      const newParticle: TrailParticle = {
        position: pos.current.clone().add(
          new Vector3(
            (Math.random() - 0.5) * 0.2,
            (Math.random() - 0.5) * 0.2,
            (Math.random() - 0.5) * 0.2
          )
        ),
        scale: 0.1 + Math.random() * 0.2,
        opacity: 0.8 * opacity, // Adjust opacity based on projectile opacity
        lifetimeMs: 400 + Math.random() * 200,
        rotationSpeed: new Vector3(
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2
        ),
        rotation: new Vector3()
      };
      
      setTrailParticles(prev => [...prev, newParticle]);
    }
    
    // Update trail particles
    setTrailParticles(prev => 
      prev.map(particle => {
        // Update lifetime
        const newLifetime = particle.lifetimeMs - delta * 1000;
        
        // Update rotation
        particle.rotation.x += particle.rotationSpeed.x * delta;
        particle.rotation.y += particle.rotationSpeed.y * delta;
        particle.rotation.z += particle.rotationSpeed.z * delta;
        
        return {
          ...particle,
          lifetimeMs: newLifetime,
          opacity: Math.max(0, newLifetime / 400) * opacity, // fade out and respect projectile opacity
          scale: particle.scale * 0.97 // shrink over time
        };
      }).filter(p => p.lifetimeMs > 0)
    );
  });
  
  return (
    <group ref={groupRef}>
      {/* Main projectile */}
      <mesh ref={ref}>
        <sphereGeometry key={`proj-geo-${id}`} args={[0.25, 16, 16]} />
        <meshStandardMaterial 
          key={`proj-mat-${id}`}
          color={'orange'} 
          emissive={'orange'} 
          emissiveIntensity={intensity}
          transparent={true}
          opacity={opacity}
        />
        
        {/* Add glow effect */}
        <pointLight 
          key={`proj-light-${id}`}
          color={'orange'} 
          intensity={intensity} 
          distance={3} 
        />
      </mesh>
      
      {/* Trail particles */}
      {trailParticles.map((particle, index) => (
        <mesh
          key={`trail-${id}-${index}`}
          position={[particle.position.x, particle.position.y, particle.position.z]}
          rotation={[particle.rotation.x, particle.rotation.y, particle.rotation.z]}
          scale={[particle.scale, particle.scale, particle.scale]}
        >
          <sphereGeometry key={`trail-geo-${id}-${index}`} args={[0.15, 8, 8]} />
          <meshBasicMaterial 
            key={`trail-mat-${id}-${index}`}
            color={new Color(0xff8c00)} 
            transparent={true} 
            opacity={particle.opacity} 
          />
        </mesh>
      ))}
    </group>
  );
}

export default ProjectileVfx;


// ==============================================================================
// FILE: app/game/vfx/SplashVfx.tsx
// ==============================================================================

import React, { useEffect, useRef, useState, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import { Color, Mesh, Material, Vector3, MathUtils } from 'three';

interface SplashVfxProps {
  position: {x: number; y: number; z: number};
  radius: number;
}

interface WaterParticle {
  position: Vector3;
  initialY: number;
  velocity: Vector3;
  scale: number;
  opacity: number;
  color: Color;
  rotation: Vector3;
  rotationSpeed: Vector3;
  stretching: number;
}

interface MistParticle {
  position: Vector3;
  scale: number;
  opacity: number;
  velocity: Vector3;
  lifetimeMs: number;
  maxLifetimeMs: number;
}

export default function SplashVfx({ position, radius }: SplashVfxProps) {
  const ringRef = useRef<Mesh>(null);
  const [lifetime, setLifetime] = useState(1.0); // 1 second lifetime
  const uniqueId = useRef(`splash-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`);
  
  // Generate water droplet particles
  const particles = useMemo(() => {
    const particleCount = 10 + Math.floor(radius * 5); // Scale particles with radius
    return Array.from({ length: particleCount }, () => ({
      position: new Vector3(
        position.x + (Math.random() - 0.5) * radius * 0.6,
        position.y + Math.random() * 0.5,
        position.z + (Math.random() - 0.5) * radius * 0.6
      ),
      initialY: position.y,
      velocity: new Vector3(
        (Math.random() - 0.5) * 10,
        Math.random() * 8 + 6,
        (Math.random() - 0.5) * 10
      ),
      scale: 0.1 + Math.random() * 0.25,
      opacity: 1.0,
      color: new Color().setHSL(0.58 + Math.random() * 0.05, 0.8, 0.5 + Math.random() * 0.2),
      rotation: new Vector3(),
      rotationSpeed: new Vector3(
        Math.random() * 5, 
        Math.random() * 5, 
        Math.random() * 5
      ),
      stretching: 1.0
    }));
  }, [position, radius]);
  
  // State for tracking particles
  const [waterParticles, setWaterParticles] = useState<WaterParticle[]>(particles);
  const mistParticlesRef = useRef<MistParticle[]>([]);
  
  // Create initial mist particles
  useEffect(() => {
    // Clear existing mist particles to prevent duplicates
    mistParticlesRef.current = [];
    
    // Create mist particles
    const mistCount = Math.floor(10 * (radius / 3));
    
    for (let i = 0; i < mistCount; i++) {
      const angle = Math.random() * Math.PI * 2;
      const distance = (0.3 + Math.random() * 0.7) * radius;
      const maxLifetimeMs = 500 + Math.random() * 800;
      
      mistParticlesRef.current.push({
        position: new Vector3(
          position.x + Math.cos(angle) * distance * 0.7,
          position.y + Math.random() * 0.5,
          position.z + Math.sin(angle) * distance * 0.7
        ),
        scale: 0.3 + Math.random() * 0.4,
        opacity: 0.4 + Math.random() * 0.3,
        velocity: new Vector3(
          Math.cos(angle) * (0.5 + Math.random()),
          0.7 + Math.random() * 0.5,
          Math.sin(angle) * (0.5 + Math.random())
        ),
        lifetimeMs: maxLifetimeMs,
        maxLifetimeMs
      });
    }
  }, [position, radius]);
  
  useFrame((_, delta) => {
    if (!ringRef.current) return;
    
    // Shrink lifetime
    setLifetime(prev => Math.max(0, prev - delta));
    
    // Scale up the ring
    const progress = 1 - lifetime;
    ringRef.current.scale.x = radius * progress;
    ringRef.current.scale.z = radius * progress;
    
    // Fade out
    if (ringRef.current.material instanceof Material) {
      ringRef.current.material.opacity = lifetime;
    }
    
    // Update water particles
    setWaterParticles(prevParticles => 
      prevParticles.map(particle => {
        // Apply gravity
        particle.velocity.y -= 15 * delta;
        
        // Update position
        particle.position.x += particle.velocity.x * delta;
        particle.position.y += particle.velocity.y * delta;
        particle.position.z += particle.velocity.z * delta;
        
        // Handle bouncing
        if (particle.position.y < particle.initialY && particle.velocity.y < 0) {
          particle.velocity.y = -particle.velocity.y * 0.4;
          particle.velocity.x *= 0.8;
          particle.velocity.z *= 0.8;
          particle.position.y = particle.initialY + 0.05;
          
          // Reduce opacity on bounce
          particle.opacity *= 0.7;
        }
        
        // Update rotation
        particle.rotation.x += particle.rotationSpeed.x * delta;
        particle.rotation.y += particle.rotationSpeed.y * delta;
        particle.rotation.z += particle.rotationSpeed.z * delta;
        
        // Fade out over time
        particle.opacity = Math.max(0, particle.opacity - 0.5 * delta);
        
        return particle;
      }).filter(p => p.opacity > 0.1)
    );
    
    // Update mist particles
    const mistParticles = mistParticlesRef.current;
    for (let i = mistParticles.length - 1; i >= 0; i--) {
      const particle = mistParticles[i];
      
      // Update lifetime
      particle.lifetimeMs -= delta * 1000;
      
      // Update position
      particle.position.x += particle.velocity.x * delta * 0.5;
      particle.position.y += particle.velocity.y * delta * 0.5;
      particle.position.z += particle.velocity.z * delta * 0.5;
      
      // Fade out particles
      particle.opacity = MathUtils.lerp(0, 0.7, particle.lifetimeMs / particle.maxLifetimeMs);
      
      // Remove dead particles
      if (particle.lifetimeMs <= 0) {
        mistParticles.splice(i, 1);
      }
    }
  });
  
  // Remove when lifetime is over and all particles are gone
  if (lifetime <= 0 && waterParticles.length === 0 && mistParticlesRef.current.length === 0) return null;
  
  return (
    <group>
      {/* Main ring */}
      <mesh 
        ref={ringRef} 
        position={[position.x, position.y + 0.05, position.z]} // Slightly above ground
        rotation={[Math.PI / 2, 0, 0]} // Flat on ground
      >
        <ringGeometry args={[radius * 0.8, radius, 32]} />
        <meshBasicMaterial color={new Color(0x00a0ff)} transparent={true} opacity={1} />
      </mesh>
      
      {/* Water particles */}
      {waterParticles.map((particle, index) => (
        <mesh
          key={`water-${index}`}
          position={[particle.position.x, particle.position.y, particle.position.z]}
          rotation={[particle.rotation.x, particle.rotation.y, particle.rotation.z]}
          scale={[particle.scale, particle.scale * particle.stretching, particle.scale]}
        >
          <sphereGeometry args={[0.12, 8, 8]} />
          <meshBasicMaterial 
            color={particle.color} 
            transparent={true} 
            opacity={particle.opacity}
          />
        </mesh>
      ))}
      
      {/* Mist particles */}
      {mistParticlesRef.current.map((particle, index) => (
        <mesh
          key={`mist-${index}`}
          position={[particle.position.x, particle.position.y, particle.position.z]}
        >
          <sphereGeometry args={[0.15, 8, 8]} />
          <meshBasicMaterial
            color={new Color(0x88ccff)}
            transparent={true}
            opacity={particle.opacity}
          />
        </mesh>
      ))}
    </group>
  );
}

// Helper functions for spawning visual effects
export function spawnSplashVfx(position: {x: number; y: number; z: number}, radius: number, type?: string) {
  window.dispatchEvent(
    new CustomEvent('spawnSplash', { 
      detail: { 
        position, 
        radius,
        effectType: type || 'water'
      } 
    })
  );
}

export function spawnStunFlash(position: {x: number; y: number; z: number}) {
  window.dispatchEvent(
    new CustomEvent('spawnStunFlash', { detail: { position } })
  );
}

// Create a FireSplash component for fire effects
export function FireSplash({ position, radius }: SplashVfxProps) {
  const ringRef = useRef<Mesh>(null);
  const [lifetime, setLifetime] = useState(1.0);
  
  // Generate fire particles
  const particles = useMemo(() => {
    const particleCount = 10 + Math.floor(radius * 5);
    return Array.from({ length: particleCount }, () => ({
      position: new Vector3(
        position.x + (Math.random() - 0.5) * radius * 0.6,
        position.y + Math.random() * 0.5,
        position.z + (Math.random() - 0.5) * radius * 0.6
      ),
      initialY: position.y,
      velocity: new Vector3(
        (Math.random() - 0.5) * 10,
        Math.random() * 10 + 4, // Stronger upward motion
        (Math.random() - 0.5) * 10
      ),
      scale: 0.1 + Math.random() * 0.25,
      opacity: 1.0,
      color: new Color().setHSL(
        0.05 + Math.random() * 0.06, // Orange-red hue
        0.7 + Math.random() * 0.3,   // Saturation
        0.5 + Math.random() * 0.5    // Lightness
      ),
      rotation: new Vector3(),
      rotationSpeed: new Vector3(
        Math.random() * 5, 
        Math.random() * 5, 
        Math.random() * 5
      ),
      stretching: 1.5 // More stretching for fire particles
    }));
  }, [position, radius]);
  
  const [fireParticles, setFireParticles] = useState<WaterParticle[]>(particles);
  
  useFrame((_, delta) => {
    if (!ringRef.current) return;
    
    // Shrink lifetime
    setLifetime(prev => Math.max(0, prev - delta));
    
    // Scale up the ring
    const progress = 1 - lifetime;
    ringRef.current.scale.x = radius * progress;
    ringRef.current.scale.z = radius * progress;
    
    // Fire-specific fading
    if (ringRef.current.material instanceof Material) {
      ringRef.current.material.opacity = lifetime * 0.8;
    }
    
    // Update fire particles
    setFireParticles(prevParticles => 
      prevParticles.map(particle => {
        // Apply upward force (opposite of gravity for fire)
        particle.velocity.y += 2 * delta;
        
        // Update position
        particle.position.x += particle.velocity.x * delta;
        particle.position.y += particle.velocity.y * delta;
        particle.position.z += particle.velocity.z * delta;
        
        // Update rotation
        particle.rotation.x += particle.rotationSpeed.x * delta;
        particle.rotation.y += particle.rotationSpeed.y * delta;
        particle.rotation.z += particle.rotationSpeed.z * delta;
        
        // Fade out over time (faster for fire)
        particle.opacity = Math.max(0, particle.opacity - 0.8 * delta);
        
        return particle;
      }).filter(p => p.opacity > 0.1)
    );
  });
  
  // Remove when lifetime is over and all particles are gone
  if (lifetime <= 0 && fireParticles.length === 0) return null;
  
  return (
    <group>
      {/* Fire ring */}
      <mesh 
        ref={ringRef} 
        position={[position.x, position.y + 0.05, position.z]}
        rotation={[Math.PI / 2, 0, 0]}
      >
        <ringGeometry args={[radius * 0.8, radius, 32]} />
        <meshBasicMaterial color={new Color(0xff5500)} transparent={true} opacity={1} />
      </mesh>
      
      {/* Fire particles */}
      {fireParticles.map((particle, index) => (
        <mesh
          key={`fire-${index}`}
          position={[particle.position.x, particle.position.y, particle.position.z]}
          rotation={[particle.rotation.x, particle.rotation.y, particle.rotation.z]}
          scale={[particle.scale, particle.scale * particle.stretching, particle.scale]}
        >
          <sphereGeometry args={[0.12, 8, 8]} />
          <meshBasicMaterial 
            color={particle.color} 
            transparent={true} 
            opacity={particle.opacity}
          />
        </mesh>
      ))}
    </group>
  );
}

// Create an IceSplash component for ice effects
export function IceSplash({ position, radius }: SplashVfxProps) {
  const ringRef = useRef<Mesh>(null);
  const [lifetime, setLifetime] = useState(1.0);
  
  // Generate ice shard particles
  const particles = useMemo(() => {
    const particleCount = 10 + Math.floor(radius * 4);
    return Array.from({ length: particleCount }, () => ({
      position: new Vector3(
        position.x + (Math.random() - 0.5) * radius * 0.8,
        position.y + Math.random() * 0.3,
        position.z + (Math.random() - 0.5) * radius * 0.8
      ),
      initialY: position.y,
      velocity: new Vector3(
        (Math.random() - 0.5) * 12, // More horizontal spread
        Math.random() * 6 + 2,
        (Math.random() - 0.5) * 12  // More horizontal spread
      ),
      scale: 0.1 + Math.random() * 0.2,
      opacity: 0.8,
      color: new Color(0xaad4ff), // Ice blue color
      rotation: new Vector3(),
      rotationSpeed: new Vector3(
        Math.random() * 5, 
        Math.random() * 5, 
        Math.random() * 5
      ),
      stretching: 0.7 // Less stretching for ice crystals
    }));
  }, [position, radius]);
  
  const [iceParticles, setIceParticles] = useState<WaterParticle[]>(particles);
  
  useFrame((_, delta) => {
    if (!ringRef.current) return;
    
    // Shrink lifetime
    setLifetime(prev => Math.max(0, prev - delta));
    
    // Scale up the ring
    const progress = 1 - lifetime;
    ringRef.current.scale.x = radius * progress;
    ringRef.current.scale.z = radius * progress;
    
    // Ice-specific fading
    if (ringRef.current.material instanceof Material) {
      ringRef.current.material.opacity = lifetime * 0.9;
    }
    
    // Update ice particles
    setIceParticles(prevParticles => 
      prevParticles.map(particle => {
        // Apply gravity
        particle.velocity.y -= 12 * delta;
        
        // Update position
        particle.position.x += particle.velocity.x * delta;
        particle.position.y += particle.velocity.y * delta;
        particle.position.z += particle.velocity.z * delta;
        
        // Handle bouncing
        if (particle.position.y < particle.initialY && particle.velocity.y < 0) {
          particle.velocity.y = -particle.velocity.y * 0.2; // Less bouncy
          particle.velocity.x *= 0.8;
          particle.velocity.z *= 0.8;
          particle.position.y = particle.initialY + 0.05;
          
          // Reduce opacity on bounce (shatter effect)
          particle.opacity *= 0.5;
        }
        
        // Update rotation
        particle.rotation.x += particle.rotationSpeed.x * delta;
        particle.rotation.y += particle.rotationSpeed.y * delta;
        particle.rotation.z += particle.rotationSpeed.z * delta;
        
        // Fade out over time
        particle.opacity = Math.max(0, particle.opacity - 0.6 * delta);
        
        return particle;
      }).filter(p => p.opacity > 0.1)
    );
  });
  
  // Remove when lifetime is over and all particles are gone
  if (lifetime <= 0 && iceParticles.length === 0) return null;
  
  return (
    <group>
      {/* Ice ring */}
      <mesh 
        ref={ringRef} 
        position={[position.x, position.y + 0.05, position.z]}
        rotation={[Math.PI / 2, 0, 0]}
      >
        <ringGeometry args={[radius * 0.8, radius, 32]} />
        <meshBasicMaterial color={new Color(0xb3e0ff)} transparent={true} opacity={1} />
      </mesh>
      
      {/* Ice particles */}
      {iceParticles.map((particle, index) => (
        <mesh
          key={`ice-${index}-${Math.random().toString(36).substring(2, 9)}`}
          position={[particle.position.x, particle.position.y, particle.position.z]}
          rotation={[particle.rotation.x, particle.rotation.y, particle.rotation.z]}
          scale={[particle.scale, particle.scale * particle.stretching, particle.scale]}
        >
          <boxGeometry args={[0.15, 0.15, 0.15]} /> {/* Use box for crystal-like shards */}
          <meshBasicMaterial 
            color={particle.color} 
            transparent={true} 
            opacity={particle.opacity}
          />
        </mesh>
      ))}
    </group>
  );
}


// ==============================================================================
// FILE: app/game/vfx/WaterProjectile.tsx
// ==============================================================================

import { useRef, useState } from 'react';
import { useFrame } from '@react-three/fiber';
import { Vector3, Mesh, Color, MathUtils, Group } from 'three';

interface WaterProjectileProps {
  id: string;
  origin: {x: number; y: number; z: number};
  dir: {x: number; y: number; z: number};
  speed: number;
}

interface DropletParticle {
  position: Vector3;
  scale: number;
  opacity: number;
  velocity: Vector3;
  lifetimeMs: number;
  rotation: Vector3;
  rotationSpeed: Vector3;
}

// Use named export instead of default
export function WaterProjectile({ id = `water-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`, origin, dir, speed }: WaterProjectileProps) {
  const mainRef = useRef<Mesh>(null);
  const groupRef = useRef<Group>(null);
  const pos = useRef(new Vector3(origin.x, origin.y, origin.z));
  const [particles, setParticles] = useState<DropletParticle[]>([]);
  const timeOffset = useRef(Math.random() * Math.PI * 2);
  
  useFrame((state, delta) => {
    if (!mainRef.current) return;
    
    // Move projectile
    pos.current.x += dir.x * speed * delta;
    pos.current.y += dir.y * speed * delta;
    pos.current.z += dir.z * speed * delta;
    mainRef.current.position.copy(pos.current);
    
    // Water-like wobble effect
    const wobbleFactor = Math.sin(state.clock.elapsedTime * 12 + timeOffset.current) * 0.2 + 0.8;
    mainRef.current.scale.set(wobbleFactor, 1, wobbleFactor);
    
    // Random movement for more natural water motion
    if (groupRef.current) {
      groupRef.current.position.y += Math.sin(state.clock.elapsedTime * 10) * 0.01;
      groupRef.current.rotation.z = Math.sin(state.clock.elapsedTime * 4) * 0.05;
    }
    
    // Add water droplets
    if (Math.random() > 0.7) {
      const angle = Math.random() * Math.PI * 2;
      const distance = Math.random() * 0.3;
      
      const newParticle: DropletParticle = {
        position: pos.current.clone().add(
          new Vector3(
            Math.cos(angle) * distance,
            Math.sin(angle) * distance + 0.1,
            Math.sin(angle) * distance
          )
        ),
        scale: 0.05 + Math.random() * 0.1,
        opacity: 0.7 + Math.random() * 0.3,
        velocity: new Vector3(
          (Math.random() - 0.5) * 1.5,
          Math.random() * 1.5,
          (Math.random() - 0.5) * 1.5
        ),
        lifetimeMs: 300 + Math.random() * 200,
        rotation: new Vector3(),
        rotationSpeed: new Vector3(
          (Math.random() - 0.5) * 3,
          (Math.random() - 0.5) * 3,
          (Math.random() - 0.5) * 3
        )
      };
      
      setParticles(prev => [...prev, newParticle]);
    }
    
    // Update water particles
    setParticles(prev => 
      prev.map(particle => {
        // Apply gravity and update position
        particle.velocity.y -= 5 * delta;
        particle.position.x += particle.velocity.x * delta;
        particle.position.y += particle.velocity.y * delta;
        particle.position.z += particle.velocity.z * delta;
        
        // Update rotation
        particle.rotation.x += particle.rotationSpeed.x * delta;
        particle.rotation.y += particle.rotationSpeed.y * delta;
        particle.rotation.z += particle.rotationSpeed.z * delta;
        
        return {
          ...particle,
          lifetimeMs: particle.lifetimeMs - delta * 1000,
          opacity: Math.max(0, particle.lifetimeMs / 300) // fade out
        };
      }).filter(p => p.lifetimeMs > 0 && p.opacity > 0.1)
    );
  });
  
  return (
    <group ref={groupRef}>
      {/* Main water projectile */}
      <mesh ref={mainRef}>
        <sphereGeometry key={`water-geo-${id}`} args={[0.3, 16, 16]} />
        <meshStandardMaterial 
          key={`water-mat-${id}`}
          color={new Color(0x42a5f5)} // Light blue
          transparent={true}
          opacity={0.7}
          roughness={0.2}
          metalness={0.8}
        />
      </mesh>
      
      {/* Water particles */}
      {particles.map((particle, index) => (
        <mesh
          key={`droplet-${id}-${index}`}
          position={[particle.position.x, particle.position.y, particle.position.z]}
          rotation={[particle.rotation.x, particle.rotation.y, particle.rotation.z]}
          scale={[particle.scale, particle.scale, particle.scale]}
        >
          <sphereGeometry key={`droplet-geo-${id}-${index}`} args={[0.1, 8, 8]} />
          <meshBasicMaterial 
            key={`droplet-mat-${id}-${index}`}
            color={new Color(0x81d4fa)} // Lighter blue for droplets
            transparent={true}
            opacity={particle.opacity}
          />
        </mesh>
      ))}
    </group>
  );
}

// Add default export as well for compatibility
export default WaterProjectile;


// ==============================================================================
// FILE: app/layout.tsx
// ==============================================================================

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Vibeage",
  description: " 3D MMORPG Adventure",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" className="dark">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased bg-black text-white`}
      >
        {children}
      </body>
    </html>
  );
}


// ==============================================================================
// FILE: app/page.tsx
// ==============================================================================

import Game from './game/components/Game'

export default function Home() {
  return (
    <main className="w-full h-screen">
      <Game />
    </main>
  );
}


// ==============================================================================
// FILE: generate-project-doc.ts
// ==============================================================================

import * as fs from 'fs';
import * as path from 'path';

// Configuration
const rootDir = process.cwd();
const outputFile = path.join(rootDir, 'all_project_in_a_single_file_for_llm.txt');
const excludeDirs = [
  'node_modules',
  '.git',
  '.next',
  'dist',
  'build',
];

const includeExtensions = [
  '.ts',
  '.tsx',
];

// Skip test files unless they provide valuable documentation
const excludePatterns = [
  /\.test\./,
  /\.spec\./,
  /\.bench\./,
  /next-env\.d\.ts/,
  /tsconfig\.tsbuildinfo/,
  /package-lock\.json/,
  /pnpm-lock\.yaml/,
];

const isExcludedPath = (filePath: string): boolean => {
  const relativePath = path.relative(rootDir, filePath);
  return excludeDirs.some(dir => 
    relativePath.startsWith(dir + path.sep) || relativePath === dir
  );
};

const isExcludedFile = (filePath: string): boolean => {
  const fileName = path.basename(filePath);
  return excludePatterns.some(pattern => pattern.test(fileName));
};

const shouldIncludeFile = (filePath: string): boolean => {
  if (isExcludedPath(filePath) || isExcludedFile(filePath)) {
    return false;
  }
  
  const ext = path.extname(filePath).toLowerCase();
  return includeExtensions.includes(ext);
};

// Function to walk through directories and find all files
function walkDir(dir: string, fileList: string[] = []): string[] {
  const files = fs.readdirSync(dir);
  
  for (const file of files) {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    
    if (stat.isDirectory()) {
      if (!isExcludedPath(filePath)) {
        walkDir(filePath, fileList);
      }
    } else if (shouldIncludeFile(filePath)) {
      fileList.push(filePath);
    }
  }
  
  return fileList;
}

// Generate file content
async function generateProjectDoc() {
  console.log('Generating project documentation...');
  
  const allFiles = walkDir(rootDir);
  
  // Sort files by path for better organization
  allFiles.sort();
  
  let output = `// Project Documentation
// Generated on: ${new Date().toISOString()}
// This file contains the source code of all meaningful files in the project.

`;

  for (const filePath of allFiles) {
    // Skip the output file itself
    if (filePath === outputFile) continue;
    
    try {
      const fileContent = fs.readFileSync(filePath, 'utf8');
      const relativePath = path.relative(rootDir, filePath);
      
      output += `\n\n// ${'='.repeat(78)}\n`;
      output += `// FILE: ${relativePath}\n`;
      output += `// ${'='.repeat(78)}\n\n`;
      output += fileContent;
    } catch (error) {
      console.error(`Error reading file ${filePath}:`, error);
    }
  }
  
  fs.writeFileSync(outputFile, output);
  console.log(`Project documentation created at: ${outputFile}`);
  console.log(`Total files included: ${allFiles.length}`);
}

// Run the script
generateProjectDoc().catch(console.error);


// ==============================================================================
// FILE: next.config.ts
// ==============================================================================

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  webpack: (config) => {
    config.externals = [...(config.externals || []), { bufferutil: 'bufferutil', 'utf-8-validate': 'utf-8-validate' }];
    return config;
  },
  // Add rewrites for Socket.IO
  rewrites: async () => {
    return [
      {
        source: '/socket.io/:path*',
        destination: 'http://localhost:3001/socket.io/:path*',
      },
    ];
  },
};

export default nextConfig;


// ==============================================================================
// FILE: script.ts
// ==============================================================================

// Script to run the server in development mode
import * as path from 'path';
import * as fs from 'fs';
import { spawn } from 'child_process';

// Get the project root directory
const rootDir = process.cwd();

// Check if TypeScript is available
const tsconfigPath = path.join(rootDir, 'tsconfig.server.json');
const hasTsConfig = fs.existsSync(tsconfigPath);

// Use ts-node for TypeScript execution in development
const nodemon = require('nodemon');

nodemon({
  script: path.join(rootDir, 'server', 'server.ts'),
  ext: 'ts,tsx,js,jsx,json',
  watch: [
    path.join(rootDir, 'server'),
    path.join(rootDir, 'shared')
  ],
  exec: hasTsConfig ? 'ts-node --project tsconfig.server.json' : 'ts-node',
  env: {
    NODE_ENV: 'development',
    PORT: process.env.PORT || '3001'
  }
});

nodemon.on('start', () => {
  console.log('Server started');
});

nodemon.on('restart', (files) => {
  console.log('Server restarted due to changes in:', files);
});

nodemon.on('crash', () => {
  console.error('Server crashed, waiting for changes before restart');
});


// ==============================================================================
// FILE: server/collision.ts
// ==============================================================================

import { VecXZ } from '../shared/types.js';
import { log, LOG_CATEGORIES } from './logger';

// Constants for the game world
const WORLD_BOUNDS = {
    minX: -500,
    maxX: 500,
    minZ: -500,
    maxZ: 500
};

// Define obstacles - can be expanded with more complex shapes
const OBSTACLES: Array<{
    type: 'circle' | 'rectangle';
    center?: VecXZ;
    position?: VecXZ;
    radius?: number;
    width?: number;
    height?: number;
}> = [
    // Central lake - moved away from spawn
    //{
    //    type: 'circle',
    //    center: { x: 100, z: 100 }, // was { x: 0, z: 0 }
    //    radius: 50
    //},
    //// Mountain area - north rectangle
    //{
    //    type: 'rectangle',
    //    position: { x: -100, z: 300 },
    //    width: 200,
    //    height: 100
    //},
    // Ruins - west rectangle
    {
        type: 'rectangle',
        position: { x: -300, z: -50 },
        width: 100,
        height: 100
    }
];

/**
 * Check if a line segment intersects with a circle
 * @param start Start point of line segment
 * @param end End point of line segment
 * @param center Circle center
 * @param radius Circle radius
 * @returns True if line segment intersects with circle
 */
function lineIntersectsCircle(start: VecXZ, end: VecXZ, center: VecXZ, radius: number): boolean {
    // Vector from start to end
    const dx = end.x - start.x;
    const dz = end.z - start.z;
    
    // Vector from start to circle center
    const sx = center.x - start.x;
    const sz = center.z - start.z;
    
    // Length of line segment squared
    const lengthSquared = dx * dx + dz * dz;
    
    // Dot product of the two vectors
    const dotProduct = sx * dx + sz * dz;
    
    // Projection of center onto line segment
    const projection = dotProduct / lengthSquared;
    
    // Closest point on line segment to circle center
    let closestX, closestZ;
    
    if (projection < 0) {
        // Closest point is start
        closestX = start.x;
        closestZ = start.z;
    } else if (projection > 1) {
        // Closest point is end
        closestX = end.x;
        closestZ = end.z;
    } else {
        // Closest point is on the line segment
        closestX = start.x + projection * dx;
        closestZ = start.z + projection * dz;
    }
    
    // Distance from closest point to circle center
    const distance = Math.sqrt(
        Math.pow(closestX - center.x, 2) + 
        Math.pow(closestZ - center.z, 2)
    );
    
    // Check if distance is less than radius (intersection)
    return distance <= radius;
}

/**
 * Check if a line segment intersects with a rectangle
 * @param start Start point of line segment
 * @param end End point of line segment
 * @param rectPos Rectangle position (top-left corner)
 * @param width Rectangle width
 * @param height Rectangle height
 * @returns True if line segment intersects with rectangle
 */
function lineIntersectsRectangle(
    start: VecXZ, 
    end: VecXZ, 
    rectPos: VecXZ, 
    width: number, 
    height: number
): boolean {
    // Rectangle corners
    const topLeft = rectPos;
    const topRight = { x: rectPos.x + width, z: rectPos.z };
    const bottomLeft = { x: rectPos.x, z: rectPos.z + height };
    const bottomRight = { x: rectPos.x + width, z: rectPos.z + height };
    
    // Check if line intersects any of the rectangle edges
    return (
        lineIntersectsLine(start, end, topLeft, topRight) ||
        lineIntersectsLine(start, end, topRight, bottomRight) ||
        lineIntersectsLine(start, end, bottomRight, bottomLeft) ||
        lineIntersectsLine(start, end, bottomLeft, topLeft)
    );
}

/**
 * Check if two line segments intersect
 * @param a1 First point of first line
 * @param a2 Second point of first line
 * @param b1 First point of second line
 * @param b2 Second point of second line
 * @returns True if lines intersect
 */
function lineIntersectsLine(a1: VecXZ, a2: VecXZ, b1: VecXZ, b2: VecXZ): boolean {
    // Direction vectors
    const dxa = a2.x - a1.x;
    const dza = a2.z - a1.z;
    const dxb = b2.x - b1.x;
    const dzb = b2.z - b1.z;
    
    // Cross product of direction vectors
    const crossProduct = dxa * dzb - dza * dxb;
    
    // If cross product is zero, lines are parallel
    if (Math.abs(crossProduct) < 1e-10) return false;
    
    // Vector from a1 to b1
    const dx = b1.x - a1.x;
    const dz = b1.z - a1.z;
    
    // Parameters for line equations
    const t = (dx * dzb - dz * dxb) / crossProduct;
    const u = (dx * dza - dz * dxa) / crossProduct;
    
    // Check if intersection point is on both line segments
    return t >= 0 && t <= 1 && u >= 0 && u <= 1;
}

/**
 * Check if a movement path from start to destination is blocked by any obstacle
 * @param start Starting position
 * @param dest Destination position
 * @returns true if the path is blocked
 */
export function isPathBlocked(start: VecXZ, dest: VecXZ): boolean {
    // Check world boundaries
    if (dest.x < WORLD_BOUNDS.minX || dest.x > WORLD_BOUNDS.maxX ||
        dest.z < WORLD_BOUNDS.minZ || dest.z > WORLD_BOUNDS.maxZ) {
        console.log('[COLLISION] Blocked by world bounds', { start, dest, bounds: WORLD_BOUNDS });
        return true;
    }
    // Check obstacle collisions
    for (const obstacle of OBSTACLES) {
        if (obstacle.type === 'circle' && obstacle.center && obstacle.radius) {
            if (lineIntersectsCircle(start, dest, obstacle.center, obstacle.radius)) {
                console.log('[COLLISION] Blocked by circle', { start, dest, center: obstacle.center, radius: obstacle.radius });
                return true;
            }
        } else if (obstacle.type === 'rectangle' && obstacle.position && obstacle.width && obstacle.height) {
            if (lineIntersectsRectangle(start, dest, obstacle.position, obstacle.width, obstacle.height)) {
                console.log('[COLLISION] Blocked by rectangle', { start, dest, position: obstacle.position, width: obstacle.width, height: obstacle.height });
                return true;
            }
        }
    }
    console.log('[COLLISION] Path clear', { start, dest });
    return false;
}

/**
 * Find a valid destination point as close as possible to the requested one
 * @param start Starting position
 * @param dest Requested destination
 * @returns Valid destination point
 */
export function findValidDestination(start: VecXZ, dest: VecXZ): VecXZ {
    // If path is not blocked, return original destination
    if (!isPathBlocked(start, dest)) return dest;
    
    // Simple approach: try points along the line from start to dest
    const dx = dest.x - start.x;
    const dz = dest.z - start.z;
    const distance = Math.sqrt(dx * dx + dz * dz);
    
    // Try increments of 5% back from the destination
    for (let percent = 0.95; percent >= 0.05; percent -= 0.05) {
        const testPoint = {
            x: start.x + dx * percent,
            z: start.z + dz * percent
        };
        
        if (!isPathBlocked(start, testPoint)) {
            console.log('[COLLISION] Clamped destination', { from: dest, to: testPoint });
            return testPoint;
        }
    }
    console.log('[COLLISION] No valid destination found, returning start', { start, dest });
    return { ...start };
}

/**
 * Check if a moving point with initial position a0 and final position a1
 * collides with a stationary circle at bPos with radius bRadius
 * Implements swept AABB collision detection for projectiles
 * @param a0 Initial position of the moving point
 * @param a1 Final position of the moving point
 * @param bPos Position of the stationary circle
 * @param bRadius Radius of the stationary circle (default 0.4)
 * @returns true if collision occurs
 */
export function sweptHit(
  a0: VecXZ, 
  a1: VecXZ,
  bPos: VecXZ, 
  hitRadiusMultiplier = 1.0
): boolean {
  // Apply the hit radius multiplier to get the final hit radius
  const hitRadius = 1.2 * hitRadiusMultiplier; // Base hit radius * multiplier
  
  // Log hit check details for debugging
  log(LOG_CATEGORIES.COLLISION, `Projectile from (${a0.x.toFixed(2)}, ${a0.z.toFixed(2)}) to (${a1.x.toFixed(2)}, ${a1.z.toFixed(2)}), target at (${bPos.x.toFixed(2)}, ${bPos.z.toFixed(2)}) with hit radius ${hitRadius}`);
  
  // SIMPLE APPROACH FIRST: Direct distance check at any point
  // Check distance at initial position
  const initialDist = Math.sqrt(Math.pow(a0.x - bPos.x, 2) + Math.pow(a0.z - bPos.z, 2));
  if (initialDist <= hitRadius) {
    log(LOG_CATEGORIES.COLLISION, `Direct hit at initial position! Distance: ${initialDist.toFixed(2)} <= ${hitRadius}`);
    return true;
  }
  
  // Check distance at final position
  const finalDist = Math.sqrt(Math.pow(a1.x - bPos.x, 2) + Math.pow(a1.z - bPos.z, 2));
  if (finalDist <= hitRadius) {
    log(LOG_CATEGORIES.COLLISION, `Direct hit at final position! Distance: ${finalDist.toFixed(2)} <= ${hitRadius}`);
    return true;
  }
  
  // SWEPT APPROACH: Check if projectile passes through the target
  // Get direction and length of movement
  const dx = a1.x - a0.x;
  const dz = a1.z - a0.z;
  const lengthSq = dx * dx + dz * dz;
  
  // Skip if no movement
  if (lengthSq < 0.0001) return false;
  
  // Get vector from start position to target center
  const cx = bPos.x - a0.x;
  const cz = bPos.z - a0.z;
  
  // Project target onto movement line to find closest point
  const t = Math.max(0, Math.min(1, (cx * dx + cz * dz) / lengthSq));
  
  // Find the closest point on the movement line segment
  const closestX = a0.x + t * dx;
  const closestZ = a0.z + t * dz;
  
  // Get distance from closest point to target
  const closestDist = Math.sqrt(Math.pow(closestX - bPos.x, 2) + Math.pow(closestZ - bPos.z, 2));
  
  log(LOG_CATEGORIES.COLLISION, `Closest approach at t=${t.toFixed(2)}, distance: ${closestDist.toFixed(2)}, hit radius: ${hitRadius}`);
  
  // Check if this closest distance is less than the hit radius
  const hit = closestDist <= hitRadius;
  
  // Additional debug logging
  if (hit) {
    log(LOG_CATEGORIES.COLLISION, `HIT! Projectile passes within ${closestDist.toFixed(2)} units of target (hit radius: ${hitRadius})`);
  } else {
    log(LOG_CATEGORIES.COLLISION, `MISS. Closest approach: ${closestDist.toFixed(2)} > ${hitRadius}`);
  }
  
  return hit;
}


// ==============================================================================
// FILE: server/combat/effects/EffectApplicator.ts
// ==============================================================================

/**
 * This file contains helper functions to process the ticks generated by the EffectRunner
 * and apply them to entities in the game world.
 */
import { EffectTick } from '../../../shared/effectsDefinition.js';
import { log, LOG_CATEGORIES } from '../../logger.js';

// Application functions for different effect types
const effectHandlers = {
  damage: (value: number, target: any) => {
    if (!target || target.health === undefined) return false;
    
    const oldHealth = target.health;
    target.health = Math.max(0, target.health - value);
    
    log(LOG_CATEGORIES.DAMAGE, `Entity ${target.id} took ${value} damage from status effect. Health: ${oldHealth} -> ${target.health}`);
    
    // Check if target died
    if (target.health <= 0 && target.isAlive) {
      target.health = 0;
      target.isAlive = false;
      target.deathTimeTs = Date.now();
      if (target.targetId) target.targetId = null;
      
      log(LOG_CATEGORIES.DAMAGE, `Entity ${target.id} was killed by status effect`);
      return true; // Entity died
    }
    
    return false; // Entity didn't die
  },
  
  healing: (value: number, target: any) => {
    if (!target || target.health === undefined || target.maxHealth === undefined) return false;
    
    // Only apply healing if the target is alive
    if (!target.isAlive) return false;
    
    const oldHealth = target.health;
    target.health = Math.min(target.maxHealth, target.health + value);
    
    log(LOG_CATEGORIES.HEALING, `Entity ${target.id} healed for ${value} from status effect. Health: ${oldHealth} -> ${target.health}`);
    
    return false; // No entity died from healing
  },
  
  mana: (value: number, target: any) => {
    if (!target || target.mana === undefined || target.maxMana === undefined) return false;
    
    const oldMana = target.mana;
    target.mana = Math.min(target.maxMana, Math.max(0, target.mana + value));
    
    log(LOG_CATEGORIES.MANA, `Entity ${target.id} mana change by ${value} from status effect. Mana: ${oldMana} -> ${target.mana}`);
    
    return false; // No entity died from mana change
  },
  
  stat: (value: number, target: any) => {
    // Stat modifications would go here
    // For now, we don't implement actual stat modifications
    return false;
  }
};

/**
 * Apply an effect tick to an entity
 * @param tick The effect tick to apply
 * @param target The target entity
 * @returns Whether the entity died from this tick
 */
export function applyEffectTick(tick: EffectTick, target: any): boolean {
  const handler = effectHandlers[tick.type];
  if (!handler) {
    console.error(`No handler found for effect type: ${tick.type}`);
    return false;
  }
  
  return handler(tick.value, target);
}


// ==============================================================================
// FILE: server/combat/effects/EffectRunner.ts
// ==============================================================================

import { nanoid } from 'nanoid';
import { EffectDef, EffectId, EFFECTS } from '../../../shared/effectsDefinition.js';
import { EffectSnapshotMsg } from '../../../shared/messages.js';
import { effectRng } from '../../../shared/combatMath.js';
import { applyEffectTick } from './EffectApplicator.js';

type EntityId = string;

interface Entity {
  id: string;
  level?: number;
  int?: number;  // Intelligence stat for effect damage/healing calculations
}

interface Active {
  id: string;        // Unique identifier for this effect instance
  srcId: EntityId;   // Source of the effect
  effectId: EffectId; // Type of effect
  def: EffectDef;    // Effect definition
  remaining: number; // Remaining duration in ms
  lastTick: number;  // When this effect last ticked
  stacks: number;    // Current stack count
  seed: number;      // RNG seed for deterministic calculations
  level: number;     // Level of the effect (from source entity)
  int: number;       // Int stat (from source entity)
}

class EffectRunner {
  private active = new Map<EntityId, Active[]>();

  /**
   * Add a new effect to an entity or refresh an existing one
   */
  add(target: Entity, src: Entity, effectId: EffectId, seed: number) {
    if (!EFFECTS[effectId]) {
      console.error(`Unknown effect type: ${effectId}`);
      return;
    }

    const targetId = target.id;
    const def = EFFECTS[effectId];
    const now = Date.now();
    
    // Get or create effects array for this target
    if (!this.active.has(targetId)) {
      this.active.set(targetId, []);
    }
    
    const effects = this.active.get(targetId)!;
    
    // Check if this effect type already exists on target
    const existingIdx = effects.findIndex(e => e.effectId === effectId && e.srcId === src.id);
    
    if (existingIdx >= 0) {
      // Update existing effect
      const existing = effects[existingIdx];
      existing.remaining = Math.max(existing.remaining, def.durationMs); // Reset duration
      existing.stacks = Math.min(existing.stacks + 1, def.maxStacks);    // Increment stacks
      existing.seed = seed; // Update seed for deterministic calculations
      return existing;
    } else {
      // Add new effect
      const newEffect: Active = {
        id: nanoid(),
        srcId: src.id,
        effectId,
        def,
        remaining: def.durationMs,
        lastTick: now,
        stacks: 1,
        seed,
        level: src.level || 1,
        int: src.int || 0
      };
      effects.push(newEffect);
      return newEffect;
    }
  }

  private gameState: any = {};
  
  /**
   * Set the game state reference for effect application
   */
  setGameState(state: any) {
    this.gameState = state;
  }

  /**
   * Process all active effects, trigger ticks, and return effect messages
   */
  tick(dt: number, emit: (m: EffectSnapshotMsg) => void) {
    const now = Date.now();
    const expiredEntities: EntityId[] = [];
    
    // Iterate through all targets and their effects
    for (const [targetId, effects] of this.active.entries()) {
      const expiredEffects: number[] = [];
      
      // Find the actual target entity
      const targetEntity = 
        (this.gameState.players && this.gameState.players[targetId]) || 
        (this.gameState.enemies && this.gameState.enemies[targetId]);
      
      if (!targetEntity) {
        // If target no longer exists, remove all effects
        expiredEntities.push(targetId);
        continue;
      }
      
      // Update each effect
      for (let i = 0; i < effects.length; i++) {
        const effect = effects[i];
        
        // Decrease remaining time
        effect.remaining -= dt;
        
        // Check if effect should be removed
        if (effect.remaining <= 0) {
          expiredEffects.push(i);
          continue;
        }
        
        // Check if effect should tick
        const timeSinceLastTick = now - effect.lastTick;
        if (timeSinceLastTick >= effect.def.tickMs) {
          // Apply effect tick
          const tickCount = Math.floor(timeSinceLastTick / effect.def.tickMs);
          effect.lastTick = now - (timeSinceLastTick % effect.def.tickMs);
          
          // For each missed tick, apply the effect
          for (let tick = 0; tick < tickCount; tick++) {
            const tickSeed = effect.seed + tick;
            const result = effect.def.apply({
              level: effect.level,
              int: effect.int,
              seed: tickSeed
            });
            
            // Apply effect result value to target entity
            if (targetEntity) {
              const didKill = applyEffectTick(result, targetEntity);
              
              // If the target died, stop processing ticks for this entity
              if (didKill) {
                break;
              }
            }
          }
          
          // Send effect snapshot after each tick
          emit({
            type: 'EffectSnapshot',
            id: targetId,
            src: effect.srcId,
            effectId: effect.effectId,
            stacks: effect.stacks,
            remainingMs: effect.remaining,
            seed: effect.seed
          });
        }
      }
      
      // Remove expired effects in reverse order
      for (let i = expiredEffects.length - 1; i >= 0; i--) {
        const expiredIdx = expiredEffects[i];
        effects.splice(expiredIdx, 1);
      }
      
      // If no effects remain for this entity, mark for cleanup
      if (effects.length === 0) {
        expiredEntities.push(targetId);
      }
    }
    
    // Remove expired entities
    for (const entityId of expiredEntities) {
      this.active.delete(entityId);
    }
  }
  
  /**
   * Get all active effects for a specific entity
   */
  getEffectsForEntity(entityId: EntityId): Active[] {
    return this.active.get(entityId) || [];
  }
  
  /**
   * Remove all effects from a specific entity
   */
  clearEffects(entityId: EntityId) {
    this.active.delete(entityId);
  }
}

export const effectRunner = new EffectRunner();


// ==============================================================================
// FILE: server/combat/skillManager.ts
// ==============================================================================

import { Socket, Server } from 'socket.io';
import { SKILLS, SkillId } from '../../shared/skillsDefinition.js';
import { CastReq, CastFail, CastSnapshotMsg, ProjSpawn2, ProjHit2 } from '../../shared/messages.js';
import { getManaCost, getCooldownMs, getDamage } from '../../shared/combatMath.js';
import { VecXZ } from '../../shared/messages.js';
import { predictPosition, distance } from '../../shared/positionUtils.js';
import { CastState as CastStateEnum, CastSnapshot } from '../../shared/types.js';
import { nanoid } from 'nanoid';
import { effectRunner } from './effects/EffectRunner.js';

// Import getDamage from shared/combatMath.js
import { getDamage as getSkillDamage } from '../../shared/combatMath.js';

/**
 * Get world interface for interacting with game state
 */
interface World {
  getEnemyById: (id: string) => any | null;
  getPlayerById: (id: string) => Player | null;
  getEntitiesInCircle: (pos: VecXZ, radius: number) => any[];
}

/**
 * Calculate damage for a skill based on the skill and caster stats, using the shared implementation
 * @param skill The skill object with dmg property
 * @param caster Optional caster with stats
 * @param castId The unique ID of the cast
 * @param targetId The ID of the target
 * @returns The calculated damage amount
 */
function calculateDamage(skill: any, caster?: any, castId?: string, targetId?: string): number {
  if (!skill || !skill.dmg) return 10; // Default damage
  
  const result = getDamage({
    caster: caster?.stats || { dmgMult: 1, critChance: 0, critMult: 2 },
    skill: { base: skill.dmg, variance: 0.1 },
    seed: `${castId || nanoid()}:${targetId || nanoid()}`
  });
  
  return result.dmg;
}

// Define the type for active casts (legacy)
interface CastState {
  id: string;
  skillId: SkillId;
  startTime: number;
  castTimeMs: number;
  targetId?: string;
  targetPos?: VecXZ;
  clientSeq: number; // To reconcile with client
  state: 'casting' | 'completed' | 'canceled';
}

// New types for the enhanced Cast and Projectile system
interface Cast {
  castId: string;
  casterId: string;
  skillId: SkillId;
  state: CastStateEnum;
  origin: VecXZ;
  target?: VecXZ;
  startedAt: number;
  castTimeMs: number;
  targetId?: string;
  targetPos?: VecXZ;
}

interface Projectile {
  castId: string;
  pos: VecXZ;
  dir: VecXZ;
  speed: number;
  distanceTraveled: number;
  maxRange: number;
  startTime: number;
  skillId: SkillId;
}

// Player interface that contains needed properties for skill casting
interface Player {
  id: string;
  socketId: string;
  health: number;
  maxHealth: number;
  mana: number;
  maxMana: number;
  cooldowns: Record<string, number>;
  skillCooldownEndTs: Record<string, number>;
  isAlive: boolean;
  level: number;
  position: { x: number; y: number; z: number };
  movement?: any;
  stats?: any;
  // Other player properties
}

// Collection of active casts by all players (legacy)
const activeCasts: CastState[] = [];
// Collection of completed casts to be processed
let completedCasts: CastState[] = [];

// New collections for the enhanced system
const activeCastsNew: Cast[] = [];
const projectiles: Projectile[] = [];

/**
 * Handle a cast request from a client
 * Validates mana and cooldown, creates cast state or rejects with fail message
 */
export function handleCastReq(
  player: Player,
  req: CastReq,
  socket: Socket,
  getEnemyById: (id: string) => any | null
): void {
  const now = Date.now();
  const skillId = req.skillId as SkillId;
  const skill = SKILLS[skillId];
  
  // Make sure the skill exists
  if (!skill) {
    socket.emit('msg', {
      type: 'CastFail',
      clientSeq: req.clientTs, // Use clientTs as clientSeq for reconciliation
      reason: 'invalid'
    } as CastFail);
    return;
  }
  
  // Check if player is alive
  if (!player.isAlive) {
    socket.emit('msg', {
      type: 'CastFail',
      clientSeq: req.clientTs,
      reason: 'invalid'
    } as CastFail);
    return;
  }
  
  // Check cooldown
  if ((player.cooldowns?.[skillId] && now < player.cooldowns[skillId]) || 
      (player.skillCooldownEndTs?.[skillId] && now < player.skillCooldownEndTs[skillId])) {
    socket.emit('msg', {
      type: 'CastFail',
      clientSeq: req.clientTs,
      reason: 'cooldown'
    } as CastFail);
    return;
  }
  
  // Check mana cost
  const manaCost = getManaCost(skillId, player.level);
  if (player.mana < manaCost) {
    socket.emit('msg', {
      type: 'CastFail',
      clientSeq: req.clientTs,
      reason: 'nomana'
    } as CastFail);
    return;
  }
  
  // Check range if this is a targeted ability
  if (skill.range && req.targetId) {
    const target = getEnemyById(req.targetId);
    if (!target) {
      socket.emit('msg', {
        type: 'CastFail',
        clientSeq: req.clientTs,
        reason: 'invalid'
      } as CastFail);
      return;
    }
    
    // Check if target is alive
    if (!target.isAlive) {
      socket.emit('msg', {
        type: 'CastFail',
        clientSeq: req.clientTs,
        reason: 'invalid'
      } as CastFail);
      return;
    }
    
    // Check range
    const playerPos = predictPosition(player, now);
    const targetPos = { x: target.position.x, z: target.position.z };
    
    if (distance(playerPos, targetPos) > skill.range) {
      socket.emit('msg', {
        type: 'CastFail',
        clientSeq: req.clientTs,
        reason: 'invalid'
      } as CastFail);
      return;
    }
  } else if (skill.range && req.targetPos) {
    // Position-targeted ability
    const playerPos = predictPosition(player, now);
    
    if (distance(playerPos, req.targetPos) > skill.range) {
      socket.emit('msg', {
        type: 'CastFail',
        clientSeq: req.clientTs,
        reason: 'invalid'
      } as CastFail);
      return;
    }
  }
  
  // Deduct mana
  player.mana -= manaCost;
  
  // Set cooldown
  const cooldownMs = getCooldownMs(skillId, player.level);
  player.cooldowns[skillId] = now + cooldownMs;
  player.skillCooldownEndTs[skillId] = now + cooldownMs;
  
  // Create a cast state entry
  const cast: CastState = {
    id: player.id,
    skillId,
    startTime: now,
    castTimeMs: skill.castMs, // Use castMs from skill definition
    targetId: req.targetId,
    targetPos: req.targetPos,
    clientSeq: req.clientTs,
    state: 'casting'
  };
  
  // Add to active casts
  activeCasts.push(cast);
  
  // Legacy CastStart removed - using only CastSnapshot
  
  // Create a new Cast object for the enhanced system
  const newCast: Cast = {
    castId: nanoid(),
    casterId: player.id,
    skillId,
    state: CastStateEnum.Casting,
    origin: { x: player.position.x, z: player.position.z },
    startedAt: now,
    castTimeMs: skill.castMs,
    targetId: req.targetId,
    targetPos: req.targetPos
  };
  
  // Add to active casts
  activeCastsNew.push(newCast);
  
  // Broadcast initial cast snapshot
  const castSnapshot: CastSnapshot = {
    castId: newCast.castId,
    casterId: newCast.casterId,
    skillId: newCast.skillId,
    state: newCast.state,
    origin: newCast.origin,
    target: newCast.targetPos,
    startedAt: newCast.startedAt
  };
  
  socket.emit('msg', {
    type: 'CastSnapshot',
    data: castSnapshot
  } as CastSnapshotMsg);
  socket.broadcast.emit('msg', {
    type: 'CastSnapshot',
    data: castSnapshot
  } as CastSnapshotMsg);
}

/**
 * Update casting progress for all active casts
 * Should be called from game loop on regular intervals
 */
export function updateCasts(io?: Server, players?: Record<string, any>): void {
  const now = Date.now();
  const localCompletedCasts: CastState[] = [];
  const playerUpdates: Record<string, any> = {};
  
  // Update all active casts
  for (let i = activeCasts.length - 1; i >= 0; i--) {
    const cast = activeCasts[i];
    const elapsedMs = now - cast.startTime;
    
    // Update casting progress for this player
    if (players && players[cast.id]) {
      players[cast.id].castingProgressMs = elapsedMs;
    }
    
    if (!playerUpdates[cast.id]) {
      playerUpdates[cast.id] = { id: cast.id, castingProgressMs: elapsedMs };
    }
    
    // Check if cast is complete
    if (elapsedMs >= cast.castTimeMs) {
      // Mark as completed
      cast.state = 'completed';
      localCompletedCasts.push({...cast});
      
      // Add to the global completed casts array
      completedCasts.push({...cast});
      
      // Remove from active casts
      activeCasts.splice(i, 1);
      
      // Reset player's casting state
      if (players && players[cast.id]) {
        players[cast.id].castingSkill = null;
        players[cast.id].castingProgressMs = 0;
      }
      
      // Update completion status
      if (playerUpdates[cast.id]) {
        playerUpdates[cast.id].castingProgressMs = 0; // Reset to 0
        playerUpdates[cast.id].castingSkill = null;   // Reset casting skill
      }
      
      // Legacy CastEnd message removed
      
    }
  }
  
  // Send progress updates to clients if we have the io server
  if (io && Object.keys(playerUpdates).length > 0) {
    // Send progress updates to all clients
    for (const playerId in playerUpdates) {
      io.emit('playerUpdated', playerUpdates[playerId]);
    }
  }
}

/**
 * Process the effects of a completed cast
 */
function processCompletedCast(cast: CastState): void {
  // Handle any side effects of the completed cast
  // e.g., apply an effect, trigger an event, etc.

  // Set cast state to completed
  cast.state = 'completed';
}

/**
 * Gets and clears the completed casts queue
 * Other systems should call this to process completed casts
 */
export function getCompletedCasts(): CastState[] {
  const temp = [...completedCasts];
  completedCasts = [];
  return temp;
}

/**
 * Cancel an active cast
 */
export function cancelCast(playerId: string, skillId?: string): boolean {
  const index = activeCasts.findIndex(cast => 
    cast.id === playerId && 
    (skillId ? cast.skillId === skillId : true)
  );
  
  if (index >= 0) {
    const cast = activeCasts[index];
    cast.state = 'canceled';
    activeCasts.splice(index, 1);
    return true;
  }
  
  return false;
}

/**
 * Check if a player is currently casting
 */
export function isPlayerCasting(playerId: string): boolean {
  return activeCasts.some(cast => cast.id === playerId);
}

/**
 * Updates and progresses active casts, transitions them between states
 */
export function tickCasts(dt: number, io: Server, world: World): void {
  const now = Date.now();
  
  for (let i = activeCastsNew.length - 1; i >= 0; i--) {
    const cast = activeCastsNew[i];
    
    // Skip casts that are already in their final state
    if (cast.state === CastStateEnum.Impact) {
      // Remove completed casts after a delay
      if (now - cast.startedAt > 5000) { // 5 seconds after cast started
        activeCastsNew.splice(i, 1);
      }
      continue;
    }
    
    // Check if cast time is complete for casts in Casting state
    if (cast.state === CastStateEnum.Casting) {
      const elapsedMs = now - cast.startedAt;
      
      if (elapsedMs >= cast.castTimeMs) {
        // Cast is complete, transition to Traveling or Impact
        const skill = SKILLS[cast.skillId];
        const isProjectileSkill = skill.projectile !== undefined;
        
        if (isProjectileSkill) {
          // Change state to Traveling
          cast.state = CastStateEnum.Traveling;
          
          // Calculate direction vector
          let dir = { x: 0, z: 0 };
          let tgtPos = cast.targetPos;
          
          if (cast.targetPos) {
            // Targeted at a position
            const dx = cast.targetPos.x - cast.origin.x;
            const dz = cast.targetPos.z - cast.origin.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            
            // Normalize the direction
            if (dist > 0) {
              dir = {
                x: dx / dist,
                z: dz / dist
              };
            }
          } else if (cast.targetId) {
            // Targeted at an entity
            const target = world.getEnemyById(cast.targetId);
            if (target) {
              // Calculate travel time based on distance and speed
              const targetPos = { x: target.position.x, z: target.position.z };
              const srcPos = cast.origin;
              const dist = Math.sqrt(
                Math.pow(targetPos.x - srcPos.x, 2) + 
                Math.pow(targetPos.z - srcPos.z, 2)
              );
              
              const speed = skill.projectile?.speed || 5;
              const travelS = dist / speed;
              
              // Predict the target's position after travel time
              const predicted = predictPosition(target, now + travelS * 1000);
              
              // Update target position to the predicted position
              tgtPos = predicted;
              
              // Calculate direction to predicted position
              const dx = predicted.x - cast.origin.x;
              const dz = predicted.z - cast.origin.z;
              const predictedDist = Math.sqrt(dx * dx + dz * dz);
              
              // Normalize the direction
              if (predictedDist > 0) {
                dir = {
                  x: dx / predictedDist,
                  z: dz / predictedDist
                };
              }
            }
          }
          
          // Calculate travel time in milliseconds
          const speed = skill.projectile?.speed || 5;
          const dist = tgtPos ? 
            Math.sqrt(
              Math.pow(tgtPos.x - cast.origin.x, 2) + 
              Math.pow(tgtPos.z - cast.origin.z, 2)
            ) : skill.range || 10; // Default to skill range if no target
          
          const travelS = dist / speed;
          const travelMs = travelS * 1000;
          
          // Create projectile
          const projectile: Projectile = {
            castId: cast.castId,
            pos: { ...cast.origin },
            dir,
            speed: speed,
            distanceTraveled: 0,
            maxRange: skill.range || 10,
            startTime: now,
            skillId: cast.skillId
          };
          
          projectiles.push(projectile);
          
          // Emit projectile spawn with travelMs
          io.emit('msg', {
            type: 'ProjSpawn2',
            castId: cast.castId,
            origin: cast.origin,
            dir,
            speed: projectile.speed,
            launchTs: now,
            hitRadius: skill.projectile?.hitRadius,
            travelMs: travelMs
          } as ProjSpawn2);
          
          // Broadcast cast state change
          io.emit('msg', {
            type: 'CastSnapshot',
            data: {
              castId: cast.castId,
              casterId: cast.casterId,
              skillId: cast.skillId,
              state: cast.state,
              origin: cast.origin,
              target: cast.targetPos,
              startedAt: cast.startedAt
            }
          } as CastSnapshotMsg);
        } else {
          // Instant cast, goes straight to Impact
          cast.state = CastStateEnum.Impact;
          
          // Broadcast cast state change
          io.emit('msg', {
            type: 'CastSnapshot',
            data: {
              castId: cast.castId,
              casterId: cast.casterId,
              skillId: cast.skillId,
              state: cast.state,
              origin: cast.origin,
              target: cast.targetPos,
              startedAt: cast.startedAt
            }
          } as CastSnapshotMsg);
          
          // TODO: Handle instant cast effects directly here
        }
      }
    }
  }
}

/**
 * Updates projectile positions and handles collisions
 */
export function tickProjectiles(dt: number, io: Server, world: World): void {
  const now = Date.now();
  
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const proj = projectiles[i];
    const skill = SKILLS[proj.skillId];
    
    // Calculate distance traveled in this time step
    const distanceThisFrame = proj.speed * (dt / 1000);
    proj.distanceTraveled += distanceThisFrame;
    
    // Update position
    proj.pos.x += proj.dir.x * distanceThisFrame;
    proj.pos.z += proj.dir.z * distanceThisFrame;
    
    // Check if projectile has reached max range
    let detonate = false;
    if (proj.distanceTraveled >= proj.maxRange) {
      detonate = true;
      
      // Find the matching cast to update state
      const castIndex = activeCastsNew.findIndex(c => c.castId === proj.castId);
      if (castIndex >= 0) {
        const cast = activeCastsNew[castIndex];
        
        // Update cast state to Impact
        cast.state = CastStateEnum.Impact;
        
        // Emit hit message with empty hit list
        io.emit('msg', {
          type: 'ProjHit2',
          castId: proj.castId,
          hitIds: [],
          dmg: [],
          impactPos: { ...proj.pos }  // Include impact position for VFX
        } as ProjHit2);
        
        // Broadcast cast state change
        io.emit('msg', {
          type: 'CastSnapshot',
          data: {
            castId: cast.castId,
            casterId: cast.casterId,
            skillId: cast.skillId,
            state: cast.state,
            origin: cast.origin,
            target: cast.targetPos,
            startedAt: cast.startedAt
          }
        } as CastSnapshotMsg);
      }
    }
    
    // Check for collisions
    if (skill.projectile?.hitRadius) {
      const victims = world.getEntitiesInCircle(proj.pos, skill.projectile.hitRadius);
      
      if (victims.length > 0) {
        detonate = true;
        
        // Find the matching cast
        const castIndex = activeCastsNew.findIndex(c => c.castId === proj.castId);
        if (castIndex >= 0) {
          const cast = activeCastsNew[castIndex];
          const caster = world.getPlayerById(cast.casterId);
          
          // Calculate damage for each victim using the shared getDamage function
          const dmgArr = victims.map((v: any) => calculateDamage(
            skill, 
            caster, 
            cast.castId, 
            v.id
          ));
          
          // Emit hit message with current projectile data
          const currentProj = projectiles[i];
          const hitVictims = victims;

          io.emit('msg', {
            type: 'ProjHit2',
            castId: currentProj.castId,
            hitIds: hitVictims.map((v: any) => v.id),
            dmg: dmgArr,
            impactPos: { ...currentProj.pos }  // Include impact position for VFX
          } as ProjHit2);
          
          // Update cast state to Impact
          cast.state = CastStateEnum.Impact;
          
          // Broadcast cast snapshot
          io.emit('msg', {
            type: 'CastSnapshot',
            data: {
              castId: cast.castId,
              casterId: cast.casterId,
              skillId: cast.skillId,
              state: cast.state,
              origin: cast.origin,
              target: cast.targetPos,
              startedAt: cast.startedAt
            }
          } as CastSnapshotMsg);
        }
      }
    }
    
    // If projectile should detonate (hit max range or collided), remove it
    if (detonate) {
      projectiles.splice(i, 1);
    }
  }
}

/**
 * Send snapshots of all active casts and projectiles to a client
 * Call this when a new client connects to catch them up on the game state
 */
export function sendCastSnapshots(socket: Socket): void {
  // Send all active casts
  activeCastsNew.forEach(cast => {
    socket.emit('msg', {
      type: 'CastSnapshot',
      data: {
        castId: cast.castId,
        casterId: cast.casterId,
        skillId: cast.skillId,
        state: cast.state,
        origin: cast.origin,
        target: cast.targetPos,
        startedAt: cast.startedAt
      }
    } as CastSnapshotMsg);
  });
  
  // Send all active projectiles
  projectiles.forEach(proj => {
    socket.emit('msg', {
      type: 'ProjSpawn2',
      castId: proj.castId,
      origin: proj.pos,
      dir: proj.dir,
      speed: proj.speed,
      launchTs: proj.startTime,
      hitRadius: SKILLS[proj.skillId].projectile?.hitRadius || 0.5
    } as ProjSpawn2);
  });
}


// ==============================================================================
// FILE: server/combat/worldLoop.ts
// ==============================================================================

// filepath: /home/s/develop/projects/vibe/1/server/combat/worldLoop.ts
import { Server } from 'socket.io';
import { tickCasts, tickProjectiles, updateCasts } from './skillManager';

// Game state reference
let gameState: any = null;
let updateProjectilesLegacy: ((gameState: any, deltaTime: number) => void) | null = null;

// Track time
let lastTime = Date.now();
let isRunning = false;
let loopInterval: NodeJS.Timeout | null = null;

// Reference to IO server
let ioServer: Server | null = null;

// World interface implementation
const world = {
  getEnemyById: (id: string) => {
    if (!gameState || !gameState.enemies) return null;
    return gameState.enemies[id] || null;
  },
  
  getPlayerById: (id: string) => {
    if (!gameState || !gameState.players) return null;
    return gameState.players[id] || null;
  },
  
  getEntitiesInCircle: (pos: { x: number, z: number }, radius: number) => {
    const result: any[] = [];
    
    // Check enemies
    if (gameState && gameState.enemies) {
      for (const enemyId in gameState.enemies) {
        const enemy = gameState.enemies[enemyId];
        if (!enemy.isAlive) continue;
        
        const dx = enemy.position.x - pos.x;
        const dz = enemy.position.z - pos.z;
        const distSq = dx * dx + dz * dz;
        
        if (distSq <= radius * radius) {
          result.push(enemy);
        }
      }
    }
    
    // Check players (for PvP if enabled)
    if (gameState && gameState.players) {
      for (const playerId in gameState.players) {
        const player = gameState.players[playerId];
        if (!player.isAlive) continue;
        
        const dx = player.position.x - pos.x;
        const dz = player.position.z - pos.z;
        const distSq = dx * dx + dz * dz;
        
        if (distSq <= radius * radius) {
          result.push(player);
        }
      }
    }
    
    return result;
  }
};

/**
 * The main game tick function that updates all game entities
 */
function gameTick() {
  const now = Date.now();
  const deltaTime = now - lastTime;
  lastTime = now;
  
  // Process cast state machine for the new system
  if (ioServer) {
    tickCasts(deltaTime, ioServer, world);
    
    // Process projectile movement and collision for the new system
    tickProjectiles(deltaTime, ioServer, world);
  }
  
  // Legacy system integration
  // Update the casts in the legacy system
  if (ioServer) {
    updateCasts(ioServer, gameState?.players);
  } else {
    updateCasts(undefined, gameState?.players);
  }
  
  // Run existing projectile system (legacy mode) if it exists
  // This ensures both systems run side by side during transition
  if (updateProjectilesLegacy && typeof updateProjectilesLegacy === 'function' && gameState) {
    updateProjectilesLegacy(gameState, deltaTime / 1000);
  }
}

/**
 * Start the game loop
 * @param tickRateMs How often to run the game loop in milliseconds
 */
export function startWorldLoop(
  io: Server, 
  state: any, 
  updateProjectilesFn?: ((gameState: any, deltaTime: number) => void) | null,
  tickRateMs: number = 50 // Default to 20 ticks per second
) {
  // Store references
  ioServer = io;
  gameState = state;
  updateProjectilesLegacy = updateProjectilesFn || null;
  
  // Initialize time
  lastTime = Date.now();
  
  // Start the loop if not already running
  if (!isRunning) {
    isRunning = true;
    
    // Clear any existing interval
    if (loopInterval) {
      clearInterval(loopInterval);
    }
    
    // Start the new interval
    loopInterval = setInterval(gameTick, tickRateMs);
    console.log(`World loop started with tick rate: ${tickRateMs}ms`);
  }
}

/**
 * Stop the game loop
 */
export function stopWorldLoop() {
  if (isRunning && loopInterval) {
    clearInterval(loopInterval);
    loopInterval = null;
    isRunning = false;
    console.log('World loop stopped');
  }
}

/**
 * Update the game state reference
 */
export function updateGameState(newState: any) {
  gameState = newState;
}

/**
 * Check if the world loop is currently running
 */
export function isWorldLoopRunning(): boolean {
  return isRunning;
}


// ==============================================================================
// FILE: server/effects/entities.ts
// ==============================================================================

import { SkillDef } from '../../shared/skillsDefinition';
import { VecXZ, InstantHit, ProjHit2 } from '../../shared/messages';
import { getDamage, hash } from '../../shared/combatMath';
import { v4 as uuid } from 'uuid';

// Define a simplified GameState interface for use in this file
interface GameState {
  enemies: Record<string, any>;
  players: Record<string, any>;
}

export interface EffectEntity {
  id: string;
  skill: SkillDef;
  done: boolean;
  update(dt: number, state: GameState): (ProjHit2 | InstantHit)[];
}

/* ---- Projectile ---------- */
export class Projectile implements EffectEntity {
  id = uuid();
  done = false;
  constructor(
     public skill: SkillDef,
     public pos: VecXZ & {y:number},
     public dir: VecXZ & {y:number},
     public casterId: string,
     public targetId?: string)
  {}
  update(dt: number, state: GameState): ProjHit2[]{
     if(this.done) return [];
     
     // Use the standardized projectile speed from the skill definition
     const speed = this.skill.projectile?.speed || this.skill.speed || 0;
     this.pos.x += this.dir.x * speed * dt;
     this.pos.y += this.dir.y * speed * dt;
     this.pos.z += this.dir.z * speed * dt;
     
     /* hit check vs targetId (later broaden) */
     const hitMsgs: ProjHit2[] = [];
     if(this.targetId) {
        const t = state.enemies[this.targetId] || state.players[this.targetId];
        // Use the hitRadius from the projectile definition if available
        const hitRadius = this.skill.projectile?.hitRadius || 0.5;
        if(t && distanceXZ(this.pos, t.position) <= hitRadius) {
            this.done = true;
            
            // Add casterId to skill for XP calculation
            const skillWithCaster = {...this.skill, casterId: this.casterId};
            
            // Calculate damage using the shared function
            const { dmg } = getDamage({
              caster: state.players[this.casterId]?.stats || { dmgMult: 1 },
              skill: { base: this.skill.dmg || 10, variance: 0.1 },
              seed: `${this.id}:${t.id}`
            });
            
            // Apply the damage using our pre-calculated value
            applySkillDamage(skillWithCaster, t, state, dmg);
            
            hitMsgs.push({
              type: 'ProjHit2', 
              castId: this.id, 
              hitIds: [t.id], 
              dmg: [dmg],
              impactPos: { x: this.pos.x, z: this.pos.z }
            });
        }
     }
     return hitMsgs;
  }
}

/* ---- Instant ---------- */
export class Instant implements EffectEntity {
  id = uuid();
  done = false;
  constructor(public skill: SkillDef,
              public casterId: string,
              public targetIds: string[],
              public origin: {x: number; y: number; z: number}) {}
  
  update(dt: number, state: GameState): InstantHit[] {
     if(this.done) return [];
     this.done = true;
     
     /* immediately apply damage and effects to targets */
     const damageResults: number[] = [];
     
     for (const targetId of this.targetIds) {
       const target = state.enemies[targetId] || state.players[targetId];
       if (target) {
         // Add casterId to skill for XP calculation
         const skillWithCaster = {...this.skill, casterId: this.casterId};
         
         // Calculate damage using the shared function
         const { dmg } = getDamage({
           caster: state.players[this.casterId]?.stats || { dmgMult: 1 },
           skill: { base: this.skill.dmg || 10, variance: 0.1 },
           seed: `${this.id}:${targetId}`
         });
         
         damageResults.push(dmg);
         
         // Pass the pre-calculated damage to applySkillDamage
         applySkillDamage(skillWithCaster, target, state, dmg);
       } else {
         damageResults.push(0); // No damage for non-existent targets
       }
     }
     
     return [{
       type: 'InstantHit',
       skillId: this.skill.id,
       origin: this.origin,
       targetPos: this.origin,
       hitIds: this.targetIds,
       dmg: damageResults
     }];
  }
}

/* Helper functions */
export function distanceXZ(a: VecXZ, b: VecXZ): number {
  const dx = a.x - b.x;
  const dz = a.z - b.z;
  return Math.sqrt(dx * dx + dz * dz);
}

export function applySkillDamage(skill: any, target: any, state: GameState, precalculatedDmg?: number) {
  // Apply all effects from the skill
  const now = Date.now();
  
  // Use precalculated damage if provided, otherwise calculate it
  let dmgToApply: number;
  if (precalculatedDmg !== undefined) {
    dmgToApply = precalculatedDmg;
  } else {
    // Get damage using the shared damage calculation
    const { dmg } = getDamage({
      caster: state.players[skill.casterId]?.stats || { dmgMult: 1 },
      skill: { base: skill.effects?.find(e => e.type === 'damage')?.value || skill.dmg || 10, variance: 0.1 },
      seed: `${skill.id || ''}:${target.id || ''}`
    });
    dmgToApply = dmg;
  }
  
  // Process all skill effects
  for (const effect of skill.effects) {
    if (effect.type === 'damage') {
      // Apply damage from our calculation instead of the literal value
      target.health -= dmgToApply;
      if (target.health <= 0) {
        target.health = 0;
        target.isAlive = false;
        target.deathTimeTs = now;
        
        // Clear target if this is an enemy
        if (target.targetId !== undefined) {
          target.targetId = null;
        }
        
        // If this is an enemy, grant XP to the player who killed it
        if (state.players && skill.casterId) {
          const killer = state.players[skill.casterId];
          if (killer && target.experienceValue) {
            killer.experience += target.experienceValue;
            
            // Check for level up
            while (killer.experience >= killer.experienceToNextLevel) {
              killer.level++;
              killer.experience -= killer.experienceToNextLevel;
              killer.experienceToNextLevel = Math.floor(killer.experienceToNextLevel * 1.5);
              killer.maxHealth += 20;
              killer.health = killer.maxHealth;
              killer.maxMana += 10;
              killer.mana = killer.maxMana;
            }
          }
        }
      }
    } else {
      // Apply status effect
      const effectId = `effect-${hash(`${effect.type}-${now}`)}`;
      const statusEffect = {
        id: effectId,
        type: effect.type,
        value: effect.value,
        durationMs: effect.durationMs || 0,
        startTimeTs: now,
        sourceSkill: skill.id
      };
      
      const existingEffectIndex = target.statusEffects.findIndex((e: any) => e.type === effect.type);
      if (existingEffectIndex >= 0) {
        target.statusEffects[existingEffectIndex] = statusEffect;
      } else {
        target.statusEffects.push(statusEffect);
      }
    }
  }
}


// ==============================================================================
// FILE: server/effects/manager.ts
// ==============================================================================

import { EffectEntity, Projectile, Instant } from './entities';
import { SKILLS, SkillId } from '../../shared/skillsDefinition';
import { ProjSpawn2, ProjHit2, InstantHit } from '../../shared/messages';
import { getDamage } from '../../shared/combatMath';
import { Server } from 'socket.io';

// Define a simplified GameState interface to match our usage
interface GameState {
  enemies: Record<string, any>;
  players: Record<string, any>;
  [key: string]: any;
}

export class EffectManager {
  private effects: Record<string, EffectEntity> = {};
  
  constructor(
    private io: Server,
    private state: GameState
  ) {}
  
  spawnProjectile(skillId: SkillId, caster, dir, targetId?) {
      const skill = SKILLS[skillId];
      if (!skill) return null;
      
      const origin = {...caster.position, y: 1.5};
      const p = new Projectile(skill, origin, dir, caster.id, targetId);
      this.effects[p.id] = p;
      
      // Calculate travel time for the projectile if we have a target
      let travelMs;
      if (targetId) {
          const target = this.state.enemies[targetId] || this.state.players[targetId];
          if (target) {
              const dist = Math.sqrt(
                  Math.pow(target.position.x - origin.x, 2) +
                  Math.pow(target.position.z - origin.z, 2)
              );
              const speedMPS = skill.projectile?.speed || skill.speed || 0;
              const speedMPMS = speedMPS / 1000;
              travelMs = Math.ceil(dist / speedMPMS);
          }
      }
      
      // Emit enhanced projectile spawn event
      this.io.emit('msg', {
        type: 'ProjSpawn2',
        castId: p.id, 
        skillId: skillId, 
        origin: { x: origin.x, z: origin.z }, 
        dir: { x: dir.x, z: dir.z }, 
        speed: skill.projectile?.speed || skill.speed || 0, 
        launchTs: Date.now(),
        casterId: caster.id,
        hitRadius: skill.projectile?.hitRadius || 0.5,
        travelMs: travelMs
      } as ProjSpawn2);
      
      return p.id;
  }
  
  spawnInstant(skillId: SkillId, caster, targetIds) {
      const skill = SKILLS[skillId];
      if (!skill) return null;
      
      const inst = new Instant(skill, caster.id, targetIds, {...caster.position, y: 1.5});
      this.effects[inst.id] = inst;
      return inst.id;
  }
  
  updateAll(dt) {
      const updatedEnemies = new Set<string>();
      const updatedPlayers = new Set<string>();
      
      for(const id in this.effects) {
          const e = this.effects[id];
          const msgs = e.update(dt, this.state);
          
          // Collect IDs of targets that got hit
          msgs.forEach(m => {
              this.io.emit('msg', m);
              
              // Track which entities need updates
              if (m.type === 'ProjHit2' || m.type === 'InstantHit') {
                  (m.hitIds || []).forEach(hitId => {
                      if (this.state.enemies[hitId]) {
                          updatedEnemies.add(hitId);
                      } else if (this.state.players[hitId]) {
                          updatedPlayers.add(hitId);
                      }
                  });
              }
          });
          
          if(e.done) {
              delete this.effects[id];
              // No need to emit ProjEnd - the new protocol handles this through state transitions
          }
      }
      
      // Send updates for all affected entities
      updatedEnemies.forEach(enemyId => {
          this.io.emit('enemyUpdated', this.state.enemies[enemyId]);
      });
      
      updatedPlayers.forEach(playerId => {
          this.io.emit('playerUpdated', this.state.players[playerId]);
      });
  }
}


// ==============================================================================
// FILE: server/logger.ts
// ==============================================================================

// filepath: /home/s/develop/projects/vibe/1/server/logger.ts
// Simple logger module to replace console.log with more controlled debugging

// Set to true to enable debug logs, false to disable them
export const DEBUG = true;

// Define different log categories
export const LOG_CATEGORIES = {
  COLLISION: 'collision',
  PROJECTILE: 'projectile',
  MOVEMENT: 'movement',
  DAMAGE: 'damage',
  ENEMY: 'enemy',
  PLAYER: 'player',
  SKILL: 'skill',
  NETWORK: 'network',
  SYSTEM: 'system'
};

// Set which categories to enable when DEBUG is true
const ENABLED_CATEGORIES = [
  //LOG_CATEGORIES.COLLISION,
  // LOG_CATEGORIES.PROJECTILE, // Disabled to reduce log spam
  LOG_CATEGORIES.DAMAGE,
  LOG_CATEGORIES.ENEMY,
  LOG_CATEGORIES.PLAYER,
  LOG_CATEGORIES.SKILL,
  LOG_CATEGORIES.NETWORK,
  LOG_CATEGORIES.SYSTEM
];

/**
 * Logs a message if debugging is enabled and the category is enabled
 * @param category The log category
 * @param message The message to log
 * @param args Optional additional args to log
 */
export function log(category: string, message: string, ...args: any[]) {
  if (DEBUG && ENABLED_CATEGORIES.includes(category)) {
    console.log(`[${category.toUpperCase()}] ${message}`, ...args);
  }
}

/**
 * Logs a warning message
 * @param category The log category
 * @param message The message to log
 * @param args Optional additional args to log
 */
export function warn(category: string, message: string, ...args: any[]) {
  console.warn(`[${category.toUpperCase()}] WARNING: ${message}`, ...args);
}

/**
 * Logs an error message
 * @param category The log category
 * @param message The message to log
 * @param args Optional additional args to log
 */
export function error(category: string, message: string, ...args: any[]) {
  console.error(`[${category.toUpperCase()}] ERROR: ${message}`, ...args);
}


// ==============================================================================
// FILE: server/server.ts
// ==============================================================================

import { createServer } from 'node:http';
import { Server } from 'socket.io';
import { ZoneManager } from '../shared/zoneSystem.js';
import { initWorld } from './world.js';
import { startWorldLoop } from './combat/worldLoop.js';
import { sendCastSnapshots } from './combat/skillManager.js';

// Create HTTP server
const httpServer = createServer();

// Configure Socket.IO with improved settings
const io = new Server(httpServer, {
  cors: {
    origin: ["http://localhost:3000", "http://127.0.0.1:3000"],
    methods: ["GET", "POST"],
    credentials: true
  },
  transports: ['websocket'], // Prefer WebSocket only for better performance
  pingTimeout: 60000,
  pingInterval: 30000, // Increased to avoid conflict with our 30Hz update rate
  connectTimeout: 45000,
  allowEIO3: true,
  maxHttpBufferSize: 1e8,
  path: '/socket.io/'
});

// Initialize zone manager
const zoneManager = new ZoneManager();

// Initialize game world with the IO instance and zone manager
const world = initWorld(io, zoneManager);

// Handle socket connections
io.on('connection', (socket) => {
  console.log('Client connected:', socket.id);

  // Handle player joining
  socket.on('joinGame', (playerName: string) => {
    console.log('Player joining:', playerName);
    
    // Add the player to the world
    const player = world.addPlayer(socket.id, playerName);
    
    // Send player ID to the client
    socket.emit('joinGame', { playerId: player.id });
    
    // Send full game state to the new player
    socket.emit('gameState', world.getGameState());
    
    // Send all active casts and projectiles to the new player
    sendCastSnapshots(socket);
    
    // Broadcast new player to others
    socket.broadcast.emit('playerJoined', player);
  });

  // Handle game state requests
  socket.on('requestGameState', () => {
    const gameState = world.getGameState();
    console.log('Client requested game state. Enemy count:', Object.keys(gameState.enemies).length);
    socket.emit('gameState', gameState);
  });

  // Handle new message format
  socket.on('msg', (message) => {
    world.handleMessage(socket, message);
  });

  // Legacy handlers - keep for backwards compatibility
  socket.on('moveStart', (message) => {
    console.log('Legacy moveStart received - should use msg type instead');
    // Convert to new format and pass to world
    const m = {
      type: 'MoveStart',
      id: message.id,
      path: [message.to],
      speed: message.speed,
      clientTs: message.ts
    };
    world.handleMessage(socket, m);
  });

  socket.on('moveStop', (message) => {
    console.log('Legacy moveStop received - should use MoveSync instead');
    // Convert to new format and pass to world
    const m = {
      type: 'MoveSync',
      id: message.id,
      pos: message.pos,
      clientTs: message.ts
    };
    world.handleMessage(socket, m);
  });

  socket.on('castSkillRequest', (data) => {
    console.log('Legacy castSkillRequest received - should use CastReq instead');
    // Convert to new format and pass to world
    const m = {
      type: 'CastReq',
      id: Object.keys(world.getGameState().players).find(
        id => world.getGameState().players[id].socketId === socket.id
      ) || '',
      skillId: data.skillId,
      targetId: data.targetId,
      clientTs: Date.now()
    };
    world.handleMessage(socket, m);
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Client disconnected:', socket.id);
    
    // Remove the player from the world
    const playerId = world.removePlayerBySocketId(socket.id);
    
    if (playerId) {
      // Broadcast player removal to all clients
      io.emit('playerLeft', playerId);
    }
  });
});

// Error handling
process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
});

process.on('unhandledRejection', (error) => {
  console.error('Unhandled Rejection:', error);
});

// Start the server
const PORT = process.env.PORT || 3001;

console.log('Attempting to start game server...');

try {
  httpServer.listen(PORT, () => {
    console.log(`Game server running on port ${PORT}`);
    console.log(`Enemy count at startup: ${Object.keys(world.getGameState().enemies).length}`);
    console.log('Game zones:', zoneManager.getZones().map(zone => zone.name).join(', '));
    
    // Start the enhanced world loop with the game state
    console.log('Starting enhanced combat system...');
    startWorldLoop(io, world.getGameState(), undefined, 50); // 50ms = 20 ticks per second
  });
} catch (error) {
  console.error('Failed to start server:', error);
  process.exit(1);
}


// ==============================================================================
// FILE: server/skillHandler.ts
// ==============================================================================

import { Socket } from 'socket.io';
import { LearnSkill, SetSkillShortcut } from '../shared/messages.js';
import { SkillId } from '../shared/skillsDefinition.js';
import { canLearnSkill } from '../shared/classSystem.js';
import { CharacterClass } from '../shared/classSystem.js';
import { canPlayerLearnSkill, learnNewSkill, setSkillShortcut } from './skillManager.js';

// Define simplified types for what we need from the game state
interface Player {
  id: string;
  socketId: string;
  level: number;
  className: string;
  unlockedSkills: SkillId[];
  skillShortcuts: (SkillId | null)[];
  availableSkillPoints: number;
}

interface GameState {
  players: Record<string, Player>;
}

/**
 * Handle the LearnSkill message 
 */
export function onLearnSkill(socket: Socket, state: GameState, msg: LearnSkill): void {
  console.log(`[SKILL] Received LearnSkill request for skill: ${msg.skillId}`);
  
  // Get player by socket ID
  const playerId = Object.keys(state.players).find(
    id => state.players[id].socketId === socket.id
  );
  
  if (!playerId) {
    console.warn(`[SKILL] Learn skill request from unknown socket: ${socket.id}`);
    return;
  }
  
  const player = state.players[playerId];
  console.log(`[SKILL] Player ${playerId} info:`, {
    className: player.className,
    level: player.level,
    unlockedSkills: player.unlockedSkills,
    availableSkillPoints: player.availableSkillPoints
  });
  
  // Skip if player already has this skill
  if (player.unlockedSkills.includes(msg.skillId)) {
    console.log(`[SKILL] Player ${playerId} already has skill: ${msg.skillId}`);
    socket.emit('msg', {
      type: 'SkillLearned',
      skillId: msg.skillId,
      remainingPoints: player.availableSkillPoints
    });
    return;
  }
  
  // Validate player has skill points to spend
  if (player.availableSkillPoints <= 0) {
    console.warn(`[SKILL] Player ${playerId} has no skill points to learn ${msg.skillId}`);
    return;
  }
  
  // Check if player can learn this skill based on class and level requirements
  if (canPlayerLearnSkill(player, msg.skillId)) {
    // Learn the skill using skillManager function
    if (learnNewSkill(player, msg.skillId)) {
      console.log(`[SKILL] Player ${playerId} learned skill: ${msg.skillId}`);
      
      // Send notification to client
      socket.emit('msg', {
        type: 'SkillLearned',
        skillId: msg.skillId,
        remainingPoints: player.availableSkillPoints
      });
      
      // Broadcast player update to all clients
      socket.broadcast.emit('playerUpdated', {
        id: player.id,
        unlockedSkills: player.unlockedSkills,
        skillShortcuts: player.skillShortcuts,
        availableSkillPoints: player.availableSkillPoints
      });
    } else {
      console.warn(`[SKILL] Failed to learn skill ${msg.skillId} for player ${playerId}`);
    }
  } else {
    console.warn(`[SKILL] Player ${playerId} cannot learn skill: ${msg.skillId}`);
  }
}

/**
 * Handle the SetSkillShortcut message
 */
export function onSetSkillShortcut(socket: Socket, state: GameState, msg: SetSkillShortcut): void {
  console.log(`[SKILL] Received SetSkillShortcut request for slot ${msg.slotIndex}: ${msg.skillId}`);
  
  // Get player by socket ID
  const playerId = Object.keys(state.players).find(
    id => state.players[id].socketId === socket.id
  );
  
  if (!playerId) {
    console.warn(`[SKILL] Set skill shortcut request from unknown socket: ${socket.id}`);
    return;
  }
  
  const player = state.players[playerId];
  
  // Validate slot index is valid (0-8 for keys 1-9)
  if (msg.slotIndex < 0 || msg.slotIndex > 8) {
    console.warn(`[SKILL] Invalid shortcut slot index: ${msg.slotIndex}`);
    return;
  }
  
  // If clearing the slot, allow it
  if (msg.skillId === null) {
    if (setSkillShortcut(player, msg.slotIndex, null)) {
      console.log(`[SKILL] Player ${playerId} cleared shortcut slot ${msg.slotIndex}`);
      
      // Send confirmation to client
      socket.emit('msg', {
        type: 'SkillShortcutUpdated',
        slotIndex: msg.slotIndex,
        skillId: null
      });
      
      // Broadcast player update to all clients
      socket.broadcast.emit('playerUpdated', {
        id: player.id,
        skillShortcuts: player.skillShortcuts
      });
    }
    return;
  }
  
  // Validate skill is unlocked
  if (!player.unlockedSkills.includes(msg.skillId)) {
    console.warn(`[SKILL] Player ${playerId} tried to shortcut skill they don't have: ${msg.skillId}`);
    return;
  }
  
  // Update skill shortcut
  if (setSkillShortcut(player, msg.slotIndex, msg.skillId)) {
    console.log(`[SKILL] Player ${playerId} set shortcut slot ${msg.slotIndex} to skill: ${msg.skillId}`);
    
    // Send confirmation to client
    socket.emit('msg', {
      type: 'SkillShortcutUpdated',
      slotIndex: msg.slotIndex,
      skillId: msg.skillId
    });
    
    // Broadcast player update to all clients
    socket.broadcast.emit('playerUpdated', {
      id: player.id,
      skillShortcuts: player.skillShortcuts
    });
  } else {
    console.warn(`[SKILL] Failed to set shortcut for player ${playerId}`);
  }
}


// ==============================================================================
// FILE: server/skillManager.ts
// ==============================================================================

// filepath: /home/s/develop/projects/vibe/1/server/skillManager.ts
import { Socket } from 'socket.io';
import { SkillId, SKILLS } from '../shared/skillsDefinition.js';
import { canLearnSkill, CharacterClass, CLASS_SKILL_TREES } from '../shared/classSystem.js';

// Define simplified types for what we need from the game state
interface Player {
  id: string;
  socketId: string;
  level: number;
  className: string;
  unlockedSkills: SkillId[];
  skillShortcuts: (SkillId | null)[];
  availableSkillPoints: number;
  // Other player properties omitted
}

/**
 * Check if a player can learn a specific skill
 */
export function canPlayerLearnSkill(player: Player, skillId: SkillId): boolean {
  // Check that player has skill points
  if (player.availableSkillPoints <= 0) {
    return false;
  }
  
  // Check if player already has this skill
  if (player.unlockedSkills.includes(skillId)) {
    return false;
  }
  
  // Use the shared check from classSystem
  return canLearnSkill(
    skillId,
    player.className as CharacterClass,
    player.level,
    player.unlockedSkills as SkillId[]
  );
}

/**
 * Learn a new skill for the player
 */
export function learnNewSkill(player: Player, skillId: SkillId): boolean {
  try {
    // Skip if player already has the skill
    if (player.unlockedSkills.includes(skillId)) {
      return true; // Not an error, just already learned
    }
    
    // Check if player can learn this skill
    if (!canPlayerLearnSkill(player, skillId)) {
      return false;
    }

    // Add skill to unlocked skills
    player.unlockedSkills.push(skillId);
    
    // Deduct a skill point
    player.availableSkillPoints -= 1;
    
    // Automatically assign to the first empty shortcut slot if available
    const emptySlotIndex = player.skillShortcuts.findIndex(slot => slot === null);
    if (emptySlotIndex !== -1) {
      player.skillShortcuts[emptySlotIndex] = skillId;
    }
    
    return true;
  } catch (error) {
    console.error(`Error learning skill ${skillId}:`, error);
    return false;
  }
}

/**
 * Set a skill shortcut
 */
export function setSkillShortcut(player: Player, slotIndex: number, skillId: SkillId | null): boolean {
  try {
    // Validate slot index is within range (0-8 for keys 1-9)
    if (slotIndex < 0 || slotIndex > 8) {
      return false;
    }
    
    // If skillId is provided, validate it's unlocked
    if (skillId !== null && !player.unlockedSkills.includes(skillId)) {
      return false;
    }
    
    // If we're trying to set a skill (not clearing a slot)
    if (skillId !== null) {
      // Check if this skill is already assigned to a different shortcut slot
      const existingIndex = player.skillShortcuts.findIndex(id => id === skillId);
      if (existingIndex !== -1 && existingIndex !== slotIndex) {
        // Remove it from the existing slot to prevent duplicates
        console.log(`Skill ${skillId} already exists in slot ${existingIndex + 1}, removing from that slot`);
        player.skillShortcuts[existingIndex] = null;
      }
    }
    
    // Update the shortcut slot
    player.skillShortcuts[slotIndex] = skillId;
    
    return true;
  } catch (error) {
    console.error('Error setting skill shortcut:', error);
    return false;
  }
}

/**
 * Get available skills to learn for a player
 */
export function getAvailableSkillsToLearn(player: Player): SkillId[] {
  try {
    const availableSkills: SkillId[] = [];
    const classTree = CLASS_SKILL_TREES[player.className as CharacterClass];
    
    if (!classTree) {
      return [];
    }
    
    // Check all skills in class progression
    for (const [skillId, requirement] of Object.entries(classTree.skillProgression)) {
      // Skip skills player already has
      if (player.unlockedSkills.includes(skillId as SkillId)) {
        continue;
      }
      
      // Check if player can learn this skill
      if (canLearnSkill(
        skillId as SkillId,
        player.className as CharacterClass,
        player.level,
        player.unlockedSkills as SkillId[]
      )) {
        availableSkills.push(skillId as SkillId);
      }
    }
    
    return availableSkills;
  } catch (error) {
    console.error('Error getting available skills:', error);
    return [];
  }
}

/**
 * Award a skill point to a player (e.g., on level up)
 */
export function awardSkillPoint(player: Player): void {
  player.availableSkillPoints += 1;
}


// ==============================================================================
// FILE: server/skills.ts
// ==============================================================================

import { Server } from 'socket.io';
import { Enemy, StatusEffect } from '../shared/types.js';
import { SkillType } from './types.js';
import { SKILLS, SkillId } from '../shared/skillsDefinition.js';
import { VecXZ } from '../shared/messages.js';
import { predictPosition, awardPlayerXP } from './world.js';
import { hash } from '../shared/combatMath.js';

interface PlayerState {
  id: string;
  socketId: string;
  name: string;
  position: { x: number; y: number; z: number };
  rotation: { x: number; y: number; z: number };
  health: number;
  maxHealth: number;
  mana: number;
  maxMana: number;
  skills: SkillType[];
  skillCooldownEndTs: Record<string, number>;
  statusEffects: StatusEffect[];
  level: number;
  experience: number;
  experienceToNextLevel: number;
  castingSkill: SkillType | null;
  castingProgressMs: number;
  isAlive: boolean;
  deathTimeTs?: number;
  lastUpdateTime?: number;
  movement?: any;
  velocity?: { x: number; z: number };
  posHistory?: { ts: number; x: number; z: number }[];
}

/**
 * Calculate distance between two points
 */
function distance(a: VecXZ, b: VecXZ): number {
  const dx = a.x - b.x;
  const dz = a.z - b.z;
  return Math.sqrt(dx * dx + dz * dz);
}

/**
 * Check if a skill can be cast
 * Uses prediction to ensure accurate position for range checks
 */
export function canCast(
  caster: PlayerState,
  skill: { id: string, range: number },
  target: Enemy | null,
  targetPos: VecXZ | null,
  now: number
): boolean {
  // Check if caster is alive
  if (!caster.isAlive) {
    return false;
  }
  
  // Check if skill is on cooldown
  const cooldownEnd = caster.skillCooldownEndTs[skill.id] || 0;
  if (now < cooldownEnd) {
    return false;
  }
  
  // Get skill definition
  const skillDef = SKILLS[skill.id as SkillType];
  if (!skillDef) {
    return false;
  }
  
  // Check mana cost
  if (caster.mana < skillDef.manaCost) {
    return false;
  }
  
  // If target-based skill, check target is valid
  if (target) {
    if (!target.isAlive) {
      return false;
    }
    
    // Predict caster position at current time
    const casterPos = predictPosition(caster, now);
    
    // Get target position
    const targetPos = { x: target.position.x, z: target.position.z };
    
    // Check range
    if (distance(casterPos, targetPos) > skill.range) {
      return false;
    }
  } 
  // If position-based skill, check position is within range
  else if (targetPos) {
    const casterPos = predictPosition(caster, now);
    
    // Check range
    if (distance(casterPos, targetPos) > skill.range) {
      return false;
    }
  } else {
    // No target or position specified
    return false;
  }
  
  return true;
}

/**
 * Execute a skill with all its effects
 */
export function executeSkill(
  caster: PlayerState,
  target: Enemy,
  skillId: SkillType,
  server: Server
): void {
  const now = Date.now();
  const skill = SKILLS[skillId];
  
  if (!skill) return;
  
  // Apply skill cost
  caster.mana -= skill.manaCost;
  caster.skillCooldownEndTs[skillId] = now + skill.cooldownMs;
  
  // Apply damage
  if (skill.dmg && target) {
    const oldHealth = target.health;
    target.health = Math.max(0, target.health - skill.dmg);
    
    if (target.health === 0) {
      target.isAlive = false;
      target.deathTimeTs = now;
      target.targetId = null;
      
      // Grant experience to the player using the centralized function
      awardPlayerXP(caster, target.experienceValue, `killing enemy ${target.id} with ${skillId}`, server);
    }
  }
  
  // Apply status effect
  if (skill.status && target) {
    for (const status of skill.status) {
      const existingEffect = target.statusEffects.find(e => e.type === status.type);
      if (existingEffect) {
        existingEffect.value = status.value;
        existingEffect.durationMs = status.durationMs;
        existingEffect.startTimeTs = now;
      } else {
        // Generate a deterministic effect ID
        const effectId = `effect-${hash(`${effect.type}-${now}-${player.id}`)}`;
        target.statusEffects.push({
          id: effectId,
          ...status,
          startTimeTs: now,
          sourceSkill: skillId,
        });
      }
    }
  }
  
  // Broadcast updates
  server.emit('enemyUpdated', target);
  server.emit('playerUpdated', caster);
}

/**
 * Spawn a projectile from a skill cast
 */
export function spawnProjectileFromSkill(
  world: any,  // World interface will be defined later
  caster: PlayerState,
  skillId: SkillId,
  targetPos?: VecXZ,
  targetId?: string
): void {
  const skill = SKILLS[skillId];
  
  // Check if skill exists and is a projectile type
  if (!skill || skill.cat !== 'projectile' || !skill.speed) {
    return;
  }
  
  // Get caster position
  const casterPos: VecXZ = { x: caster.position.x, z: caster.position.z };
  
  // Determine target position
  let finalTargetPos: VecXZ;
  
  if (targetPos) {
    // If target position provided, use it
    finalTargetPos = targetPos;
  } else if (targetId) {
    // If target ID provided, get entity position
    const targetEntity = world.getGameState().enemies[targetId] || world.getGameState().players[targetId];
    if (!targetEntity) return;
    
    finalTargetPos = { x: targetEntity.position.x, z: targetEntity.position.z };
  } else {
    // No valid target, use caster's forward direction
    const forwardDir = { x: 0, z: 1 }; // Assuming +Z is forward
    finalTargetPos = {
      x: casterPos.x + forwardDir.x * 10, // 10 units forward
      z: casterPos.z + forwardDir.z * 10
    };
  }
  
  // Calculate direction from caster to target
  const dx = finalTargetPos.x - casterPos.x;
  const dz = finalTargetPos.z - casterPos.z;
  const dist = Math.sqrt(dx * dx + dz * dz);
  
  // Normalize direction
  const dir: VecXZ = dist > 0 
    ? { x: dx / dist, z: dz / dist } 
    : { x: 0, z: 1 };  // Default forward
  
  // Spawn the projectile in the world
  world.spawnProjectile({
    casterId: caster.id,
    skillId,
    pos: casterPos,
    dir,
    speed: skill.speed,
    targetId
  });
}


// ==============================================================================
// FILE: server/spatial/SpatialHashGrid.ts
// ==============================================================================

import { VecXZ } from '../../shared/messages';

// Define EntityId type locally to avoid dependency issues
type EntityId = string;

/**
 * A spatial hash grid for efficient spatial queries
 */
export class SpatialHashGrid {
  private cells: Map<string, Set<EntityId>>;
  private cellSize: number;
  private invCellSize: number;
  private _scratchSet: Set<string>;
  private _scratchArr: string[];

  /**
   * Creates a new spatial hash grid with customizable cell size
   * @param cellSize The size of each grid cell (default: 6)
   */
  constructor(cellSize: number = 6) {
    this.cells = new Map<string, Set<EntityId>>();
    this.cellSize = cellSize;
    this.invCellSize = 1 / cellSize;
    this._scratchSet = new Set<string>();
    this._scratchArr = [] as string[];
  }

  /**
   * Creates a cell key from world coordinates using specified cell size
   * Static helper for external use without instantiating a grid
   */
  static key(x: number, z: number, cellSize: number = 6): string {
    const ix = Math.floor(x / cellSize);
    const iz = Math.floor(z / cellSize);
    return `${ix},${iz}`;
  }

  /**
   * Generates a hash key from world coordinates
   */
  private hash(x: number, z: number): string {
    const ix = Math.floor(x * this.invCellSize);
    const iz = Math.floor(z * this.invCellSize);
    return `${ix},${iz}`;
  }

  /**
   * Inserts an entity into the grid at the specified position
   */
  public insert(id: EntityId, pos: VecXZ): void {
    const key = this.hash(pos.x, pos.z);
    
    if (!this.cells.has(key)) {
      this.cells.set(key, new Set<EntityId>());
    }
    
    this.cells.get(key)!.add(id);
  }
  
  /**
   * Moves an entity from its old position to a new position in the grid
   */
  public move(id: EntityId, oldPos: VecXZ, newPos: VecXZ): void {
    const oldKey = this.hash(oldPos.x, oldPos.z);
    const newKey = this.hash(newPos.x, newPos.z);
    
    // If the entity hasn't changed cells, no need to update the grid
    if (oldKey === newKey) {
      return;
    }
    
    // Remove from old cell
    const oldCell = this.cells.get(oldKey);
    if (oldCell) {
      oldCell.delete(id);
      // Clean up empty cells to prevent memory leaks
      if (oldCell.size === 0) {
        this.cells.delete(oldKey);
      }
    }
    
    // Add to new cell
    if (!this.cells.has(newKey)) {
      this.cells.set(newKey, new Set<EntityId>());
    }
    
    this.cells.get(newKey)!.add(id);
  }
  
  /**
   * Removes an entity from the grid
   */
  public remove(id: EntityId, pos: VecXZ): void {
    const key = this.hash(pos.x, pos.z);
    
    const cell = this.cells.get(key);
    if (cell) {
      cell.delete(id);
      // Clean up empty cells to prevent memory leaks
      if (cell.size === 0) {
        this.cells.delete(key);
      }
    }
  }
  
  /**
   * Queries the grid for entities within a circle centered at pos with radius r
   * Returns deduplicated list of entity IDs
   */
  public queryCircle(pos: VecXZ, r: number): EntityId[] {
    const set = this._scratchSet;
    set.clear();
    
    const cellRadius = Math.ceil(r * this.invCellSize);
    const centerIx = Math.floor(pos.x * this.invCellSize);
    const centerIz = Math.floor(pos.z * this.invCellSize);
    
    // Generate keys for all cells that might intersect with the circle
    for (let ix = centerIx - cellRadius; ix <= centerIx + cellRadius; ix++) {
      for (let iz = centerIz - cellRadius; iz <= centerIz + cellRadius; iz++) {
        const key = `${ix},${iz}`;
        const cell = this.cells.get(key);
        
        if (cell) {
          // Add all entities from this cell to the result set
          for (const id of cell) {
            set.add(id);
          }
        }
      }
    }
    
    // Convert set to array using scratch array to avoid allocation
    this._scratchArr.length = 0;
    for (const id of set) {
      this._scratchArr.push(id);
    }
    
    return this._scratchArr;
  }
}

/**
 * Checks if an entity has moved to a different grid cell
 * Uses static key method to avoid unnecessary object instantiation
 */
export function gridCellChanged(oldPos: VecXZ, newPos: VecXZ): boolean {
  const oldKey = SpatialHashGrid.key(oldPos.x, oldPos.z);
  const newKey = SpatialHashGrid.key(newPos.x, newPos.z);
  return oldKey !== newKey;
}


// ==============================================================================
// FILE: server/types.ts
// ==============================================================================

import { SkillId, SKILLS, SkillDef, SkillEffect as SharedSkillEffect } from '../shared/skillsDefinition.js';
import { VecXZ } from '../shared/messages.js';
import { CharacterClass } from '../shared/classSystem.js';

// Server-side representation of a skill effect
export interface SkillEffect extends SharedSkillEffect {
    id?: string;
    startTimeTs?: number;
    sourceSkill?: string;
}

// Re-export SkillDef for server
export type { SkillDef };

export interface Projectile {
    id: string;
    casterId: string;
    skillId: SkillId;
    pos: VecXZ;
    dir: VecXZ;
    speed: number;
    spawnTs: number;
    targetId?: string;  // Optional for homing projectiles
    hitTargets: string[];  // Track entities that have been hit by this projectile
    hitCount: number;  // Track number of hits for piercing projectiles
}

export type SkillType = SkillId;   // export for compatibility

// Add an alias for 'water' skill ID to match 'waterSplash'
(SKILLS as any)['water'] = SKILLS['waterSplash'];

// Player class data - stores class and unlocked skills
export interface PlayerClassData {
    className: CharacterClass;
    unlockedSkills: SkillId[];
    activeSkills: SkillId[]; // Skills currently equipped (limited by slots)
    availableSkillPoints: number;
}


// ==============================================================================
// FILE: server/world.ts
// ==============================================================================

import { Server, Socket } from 'socket.io';
import { ZoneManager } from '../shared/zoneSystem.js';
import { Enemy, StatusEffect, PlayerState as SharedPlayerState } from '../shared/types.js';
import { SkillType, Projectile } from './types.js';
import { isPathBlocked, findValidDestination, sweptHit } from './collision.js';
import { ClientMsg, MoveStart, MoveSync, CastReq, VecXZ, PosSnap, PlayerMovementState, LearnSkill, SetSkillShortcut } from '../shared/messages.js';
import { log, LOG_CATEGORIES } from './logger.js';
import { EffectManager } from './effects/manager';
import { SKILLS, SkillId } from '../shared/skillsDefinition.js';
import { onLearnSkill, onSetSkillShortcut } from './skillHandler.js';
import { handleCastReq, updateCasts, getCompletedCasts } from './combat/skillManager.js';
import { predictPosition as sharedPredictPosition } from '../shared/positionUtils.js';
import { SpatialHashGrid, gridCellChanged } from './spatial/SpatialHashGrid';
import { getDamage, hash, rng } from '../shared/combatMath.js';
import { effectRunner } from './combat/effects/EffectRunner.js';

/**
 * Defines the GameState interface
 */
interface GameState {
  players: Record<string, PlayerState>;
  enemies: Record<string, Enemy>;
  projectiles: Projectile[];
  lastProjectileId: number;
}

// Update PlayerState to include the class system fields
interface PlayerState {
  id: string;
  socketId: string;
  name: string;
  position: { x: number; y: number; z: number };
  rotation: { x: number; y: number; z: number };
  health: number;
  maxHealth: number;
  mana: number;
  maxMana: number;
  className: string; // Character class: mage, warrior, etc.
  unlockedSkills: SkillId[]; // Skills the player has learned
  skillShortcuts: (SkillId | null)[]; // Skills assigned to number keys 1-9
  availableSkillPoints: number; // Points to spend on new skills
  skillCooldownEndTs: Record<string, number>;
  cooldowns: Record<string, number>; // Alias for skillCooldownEndTs for compatibility
  statusEffects: StatusEffect[];
  level: number;
  experience: number;
  experienceToNextLevel: number;
  castingSkill: SkillType | null;
  castingProgressMs: number;
  isAlive: boolean;
  deathTimeTs?: number;
  lastUpdateTime?: number;
  movement?: PlayerMovementState;
  velocity?: { x: number; z: number }; // New: current velocity vector
  posHistory?: { ts: number; x: number; z: number }[]; // Position history for better hit detection
  stats?: {
    dmgMult?: number;
    critChance?: number;
    critMult?: number;
  };
}

/**
 * Calculates the distance between two positions
 */
function distance(a: VecXZ, b: VecXZ): number {
  const dx = a.x - b.x;
  const dz = a.z - b.z;
  return Math.sqrt(dx * dx + dz * dz);
}

/**
 * Calculates the direction vector from source to destination
 */
function calculateDir(from: VecXZ, to: VecXZ): { x: number; y: number; z: number } {
  const dx = to.x - from.x;
  const dz = to.z - from.z;
  const dist = Math.sqrt(dx * dx + dz * dz);
  
  // Normalize direction
  if (dist === 0) return { x: 0, y: 0, z: 0 };
  return {
    x: dx / dist,
    y: 0, // Add y component with default 0
    z: dz / dist
  };
}

/**
 * Predicts the position of an entity at a specific timestamp based on its movement
 */
export function predictPosition(
  entity: { position: { x: number; z: number }, movement?: { dest: VecXZ | null, speed: number, startTs: number } },
  timestamp: number
): VecXZ {
  if (!entity.movement?.dest) {
    return { x: entity.position.x, z: entity.position.z };
  }

  const dest = entity.movement.dest;
  const speed = entity.movement.speed;
  const startTs = entity.movement.startTs;
  const currentPos = { x: entity.position.x, z: entity.position.z };
  
  // Calculate elapsed time in seconds
  const elapsedSec = (timestamp - startTs) / 1000;
  
  // Calculate direction
  const dir = calculateDir(currentPos, dest);
  
  // Calculate distance that would be covered by now
  const distanceCovered = speed * elapsedSec;
  const totalDistance = distance(currentPos, dest);
  
  // If we've reached or passed the destination, return destination
  if (distanceCovered >= totalDistance) {
    return dest;
  }
  
  // Otherwise, interpolate
  return {
    x: currentPos.x + dir.x * distanceCovered,
    z: currentPos.z + dir.z * distanceCovered
  };
}

/**
 * Advances an entity's position based on its movement state
 */
function advancePosition(entity: PlayerState, deltaTimeMs: number): void {
  if (!entity.movement?.dest) return;
  
  // Current position
  const currentPos = { x: entity.position.x, z: entity.position.z };
  
  // Get destination and speed
  const dest = entity.movement.dest;
  const speed = entity.movement.speed;
  
  // Calculate direction if not already set
  if (!entity.velocity) {
    const dir = calculateDir(currentPos, dest);
    entity.velocity = {
      x: dir.x * speed,
      z: dir.z * speed
    };
  }
  
  // Calculate distance to move this step
  const deltaTimeSec = deltaTimeMs / 1000;
  const stepX = entity.velocity.x * deltaTimeSec;
  const stepZ = entity.velocity.z * deltaTimeSec;
  
  // Update position
  const oldPos = { x: entity.position.x, z: entity.position.z };
  entity.position.x += stepX;
  entity.position.z += stepZ;
  const newPos = { x: entity.position.x, z: entity.position.z };
  
  // Update spatial hash grid if position changed cells
  if (gridCellChanged(oldPos, newPos)) {
    spatial.move(entity.id, oldPos, newPos);
  }
  
  // Check if we've reached the destination
  const newDist = distance(newPos, dest);
  const prevDist = distance(currentPos, dest);
  
  // If we've passed the destination or are very close, snap to it and clear movement
  if (newDist > prevDist || newDist < 0.1) {
    entity.position.x = dest.x;
    entity.position.z = dest.z;
    
    // Check again if final position changed the cell
    const finalPos = { x: dest.x, z: dest.z };
    if (gridCellChanged(newPos, finalPos)) {
      spatial.move(entity.id, newPos, finalPos);
    }
    
    entity.movement.dest = null;
    entity.velocity = { x: 0, z: 0 };
    
    // Add a flag to indicate velocity was zeroed so we include it in the next snapshot
    (entity as any).dirtySnap = true;
  }
  
  // Update the position history after movement
  updatePositionHistory(entity, Date.now());
}

/**
 * Updates the position history of an entity, maintaining a limited history window
 */
function updatePositionHistory(entity: PlayerState | Enemy, timestamp: number): void {
  if (!entity.posHistory) {
    entity.posHistory = [];
  }
  
  // Add current position to history
  entity.posHistory.push({
    ts: timestamp,
    x: entity.position.x,
    z: entity.position.z
  });
  
  // Trim old entries to keep history within the time window (500ms)
  const MAX_HISTORY_AGE_MS = 500;
  while (entity.posHistory.length > 0 && 
         entity.posHistory[0].ts < timestamp - MAX_HISTORY_AGE_MS) {
    entity.posHistory.shift();
  }
}

/**
 * Gets the position of an entity at a specific timestamp by interpolating position history
 */
function getPositionAtTime(entity: PlayerState | Enemy, timestamp: number): VecXZ {
  // For enemies or entities without history, just return current position
  if (!('posHistory' in entity) || !entity.posHistory || entity.posHistory.length === 0) {
    return { x: entity.position.x, z: entity.position.z };
  }
  
  const history = entity.posHistory;
  
  // If timestamp is newer than all history entries, use the latest position
  if (timestamp > history[history.length - 1].ts) {
    return { x: entity.position.x, z: entity.position.z };
  }
  
  // If timestamp is older than all history entries, use the oldest position
  if (timestamp < history[0].ts) {
    return { x: history[0].x, z: history[0].z };
  }
  
  // Find the two history entries that bracket the requested timestamp
  let beforeIndex = 0;
  for (let i = 0; i < history.length - 1; i++) {
    if (history[i].ts <= timestamp && history[i + 1].ts >= timestamp) {
      beforeIndex = i;
      break;
    }
  }
  
  const before = history[beforeIndex];
  const after = history[beforeIndex + 1];
  
  // Linear interpolation between the two positions
  if (after.ts === before.ts) {
    return { x: before.x, z: before.z }; // Avoid division by zero
  }
  
  const ratio = (timestamp - before.ts) / (after.ts - before.ts);
  return {
    x: before.x + (after.x - before.x) * ratio,
    z: before.z + (after.z - before.z) * ratio
  };
}

/**
 * Advances all entities in the game world by the given time step
 */
function advanceAll(state: GameState, deltaTimeMs: number): void {
  // Process player movements
  for (const playerId in state.players) {
    const player = state.players[playerId];
    if (player.movement?.dest) {
      advancePosition(player, deltaTimeMs);
    }
  }
  
  // Process enemy logic, status effects, etc.
  for (const enemyId in state.enemies) {
    const enemy = state.enemies[enemyId];
    const now = Date.now();
    
    // Update position history for all enemies at each tick
    updatePositionHistory(enemy, now);
    enemy.lastUpdateTime = now;
    
    // Process enemy targeting and movement here
    if (enemy.isAlive && enemy.targetId) {
      const target = state.players[enemy.targetId];
      if (target && target.isAlive) {
        // Calculate target position prediction
        const targetPos = predictPosition(target, now);
        
        // Movement logic for enemy to follow target
        // (Simplified for now)
      }
    }
    
    // Process status effects (could be moved to a separate function)
    if (enemy.statusEffects.length > 0) {
      enemy.statusEffects = enemy.statusEffects.filter(effect => {
        return (effect.startTimeTs + effect.durationMs) > now;
      });
    }
  }
}

/**
 * Collects current position snapshots for all entities
 */
function collectSnaps(state: GameState, timestamp: number): PosSnap[] {
  const snaps: PosSnap[] = [];
  
  // Add player position snapshots
  for (const playerId in state.players) {
    const player = state.players[playerId];
    
    // Skip dead players
    if (!player.isAlive) continue;
    
    // Get predicted/current position
    const pos = predictPosition(player, timestamp);
    
    // Add velocity if moving, zero otherwise
    const vel = player.velocity || { x: 0, z: 0 };
    
    // Always include in snapshot if player has dirty velocity flag
    // or if player is moving (non-zero velocity)
    const shouldInclude = (player as any).dirtySnap || 
                         (vel.x !== 0 || vel.z !== 0) || 
                         player.movement?.dest !== null;
    
    if (shouldInclude) {
      snaps.push({
        id: playerId,
        pos,
        vel,
        ts: timestamp
      });
      
      // Clear the dirty flag after including in snapshot
      if ((player as any).dirtySnap) {
        (player as any).dirtySnap = false;
      }
    }
  }
  
  return snaps;
}

/**
 * Validates movement start requests
 */
function validateMoveStart(player: PlayerState, msg: MoveStart): boolean {
  // Validate player speed
  const MAX_SPEED = 30; // units per second
  if (msg.speed > MAX_SPEED) {
    console.warn(`Player ${player.id} attempted to move too fast: ${msg.speed} > ${MAX_SPEED}`);
    return false;
  }
  
  // Validate movement while dead
  if (!player.isAlive) {
    console.warn(`Dead player ${player.id} attempted to move`);
    return false;
  }
  
  // Wall/collision validation for the first path segment
  if (msg.path.length > 0) {
    const startPos = { x: player.position.x, z: player.position.z };
    const firstDest = msg.path[0];
    
    if (isPathBlocked(startPos, firstDest)) {
      console.warn(`Player ${player.id} attempted to move through an obstacle`);
      return false;
    }
  }
  
  return true;
}

/**
 * Handles MoveStart message
 */
function onMoveStart(socket: Socket, state: GameState, msg: MoveStart): void {
  const playerId = msg.id;
  const player = state.players[playerId];
  
  // Verify player exists and belongs to this socket
  if (!player || player.socketId !== socket.id) {
    console.warn(`Invalid player ID or wrong socket for MoveStart: ${playerId}`);
    return;
  }
  
  // Validate the move request
  if (!validateMoveStart(player, msg)) {
    return;
  }
  
  // Implement a cast-lock window to prevent "micro-teleport" exploits
  // If we just received a movement request, make the player wait one tick before another one takes effect
  const now = Date.now();
  if (player.lastUpdateTime && now - player.lastUpdateTime < 33) { // 33ms is approximately one tick at 30 FPS
    console.warn(`Movement request from player ${playerId} received too quickly, enforcing cast-lock window`);
    // Still process the request but apply a slight delay
  }
  
  // Determine destination from the path
  const destination = msg.path.length > 0 ? msg.path[0] : null;
  if (!destination) {
    console.warn(`Empty path in MoveStart from player ${playerId}`);
    return;
  }

  // Calculate direction and velocity
  const dir = calculateDir({ x: player.position.x, z: player.position.z }, destination);
  
  // Update player's movement state
  player.movement = {
    dest: destination,
    speed: msg.speed,
    startTs: now
  };
  
  // Set the velocity vector
  player.velocity = {
    x: dir.x * msg.speed,
    z: dir.z * msg.speed
  };
  
  // Update the last update time
  player.lastUpdateTime = now;
  
  // Update position history
  updatePositionHistory(player, now);
  
  // Instead of using socket.server.emit, we'll broadcast the message to all clients
  // We can use socket.broadcast.emit to send to all clients except the sender
  // or just use the io instance that's passed to the createWorld function
  socket.broadcast.emit('msg', msg);
}

/**
 * Handles MoveSync message
 */
function onMoveSync(socket: Socket, state: GameState, msg: MoveSync): void {
  const playerId = msg.id;
  const player = state.players[playerId];
  
  // Verify player exists and belongs to this socket
  if (!player || player.socketId !== socket.id) {
    return;
  }
  
  // Clamp clientTs to prevent lag-dodge exploits (can't rewrite the last 100ms)
  const now = Date.now();
  const MAX_SYNC_LAG_MS = 100;
  const clampedClientTs = Math.min(msg.clientTs, now - MAX_SYNC_LAG_MS);
  
  // Calculate the current server-side position
  const serverPos = predictPosition(player, now);
  
  // Calculate error between client and server positions
  const error = distance(serverPos, msg.pos);
  
  // If error is large, force correction
  if (error > 2.0) {
    console.warn(`Large position error for player ${playerId}: ${error} units. Correction applied.`);
    
    // Send a position snapshot to correct the client
    socket.emit('msg', {
      type: 'PosSnap',
      snaps: [{
        id: playerId,
        pos: serverPos,
        vel: player.velocity || { x: 0, z: 0 },
        snapTs: now
      }]
    });
  } 
  // For smaller errors, we could implement gradual reconciliation if needed
  
  // Update position history regardless of error
  updatePositionHistory(player, now);
}

/**
 * Handles CastReq message
 */
function onCastReq(socket: Socket, state: GameState, msg: CastReq): void {
  const playerId = msg.id;
  const player = state.players[playerId];
  
  // Verify player exists and belongs to this socket
  if (!player || player.socketId !== socket.id) {
    return;
  }
  
  if (!player.unlockedSkills.includes(msg.skillId as SkillType)) {
    console.warn(`Player ${playerId} tried to cast not owned skill: ${msg.skillId}`);
    socket.emit('msg', {
      type: 'CastFail',
      clientSeq: msg.clientTs,
      reason: 'invalid'
    });
    return;
  }
  
  // Use the skillManager to handle the cast request
  // Helper function to get enemy by ID
  const getEnemyById = (id: string) => state.enemies[id] || null;
  
  // Delegate to the skillManager
  handleCastReq(player, msg, socket, getEnemyById);
}

/**
 * Executes a skill's effects
 */
function executeSkillEffects(
  caster: PlayerState, 
  target: Enemy, 
  skillId: SkillType, 
  io: any,
  state: GameState
): void {
  if (!target || !target.isAlive) return;
  
  // Get skill from the shared/skills.ts file if available
  const sharedSkill = SKILLS[skillId as SkillId];
  const skill = SKILLS[skillId as SkillId];
  
  // Launch appropriate effect based on skill category from shared definition if available
  if (sharedSkill) {
    if (sharedSkill.cat === 'projectile') {
      const casterPos = { x: caster.position.x, z: caster.position.z };
      const targetPos = { x: target.position.x, z: target.position.z };
      const dir = calculateDir(casterPos, targetPos);
      
      // Spawn projectile using the effect manager
      effects.spawnProjectile(sharedSkill.id, caster, dir, target.id);
    } else if (sharedSkill.cat === 'instant') {
      // Spawn instant effect using the effect manager
      effects.spawnInstant(sharedSkill.id, caster, [target.id]);
    }
  }
  
  // Handle area of effect damage
  if (skill.area && skill.area > 0) {
    Object.values(state.enemies).forEach(enemy => {
      // Skip primary target (already damaged) and dead enemies
      if (enemy.id === target.id || !enemy.isAlive) return;
      
      // Check if enemy is within AoE radius
      const dist = distance(
        { x: target.position.x, z: target.position.z },
        { x: enemy.position.x, z: enemy.position.z }
      );
      
      if (dist <= skill.area!) {
        // Apply AoE damage
        enemy.health = Math.max(0, enemy.health - (skill.dmg || 0));
        
        // Handle death
        if (enemy.health === 0) {
          enemy.isAlive = false;
          enemy.deathTimeTs = Date.now();
          enemy.targetId = null;
          
          // Remove from spatial hash grid
          spatial.remove(enemy.id, { x: enemy.position.x, z: enemy.position.z });
          
          // Grant experience to the player
          caster.experience += enemy.experienceValue;
        }
        
        // Broadcast enemy update for AoE targets
        io.emit('enemyUpdated', enemy);
      }
    });
  }
  
  // Apply status effect
  if (skill.effects && skill.effects.length > 0) {
    for (const effect of skill.effects) {
      // Skip effects without a duration
      if (!effect.durationMs) continue;
      
      const now = Date.now();
      
      // Use the new effectRunner for direct skill effects
      effectRunner.add(
        target,           // target entity
        caster,           // source entity
        effect.type as any, // effect type as EffectId
        hash(`${skillId}:${target.id}:${now}`) // consistent seed for deterministic effect calculations
      );
    }
  }
  
  // Broadcast updates
  io.emit('enemyUpdated', target);
  io.emit('playerUpdated', caster);
  
  // Emit skillEffect event for visual effects (legacy support)
  // TODO: Remove this legacy skillEffect emission after client PR-3 is merged
  io.emit('skillEffect', {
    skillId,
    sourceId: caster.id,
    targetId: target.id
  });
}

/**
 * Initialize the game world
 */
// Create an effects variable at module scope
let effects: EffectManager;
// Create a spatial hash grid at module scope
let spatial: SpatialHashGrid;

export function initWorld(io: Server, zoneManager: ZoneManager) {
  // Initialize game state
  const state: GameState = {
    players: {},
    enemies: {},
    projectiles: [],
    lastProjectileId: 0
  };
  
  // Initialize effect manager
  effects = new EffectManager(io, state);
  
  // Initialize the spatial hash grid
  spatial = new SpatialHashGrid();
  
  // Spawn initial enemies
  spawnInitialEnemies(state, zoneManager);
  
  // Game loop settings
  const TICK = 1000 / 30; // 30 FPS / Hz world tick rate
  const SNAP_HZ = 10;     // 10 Hz position snapshots
  let snapAccumulator = 0;
  
  // Start game loop
  setInterval(() => {
    const now = Date.now();
    
    // Step 1: Advance all entity states
    advanceAll(state, TICK);
    
    // Step 2: Update all effects
    effects.updateAll(TICK/1000); // convert to seconds
    
    // Step 3: Process status effects with our new effectRunner
    effectRunner.setGameState(state);
    effectRunner.tick(TICK/1000, (effectMsg) => {
      io.emit('msg', effectMsg);
    });
    
    // Step 4: Update skill casting progress
    updateCasts(io, state.players);
    
    // Step 4: Process completed casts
    const completedCasts = getCompletedCasts();
    completedCasts.forEach(cast => {
      // Find the player and target
      const player = state.players[cast.id];
      const targetId = cast.targetId;
      const target = targetId ? state.enemies[targetId] : null;
      
      // Execute the skill if target exists
      if (player && target) {
        executeSkillEffects(player, target, cast.skillId, io, state);
      }
    });
    
    // Step 5: Update all projectiles
    if (state.projectiles.length > 0) {
      updateProjectiles(state, TICK/1000, io);
    }
    
    // Step 5: Generate and broadcast PosSnap at the target rate
    snapAccumulator += 1;
    if (snapAccumulator >= 30 / SNAP_HZ) {
      const snaps = collectSnaps(state, now);
      if (snaps.length > 0) {
        io.emit('msg', {
          type: 'PosSnap',
          snaps
        });
      }
      snapAccumulator = 0;
    }
    
    // Step 5: Process mana regeneration (less frequent)
    if (snapAccumulator === 1) {
      handleManaRegeneration(state, io);
    }
    
    // Step 6: Process enemy respawns (even less frequent)
    if (snapAccumulator === 2) {
      handleEnemyRespawns(state, io);
    }
  }, TICK);
  
  // Return public API
  return {
    handleMessage(socket: Socket, msg: ClientMsg) {
      switch (msg.type) {
        case 'MoveStart': return onMoveStart(socket, state, msg as MoveStart);
        case 'MoveSync': return onMoveSync(socket, state, msg as MoveSync);
        case 'CastReq': return onCastReq(socket, state, msg as CastReq);
        case 'LearnSkill': return onLearnSkill(socket, state, msg as LearnSkill);
        case 'SetSkillShortcut': return onSetSkillShortcut(socket, state, msg as SetSkillShortcut);
      }
    },
    
    getGameState() {
      return state;
    },
    
    getEntitiesInCircle(pos: VecXZ, radius: number) {
      // Use spatial hash grid to get entity IDs within the circle
      const entityIds = spatial.queryCircle(pos, radius);
      
      // Convert IDs back to entities
      return entityIds.map(id => {
        // Check if it's a player
        if (id in state.players && state.players[id].isAlive) {
          return state.players[id];
        }
        // Check if it's an enemy
        if (id in state.enemies && state.enemies[id].isAlive) {
          return state.enemies[id];
        }
        return null;
      }).filter(Boolean); // Remove null entries
    },
    
    // Expose the spatial grid for direct access
    spatial,
    
    addPlayer(socketId: string, name: string) {
      const playerId = `player-${hash(socketId + Date.now().toString())}`;
      
      const player: PlayerState = {
        id: playerId,
        socketId,
        name,
        position: { x: 0, y: 0.5, z: 0 },
        rotation: { x: 0, y: 0, z: 0 },
        health: 100,
        maxHealth: 100,
        mana: 100,
        maxMana: 100,
        level: 2,
        experience: 0,
        experienceToNextLevel: 100,
        statusEffects: [],
        skillCooldownEndTs: {},
        cooldowns: {}, // Alias for skillCooldownEndTs
        castingSkill: null,
        castingProgressMs: 0,
        isAlive: true,
        className: 'mage', // Default class
        unlockedSkills: ['fireball'], // Start with fireball
        skillShortcuts: ['fireball', null, null, null, null, null, null, null, null], // Assign fireball to shortcut 1
        availableSkillPoints: 1, // Give the player 1 skill point to start
        posHistory: [], // Initialize position history
        lastUpdateTime: Date.now()
      };
      
      state.players[playerId] = player;
      
      // Add player to spatial hash grid
      spatial.insert(playerId, { x: player.position.x, z: player.position.z });
      
      return player;
    },
    
    removePlayerBySocketId(socketId: string) {
      const playerId = Object.keys(state.players).find(
        id => state.players[id].socketId === socketId
      );
      
      if (playerId) {
        // Get player position before removing
        const player = state.players[playerId];
        const pos = { x: player.position.x, z: player.position.z };
        
        // Remove player from spatial hash grid
        spatial.remove(playerId, pos);
        
        // Remove player from state
        delete state.players[playerId];
        
        return playerId;
      }
      
      return null;
    }
  };
}

/**
 * Helper to spawn initial enemies
 */
function spawnInitialEnemies(state: GameState, zoneManager: ZoneManager) {
  const GAME_ZONES = zoneManager.getZones();
  
  GAME_ZONES.forEach((zone) => {
    const mobsToSpawn = zoneManager.getMobsToSpawn(zone.id);
    mobsToSpawn.forEach((mobConfig) => {
      const { type, count } = mobConfig;
      for (let i = 0; i < count; i++) {
        const position = zoneManager.getRandomPositionInZone(zone.id);
        if (!position) continue;

        const enemyId = `${type}-${hash(`${type}-${Date.now()}-${position.x}-${position.z}`).toString(36).substring(0, 9)}`;
        const level = zoneManager.getMobLevel(zone.id);

        state.enemies[enemyId] = {
          id: enemyId,
          type,
          name: type.charAt(0).toUpperCase() + type.slice(1),
          level,
          position,
          spawnPosition: { ...position },
          rotation: { x: 0, y: rng(hash(`rotation-${Date.now()}-${position.x}-${position.z}`))() * Math.PI * 2, z: 0 },
          health: 100 + (level * 20),
          maxHealth: 100 + (level * 20),
          isAlive: true,
          attackDamage: 10 + (level * 2),
          attackRange: 2,
          baseExperienceValue: 50 + (level * 10),
          experienceValue: 50 + (level * 10),
          statusEffects: [],
          targetId: null,
        };
        
        // Add enemy to spatial hash grid
        spatial.insert(enemyId, { x: position.x, z: position.z });
      }
    });
  });
}

/**
 * Awards XP to a player and handles level ups
 * @param player The player to award XP to
 * @param xpAmount Amount of XP to award
 * @param sourceInfo Information about the source of XP (for logging)
 * @param io Server instance for broadcasting updates
 */
export function awardPlayerXP(player: PlayerState, xpAmount: number, sourceInfo: string, io: Server): void {
  const oldExp = player.experience;
  player.experience += xpAmount;
  log(LOG_CATEGORIES.PLAYER, `Player ${player.id} gained ${xpAmount} XP from ${sourceInfo}. XP: ${oldExp} -> ${player.experience}`);
  
  // Check for level up
  if (player.experience >= player.experienceToNextLevel) {
    player.level += 1;
    const oldMaxExp = player.experienceToNextLevel;
    player.experience -= player.experienceToNextLevel; // Keep excess XP
    player.experienceToNextLevel = Math.floor(oldMaxExp * 1.5); // 50% more XP needed for next level
    log(LOG_CATEGORIES.PLAYER, `Player ${player.id} leveled up to level ${player.level}! Next level at ${player.experienceToNextLevel} XP`);
    
    // Increase max health and mana with level
    player.maxHealth = 100 + (player.level - 1) * 20;
    player.maxMana = 100 + (player.level - 1) * 10;
    
    // Heal player on level up
    player.health = player.maxHealth;
    player.mana = player.maxMana;
    
    // Award a skill point on level up
    player.availableSkillPoints += 1;
    log(LOG_CATEGORIES.PLAYER, `Player ${player.id} gained a skill point. Total: ${player.availableSkillPoints}`);
  }
  
  // Broadcast the updated player state so clients see XP and level changes
  io.emit('playerUpdated', {
    id: player.id,
    experience: player.experience,
    experienceToNextLevel: player.experienceToNextLevel,
    level: player.level,
    maxHealth: player.maxHealth,
    health: player.health,
    maxMana: player.maxMana,
    mana: player.mana,
    availableSkillPoints: player.availableSkillPoints
  });
}

/**
 * Spawns a projectile in the world
 */
function spawnProjectile(
  state: GameState,
  casterId: string,
  skillId: SkillId,
  pos: VecXZ,
  dir: VecXZ,
  speed: number,
  targetId?: string
): Projectile {
  const projectileId = `proj_${state.lastProjectileId++}`;
  
  // Offset the initial position slightly in the direction of travel
  // This helps avoid collisions with the caster when spawning projectiles
  const offsetDistance = 0.5; // Small offset to move projectile away from caster
  const initialPos = {
    x: pos.x + dir.x * offsetDistance,
    z: pos.z + dir.z * offsetDistance
  };
  
  const projectile: Projectile = {
    id: projectileId,
    casterId,
    skillId,
    pos: { ...initialPos },
    dir: { ...dir },
    speed,
    spawnTs: Date.now(),
    targetId,
    hitTargets: [],
    hitCount: 0
  };
  
  console.log(`[PROJECTILE] Created new projectile: id=${projectileId}, skill=${skillId}, pos=(${initialPos.x.toFixed(2)}, ${initialPos.z.toFixed(2)}), dir=(${dir.x.toFixed(2)}, ${dir.z.toFixed(2)}), speed=${speed}, targetId=${targetId || 'none'}`);
  
  state.projectiles.push(projectile);
  
  return projectile;
}

/**
 * Updates all projectiles in the game
 */
function updateProjectiles(state: GameState, dt: number, io: Server): void {
  const projectilesToRemove: number[] = [];
  
  // Process each projectile
  for (let i = 0; i < state.projectiles.length; i++) {
    const p = state.projectiles[i];
    
    // Calculate new position using linear movement
    const oldPos = { ...p.pos };
    p.pos.x += p.dir.x * p.speed * dt;
    p.pos.z += p.dir.z * p.speed * dt;
    
    // Debug log for projectile movement
    log(LOG_CATEGORIES.PROJECTILE, `Projectile ${p.id} moved from (${oldPos.x.toFixed(2)}, ${oldPos.z.toFixed(2)}) to (${p.pos.x.toFixed(2)}, ${p.pos.z.toFixed(2)}) with speed ${p.speed}`);
    
    // Check for collisions with players and enemies
    let hit = false;
    const hitTargets: string[] = [];
    
    log(LOG_CATEGORIES.PROJECTILE, `Checking collisions for projectile at (${p.pos.x.toFixed(2)}, ${p.pos.z.toFixed(2)})`);
    
    // Check collision against enemies
    for (const enemyId in state.enemies) {
      const enemy = state.enemies[enemyId];
      if (!enemy.isAlive) continue;
      
      // Skip if this enemy is the caster
      if (enemyId === p.casterId) continue;
      
      // Get enemy position at the time of projectile movement for accurate hit detection
      const timeOfCheck = Date.now();
      const enemyPos = getPositionAtTime(enemy, timeOfCheck);
      
      // Add debug info for distance to enemy
      const distToEnemy = Math.sqrt(
        Math.pow(p.pos.x - enemyPos.x, 2) + 
        Math.pow(p.pos.z - enemyPos.z, 2)
      );
      
      log(LOG_CATEGORIES.PROJECTILE, `Distance to enemy ${enemyId}: ${distToEnemy.toFixed(2)}, enemy pos: (${enemyPos.x.toFixed(2)}, ${enemyPos.z.toFixed(2)})`);
      
      // Get the configured hit radius from the skill definition
      const skill = SKILLS[p.skillId];
      const configuredHitRadius = skill?.projectile?.hitRadius || 1.0;
      
      // Improved hit detection with both distance check and swept hit
      // Uses hit radius from skill config
      const isDirectHit = distToEnemy <= configuredHitRadius * 2.0; // Direct hit can be more generous
      const isSweptHit = sweptHit(oldPos, p.pos, enemyPos, configuredHitRadius);
      
      // Skip this enemy if it's already been hit by this projectile (for piercing projectiles)
      if (p.hitTargets && p.hitTargets.includes(enemyId)) {
        log(LOG_CATEGORIES.PROJECTILE, `Skipping enemy ${enemyId} - already hit by this projectile`);
        continue;
      }
      
      if (isDirectHit || isSweptHit) {
        log(LOG_CATEGORIES.PROJECTILE, `HIT enemy ${enemyId}! Distance: ${distToEnemy.toFixed(2)}, Direct hit: ${isDirectHit}, Swept hit: ${isSweptHit}`);
        hit = true;
        hitTargets.push(enemyId);
        
        // Apply skill effect
        const skill = SKILLS[p.skillId];
        if (skill) {
          // Apply damage to the enemy
          if (skill.dmg) {
            const oldHealth = enemy.health;
            enemy.health -= skill.dmg;
            log(LOG_CATEGORIES.DAMAGE, `Enemy ${enemyId} took ${skill.dmg} damage from projectile ${p.id}. Health: ${oldHealth} -> ${enemy.health}`);
            
            if (enemy.health <= 0) {
              enemy.health = 0;
              enemy.isAlive = false;
              enemy.deathTimeTs = Date.now();
              enemy.targetId = null;
              log(LOG_CATEGORIES.ENEMY, `Enemy ${enemyId} was killed by projectile ${p.id}`);
              
              // Remove enemy from spatial hash grid
              spatial.remove(enemyId, { x: enemy.position.x, z: enemy.position.z });
              
              // Give XP to the player who cast the projectile
              const caster = state.players[p.casterId];
              if (caster) {
                awardPlayerXP(caster, enemy.experienceValue || 0, `killing enemy ${enemyId}`, io);
              }
            }
          }
          
          // Apply status effects if defined
          if (skill.effects && skill.effects.length > 0) {
            for (const effect of skill.effects) {
              // Skip effects without a duration
              if (!effect.durationMs) continue;
              
              const now = Date.now();
              
              // Use the new effectRunner instead of directly pushing to status effects
              effectRunner.add(
                enemy,                  // target entity 
                state.players[p.casterId], // source entity
                effect.type as any,     // effect type as EffectId
                hash(`${p.id}:${enemyId}:${now}`)  // consistent seed for deterministic effect calculations
              );
            }
          }
          
          // Broadcast enemy update
          io.emit('enemyUpdated', enemy);
        }
        
        // Important: Break out of the enemy loop after a hit to ensure we stop checking more enemies
        break;
      }
    }
    
    // Check collision against players (if PvP is enabled)
    for (const playerId in state.players) {
      const player = state.players[playerId];
      if (!player.isAlive) continue;
      
      // Skip if this player is the caster
      if (playerId === p.casterId) continue;
      
      // Get player position at the exact time of projectile movement for more accurate hit detection
      const timeOfCheck = Date.now();
      const playerPos = player.posHistory && player.posHistory.length > 0 
                      ? getPositionAtTime(player, timeOfCheck) 
                      : { x: player.position.x, z: player.position.z };
      
      // Calculate distance to player
      const distToPlayer = Math.sqrt(
        Math.pow(p.pos.x - playerPos.x, 2) + 
        Math.pow(p.pos.z - playerPos.z, 2)
      );
      
      // Get the configured hit radius from the skill definition
      const skill = SKILLS[p.skillId];
      const configuredHitRadius = skill?.projectile?.hitRadius || 0.8; // Default slightly smaller for PvP
      
      // Skip this player if it's already been hit by this projectile (for piercing projectiles)
      if (p.hitTargets && p.hitTargets.includes(playerId)) {
        log(LOG_CATEGORIES.PROJECTILE, `Skipping player ${playerId} - already hit by this projectile`);
        continue;
      }
      
      // Improved hit detection with both distance check and swept hit
      const isDirectHit = distToPlayer <= configuredHitRadius * 1.5; // Direct hit can be more generous
      const isSweptHit = sweptHit(oldPos, p.pos, playerPos, configuredHitRadius);
      
      if (isDirectHit || isSweptHit) {
        log(LOG_CATEGORIES.PROJECTILE, `HIT player ${playerId}! Distance: ${distToPlayer.toFixed(2)}, Direct hit: ${isDirectHit}, Swept hit: ${isSweptHit}`);
        hit = true;
        hitTargets.push(playerId);
        
        // Apply skill effect to player
        // (Add PvP damage logic here if needed)
        
        // Important: Break out of the player loop after a hit
        break;
      }
    }
    
    // Handle hit effects
    if (hit && hitTargets.length > 0) {
      log(LOG_CATEGORIES.PROJECTILE, `Hit detected with ${hitTargets.length} targets, processing hit`);
      
      // Initialize hit targets array if not already present
      if (!p.hitTargets) {
        p.hitTargets = [];
      }
      
      // Track hit count
      p.hitCount = (p.hitCount || 0) + hitTargets.length;
      
      // Add new hit targets to the tracking array
      hitTargets.forEach(targetId => {
        if (!p.hitTargets?.includes(targetId)) {
          p.hitTargets.push(targetId);
        }
      });
      
      // Emit hit event
      io.emit('msg', {
        type: 'ProjHit2',
        castId: p.id,
        hitIds: hitTargets,
        dmg: hitTargets.map(targetId => {
          const { dmg } = getDamage({
            caster: state.players[p.casterId]?.stats ?? {},
            skill: { base: skill?.dmg || 10, variance: 0.1 },
            seed: `${p.id}:${targetId}`
          });
          return dmg;
        }),
        impactPos: { x: p.pos.x, z: p.pos.z }
      });
      
      // Check if the skill has splash damage
      const skill = SKILLS[p.skillId];
      if (skill?.projectile?.splashRadius) {
        const splashRadius = skill.projectile.splashRadius;
        const splashTargets: string[] = [];
        
        // Check all enemies for splash damage
        for (const enemyId in state.enemies) {
          const enemy = state.enemies[enemyId];
          if (!enemy.isAlive || hitTargets.includes(enemyId)) continue; // Skip dead enemies or already hit
          
          // Skip enemies already hit by this projectile
          if (p.hitTargets.includes(enemyId)) {
            continue;
          }
          
          const enemyPos = { x: enemy.position.x, z: enemy.position.z };
          const distToEnemy = Math.sqrt(
            Math.pow(p.pos.x - enemyPos.x, 2) + 
            Math.pow(p.pos.z - enemyPos.z, 2)
          );
          
          if (distToEnemy <= splashRadius) {
            splashTargets.push(enemyId);
            
            // Apply splash damage to the enemy with distance-based fall-off
            if (skill.dmg) {
              // Calculate damage fall-off based on distance
              // 100% damage at direct hit, scaling down to 25% at max splash radius
              const distanceFactor = 1 - (distToEnemy / splashRadius * 0.75);
              const splashDamage = Math.floor(skill.dmg * distanceFactor);
              
              // Track hit
              p.hitTargets.push(enemyId);
              p.hitCount += 1;
              
              const oldHealth = enemy.health;
              enemy.health -= splashDamage;
              log(LOG_CATEGORIES.DAMAGE, `Enemy ${enemyId} took ${splashDamage} splash damage from projectile ${p.id}. Distance: ${distToEnemy.toFixed(2)}, fall-off: ${(distanceFactor * 100).toFixed(0)}%. Health: ${oldHealth} -> ${enemy.health}`);
              
              if (enemy.health <= 0) {
                enemy.health = 0;
                enemy.isAlive = false;
                enemy.deathTimeTs = Date.now();
                enemy.targetId = null;
                log(LOG_CATEGORIES.ENEMY, `Enemy ${enemyId} was killed by splash from projectile ${p.id}`);
                
                // Remove enemy from spatial hash grid
                spatial.remove(enemyId, { x: enemy.position.x, z: enemy.position.z });
                
                // Give XP to the player who cast the projectile
                const caster = state.players[p.casterId];
                if (caster) {
                  awardPlayerXP(caster, enemy.experienceValue || 0, `splash killing enemy ${enemyId}`, io);
                }
              }
              
              // Apply status effects if defined
              if (skill.effects && skill.effects.length > 0) {
                for (const effect of skill.effects) {
                  // Skip effects without a duration
                  if (!effect.durationMs) continue;
                  
                  const effectId = `effect-${hash(`${effect.type}-${now}-${enemyId}`).toString(36).substring(0, 9)}`;
                  enemy.statusEffects.push({
                    id: effectId,
                    type: effect.type,
                    value: effect.value,
                    durationMs: effect.durationMs,
                    startTimeTs: Date.now(),
                    sourceSkill: p.skillId
                  });
                }
              }
              
              // Broadcast enemy update
              io.emit('enemyUpdated', enemy);
            }
          }
        };
        
        // Emit a separate hit event for splash targets
        if (splashTargets.length > 0) {
          log(LOG_CATEGORIES.PROJECTILE, `Projectile ${p.id} hit ${splashTargets.length} targets with splash damage`);
          io.emit('msg', {
            type: 'ProjHit2',
            castId: p.id,
            hitIds: splashTargets,
            dmg: splashTargets.map(targetId => {
              const { dmg } = getDamage({
                caster: state.players[p.casterId]?.stats ?? {},
                skill: { 
                  base: (skill?.dmg || 10) * (skill?.projectile?.splashDamagePct || 0.5), 
                  variance: 0.1 
                },
                seed: `${p.id}:splash:${targetId}`
              });
              return dmg;
            }),
            impactPos: { x: p.pos.x, z: p.pos.z }
          });
        }
      }
      
      // Check for piercing - continue flight if piercing is true
      if (skill?.projectile?.pierce) {
        // Get the max number of hits for this piercing projectile
        const maxPierceHits = skill.projectile.maxPierceHits || Number.MAX_SAFE_INTEGER;
        
        // Check if we've hit the maximum number of targets already
        if (p.hitCount >= maxPierceHits) {
          log(LOG_CATEGORIES.PROJECTILE, `Projectile ${p.id} reached max pierce hits (${p.hitCount}/${maxPierceHits}), removing`);
          
          // Tell clients to despawn it
          io.emit('msg', {
            type: 'ProjHit2',
            castId: p.id,
            hitIds: [],
            dmg: [],
            impactPos: { x: p.pos.x, z: p.pos.z }
          });
          
          // Mark for removal and skip further processing for this projectile
          projectilesToRemove.push(i);
          continue; // Skip the TTL check
        }
        
        log(LOG_CATEGORIES.PROJECTILE, `Projectile ${p.id} has pierce property, continuing flight (hits: ${p.hitCount || 0}/${maxPierceHits})`);
      } else {
        // Also tell clients to despawn it immediately for non-piercing projectiles
        io.emit('msg', {
          type: 'ProjHit2',
          castId: p.id,
          hitIds: [],
          dmg: [],
          impactPos: { x: p.pos.x, z: p.pos.z }
        });
        
        // Mark for removal and skip further processing for this projectile
        projectilesToRemove.push(i);
        continue; // Skip the TTL check
      }
    }
    
    // Check TTL (Time To Live) - 4 seconds max lifetime
    const now = Date.now();
    if (now - p.spawnTs > 4000) {
      log(LOG_CATEGORIES.PROJECTILE, `Projectile ${p.id} expired by TTL after ${((now - p.spawnTs)/1000).toFixed(1)}s`);
      io.emit('msg', {
        type: 'ProjHit2',
        castId: p.id,
        hitIds: [],
        dmg: [],
        impactPos: { x: p.pos.x, z: p.pos.z }
      });
      
      projectilesToRemove.push(i);
    }
  }
  
  // Remove projectiles that hit or expired (remove from end to start to avoid index issues)
  if (projectilesToRemove.length > 0) {
    log(LOG_CATEGORIES.PROJECTILE, `Removing ${projectilesToRemove.length} projectiles`);
    for (let i = projectilesToRemove.length - 1; i >= 0; i--) {
      const index = projectilesToRemove[i];
      const p = state.projectiles[index];
      log(LOG_CATEGORIES.PROJECTILE, `Projectile ${p.id} removed from world`);
      state.projectiles.splice(index, 1);
    }
  }
}

/**
 * Handle mana regeneration for all players
 */
function handleManaRegeneration(state: GameState, io: Server) {
  const MANA_REGEN_PER_SECOND = 2;
  
  for (const playerId in state.players) {
    const player = state.players[playerId];
    if (player.isAlive && player.mana < player.maxMana) {
      const oldMana = player.mana;
      // Since this function is called less frequently than the old system,
      // we regenerate more mana per call to achieve the same rate over time
      player.mana = Math.min(player.maxMana, player.mana + MANA_REGEN_PER_SECOND);
      
      // Only broadcast if mana actually changed (avoiding precision issues)
      if (Math.abs(player.mana - oldMana) > 0.01) {
        // Broadcast mana update to all clients
        io.emit('playerUpdated', {
          id: player.id,
          mana: player.mana
        });
      }
    }
  }
}

/**
 * Handle enemy respawns
 */
function handleEnemyRespawns(state: GameState, io: Server) {
  const now = Date.now();
  
  for (const enemyId in state.enemies) {
    const enemy = state.enemies[enemyId];
    
    if (!enemy.isAlive && enemy.deathTimeTs) {
      const timeSinceDeath = now - enemy.deathTimeTs;
      if (timeSinceDeath >= 30000) { // 30 seconds respawn time
        enemy.isAlive = true;
        enemy.health = enemy.maxHealth;
        enemy.position = { ...enemy.spawnPosition };
        enemy.targetId = null;
        enemy.statusEffects = [];
        
        // Re-add enemy to spatial hash grid upon respawn
        spatial.insert(enemyId, { x: enemy.position.x, z: enemy.position.z });
        
        io.emit('enemyUpdated', enemy);
      }
    }
  }
}


// ==============================================================================
// FILE: shared/classSystem.ts
// ==============================================================================

// filepath: /home/s/develop/projects/vibe/1/shared/classSystem.ts
import { SkillId } from './skillsDefinition';

// Class types in the game
export type CharacterClass = 'mage' | 'warrior' | 'healer' | 'ranger';

// Interface for requirements to unlock skills
export interface SkillRequirement {
  level: number;
  classType?: CharacterClass; // If specified, skill is only available to this class
  requiredSkills?: SkillId[]; // Skills that must be learned before this one
}

// Class-specific skill progression tree
export interface ClassSkillTree {
  className: CharacterClass;
  description: string;
  baseStats: {
    healthMultiplier: number;
    manaMultiplier: number;
    damageMultiplier: number;
    speedMultiplier: number;
  };
  skillProgression: Record<SkillId, SkillRequirement>;
}

// Define skill trees for each class
export const CLASS_SKILL_TREES: Record<CharacterClass, ClassSkillTree> = {
  mage: {
    className: 'mage',
    description: 'Masters of elemental magic with high damage output but lower health',
    baseStats: {
      healthMultiplier: 0.8,
      manaMultiplier: 1.3,
      damageMultiplier: 1.2,
      speedMultiplier: 0.9
    },
    skillProgression: {
      'fireball': { level: 1 },  // Available immediately
      'waterSplash': { level: 2, requiredSkills: ['fireball'] },
      'iceBolt': { level: 3, requiredSkills: ['waterSplash'] },
      'petrify': { level: 4, requiredSkills: ['iceBolt'] }
    }
  },
  warrior: {
    className: 'warrior',
    description: 'Strong melee fighters with high health and defensive capabilities',
    baseStats: {
      healthMultiplier: 1.3,
      manaMultiplier: 0.7,
      damageMultiplier: 1.1,
      speedMultiplier: 1.0
    },
    skillProgression: {
      'fireball': { level: 2 }, // Warriors get fireball later
      'petrify': { level: 3 }
    }
  },
  healer: {
    className: 'healer',
    description: 'Support characters focused on healing and buffs',
    baseStats: {
      healthMultiplier: 0.9,
      manaMultiplier: 1.2,
      damageMultiplier: 0.8,
      speedMultiplier: 1.0
    },
    skillProgression: {
      'waterSplash': { level: 1 },
      'iceBolt': { level: 3 }
    }
  },
  ranger: {
    className: 'ranger',
    description: 'Long-range attackers with high speed and moderate damage',
    baseStats: {
      healthMultiplier: 0.9,
      manaMultiplier: 1.0,
      damageMultiplier: 1.1,
      speedMultiplier: 1.2
    },
    skillProgression: {
      'iceBolt': { level: 1 },
      'fireball': { level: 2 },
      'petrify': { level: 4 }
    }
  }
};

// Check if a player can learn a specific skill
export function canLearnSkill(
  skillId: SkillId, 
  playerClass: CharacterClass, 
  playerLevel: number, 
  playerSkills: SkillId[]
): boolean {
  const classTree = CLASS_SKILL_TREES[playerClass];
  if (!classTree) return false;
  
  const skillReq = classTree.skillProgression[skillId];
  if (!skillReq) return false; // Skill not available for this class
  
  // Check level requirement
  if (playerLevel < skillReq.level) return false;
  
  // Check prerequisite skills
  if (skillReq.requiredSkills) {
    for (const reqSkill of skillReq.requiredSkills) {
      if (!playerSkills.includes(reqSkill)) return false;
    }
  }
  
  return true;
}

// Get available skills to learn based on player's class, level and current skills
export function getAvailableSkills(
  playerClass: CharacterClass,
  playerLevel: number,
  playerSkills: SkillId[]
): SkillId[] {
  const classTree = CLASS_SKILL_TREES[playerClass];
  if (!classTree) return [];
  
  const availableSkills: SkillId[] = [];
  
  Object.entries(classTree.skillProgression).forEach(([skillId, req]) => {
    const skill = skillId as SkillId;
    // Skip skills player already has
    if (playerSkills.includes(skill)) return;
    
    // Check if player can learn this skill
    if (canLearnSkill(skill, playerClass, playerLevel, playerSkills)) {
      availableSkills.push(skill);
    }
  });
  
  return availableSkills;
}


// ==============================================================================
// FILE: shared/combatMath.ts
// ==============================================================================

import { SkillId, SKILLS } from './skillsDefinition';

/**
 * Calculate the mana cost of a skill, accounting for potential changes from player stats
 * @param skillId The skill ID
 * @param playerLevel Current player level
 * @returns Mana cost for the skill
 */
export function getManaCost(skillId: SkillId, playerLevel: number): number {
  const skill = SKILLS[skillId];
  if (!skill) return 0;
  
  const baseCost = skill.manaCost;
  
  return baseCost;
}

/**
 * Calculate the cooldown of a skill, accounting for potential changes from player stats
 * @param skillId The skill ID
 * @param playerLevel Current player level
 * @returns Cooldown time in milliseconds
 */
export function getCooldownMs(skillId: SkillId, playerLevel: number): number {
  const skill = SKILLS[skillId];
  if (!skill) return 0;
  
  const baseCooldown = skill.cooldownMs;

  return baseCooldown;
}

/** xorshift32  enough for crit & variability, seed != 0 */
export function rng(seed: number): () => number {
  let x = seed >>> 0;
  return () => {
    x ^= x << 13; x ^= x >>> 17; x ^= x << 5;
    return (x >>> 0) / 0xffffffff;
  };
}

/**
 * Simple FNV-1a hash implementation to convert strings to numbers
 * @param str String to hash
 * @returns 32-bit number hash
 */
export function hash(str: string): number {
  let h = 2166136261 >>> 0; // FNV offset basis
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619); // FNV prime
  }
  return h >>> 0;
}

/**
 * Specialized RNG for status effects with a unique hash seed
 * @param seed The base seed to use
 * @returns Random number generator function
 */
export function effectRng(seed: number) {
  return rng(seed ^ 0xEFFECC);
}

export interface DamageOpts {
  caster: { dmgMult?: number; critChance?: number; critMult?: number };
  skill:  { base: number; variance?: number }; // variance , default 0.1
  seed:   string;                              // castId + targetId
}

export function getDamage(opts: DamageOpts): { dmg: number; crit: boolean } {
  const { caster, skill, seed } = opts;
  const roll = rng(hash(seed))();              // 01 uniform
  const variance = 1 + (roll * 2 - 1) * (skill.variance ?? 0.1);
  const critRoll = rng(hash(seed) ^ 0x9e3779b9)();
  const crit = critRoll < (caster.critChance ?? 0);
  const critMult = crit ? (caster.critMult ?? 2) : 1;
  const dmg = skill.base * variance * (caster.dmgMult ?? 1) * critMult;
  return { dmg: Math.round(dmg), crit };
}


// ==============================================================================
// FILE: shared/constants.ts
// ==============================================================================

// Protocol version - bump when making changes to message formats
export const PROTOCOL_VERSION = '0.6.1';

// Game constants
export const DEFAULT_GROUND_Y = 0;
export const DEFAULT_PLAYER_HEIGHT = 1.8;
export const DEFAULT_GRAVITY = 9.8;

// Network constants
export const MAX_SYNC_LAG_MS = 100; // Maximum lag allowed for sync
export const POSITION_CORRECTION_THRESHOLD = 2.0; // Distance in meters
// Protocol version - bump when making changes to message formats
export const PROTOCOL_VERSION = '0.6.1';

// Game constants
export const DEFAULT_GROUND_Y = 0;
export const DEFAULT_PLAYER_HEIGHT = 1.8;
export const DEFAULT_GRAVITY = 9.8;

// Network constants
export const MAX_SYNC_LAG_MS = 100; // Maximum lag allowed for sync
export const POSITION_CORRECTION_THRESHOLD = 2.0; // Distance in meters

// ==============================================================================
// FILE: shared/effectsDefinition.ts
// ==============================================================================

import { rng } from './combatMath.js';

export type EffectId = 'burn' | 'bleed' | 'regen';

export interface EffectTick {
  value: number;      // Damage/healing amount
  type: 'damage' | 'healing' | 'mana' | 'stat'; // Effect type
}

export interface EffectDef {
  tickMs: number;     // How often the effect ticks
  durationMs: number; // Total duration
  maxStacks: number;  // Maximum number of stacks
  apply(o: {level: number; int: number; seed: number}): EffectTick;
}

export const EFFECTS: Record<EffectId, EffectDef> = {
  burn: {
    tickMs: 1000,     // Tick every second
    durationMs: 8000, // Last for 8 seconds
    maxStacks: 3,     // Max 3 stacks
    apply({ level, int, seed }): EffectTick {
      const random = rng(seed);
      const baseDamage = 8 + level * 2; // Base damage scales with level
      const variance = 0.2; // 20% variance
      const actualDamage = baseDamage * (1 + (random() * 2 - 1) * variance);
      
      return {
        value: Math.round(actualDamage * (1 + int * 0.05)), // Int increases damage by 5% per point
        type: 'damage'
      };
    }
  },
  
  bleed: {
    tickMs: 750,      // Ticks faster than burn
    durationMs: 6000, // Shorter duration
    maxStacks: 5,     // More stacks
    apply({ level, int, seed }): EffectTick {
      const random = rng(seed);
      const baseDamage = 5 + level * 1.5;
      const variance = 0.15;
      const actualDamage = baseDamage * (1 + (random() * 2 - 1) * variance);
      
      return {
        value: Math.round(actualDamage),
        type: 'damage'
      };
    }
  },
  
  regen: {
    tickMs: 1000,     // Every second
    durationMs: 10000, // 10 seconds
    maxStacks: 2,     // Max 2 stacks
    apply({ level, int, seed }): EffectTick {
      const random = rng(seed);
      const baseHeal = 5 + level * 1.8;
      const variance = 0.1;
      const actualHeal = baseHeal * (1 + (random() * 2 - 1) * variance);
      
      return {
        value: Math.round(actualHeal * (1 + int * 0.08)), // Int increases healing by 8% per point
        type: 'healing'
      };
    }
  }
};


// ==============================================================================
// FILE: shared/messages.ts
// ==============================================================================

import { SkillId } from './skillsDefinition';
import { CastSnapshot } from './types';

export interface VecXZ {
  x: number;
  z: number;
}

export interface PlayerMovementState {
  isMoving: boolean;
  path?: VecXZ[];
  pos: VecXZ;  // Current position
  targetPos?: VecXZ; // Target position when moving
  lastUpdateTime: number;
  speed: number;
}

// Base message with type
export interface ClientMsg {
  type: string;
  [key: string]: any;
}

// Movement messages
export interface MoveStart extends ClientMsg {
  type: 'MoveStart';
  id: string;
  path: VecXZ[];
  speed: number;
  clientTs: number;
}

export interface MoveSync extends ClientMsg {
  type: 'MoveSync';
  id: string;
  pos: VecXZ;
  clientTs: number;
}

export interface MoveStop extends ClientMsg {
  type: 'MoveStop';
  id: string;
  pos: VecXZ;
  clientTs: number;
}

// Server-driven position correction
export interface PosSnap extends ClientMsg {
  type: 'PosSnap';
  id: string;
  pos: VecXZ;
  serverTs: number;
}

// Skill casting
export interface CastReq extends ClientMsg {
  type: 'CastReq';
  id: string;
  skillId: string;
  targetId?: string;
  targetPos?: VecXZ;
  clientTs: number;
}

// Projectile messages - Legacy interfaces removed

// Instant skill hit effect
export interface InstantHit extends ClientMsg {
  type: 'InstantHit';
  skillId: string;
  origin: { x: number; y: number; z: number };
  targetPos: { x: number; y: number; z: number };
  hitIds: string[];
  dmg?: number[];  // Damage values for each hit target
}

// Skill management
export interface LearnSkill extends ClientMsg {
  type: 'LearnSkill';
  skillId: SkillId;
}

export interface SetSkillShortcut extends ClientMsg {
  type: 'SetSkillShortcut';
  slotIndex: number;  // 0-8 for keys 1-9
  skillId: SkillId | null;  // null to clear the slot
}

export interface SkillLearned extends ClientMsg {
  type: 'SkillLearned';
  skillId: SkillId;
  remainingPoints: number;
}

export interface SkillShortcutUpdated extends ClientMsg {
  type: 'SkillShortcutUpdated';
  slotIndex: number;
  skillId: SkillId | null;
}

// Class system messages
export interface SelectClass extends ClientMsg {
  type: 'SelectClass';
  className: string;
}

export interface ClassSelected extends ClientMsg {
  type: 'ClassSelected';
  className: string;
  baseStats: {
    healthMultiplier: number;
    manaMultiplier: number;
    damageMultiplier: number;
    speedMultiplier: number;
  };
}

// Skill cast failure message
export interface CastFail extends ClientMsg {
  type: 'CastFail';
  clientSeq: number;
  reason: 'cooldown' | 'nomana' | 'invalid';
}

// Server-facing message base type
export interface ServerMsg extends ClientMsg {
  type: string;
}

// New additive messages - do NOT edit old ones
export interface CastSnapshotMsg extends ServerMsg {
  type: 'CastSnapshot';
  data: CastSnapshot;
}

export interface ProjSpawn2 extends ServerMsg {
  type: 'ProjSpawn2';
  castId: string;
  origin: VecXZ;
  dir: VecXZ;   // Normalized, XZ plane
  speed: number;
  launchTs: number;
  hitRadius?: number;  // Optional hitRadius for VFX
  casterId?: string;   // ID of the entity that cast this projectile
  skillId?: string;    // ID of the skill that created this projectile
  travelMs?: number;   // Flight time client-side
}

export interface ProjHit2 extends ServerMsg {
  type: 'ProjHit2';
  castId: string;
  hitIds: string[];
  dmg: number[];   // Aligned with hitIds
  impactPos?: VecXZ; // Position of the projectile impact (optional for backwards compatibility)
}

// Status effect messages
export interface EffectSnapshotMsg extends ServerMsg {
  type: 'EffectSnapshot';
  id: string;       // Entity ID
  src: string;      // Source entity ID
  effectId: string; // Effect type identifier
  stacks: number;   // Current stacks
  remainingMs: number; // Remaining duration in ms
  seed: number;     // RNG seed for deterministic calculations
}


// ==============================================================================
// FILE: shared/positionUtils.ts
// ==============================================================================

// filepath: /home/s/develop/projects/vibe/1/shared/positionUtils.ts
import { VecXZ } from './messages.js';

/**
 * Predicts the position of an entity at a given time based on its movement state
 * @param entity The entity with position and movement
 * @param timestamp The time to predict position for
 * @returns The predicted position at the given time
 */
export function predictPosition(entity: any, timestamp: number): VecXZ {
  if (!entity || !entity.position) {
    return { x: 0, z: 0 };
  }

  // If no movement or timestamp is in the past, return current position
  if (!entity.movement || 
      !entity.movement.startTime || 
      timestamp <= entity.movement.startTime) {
    return { 
      x: entity.position.x, 
      z: entity.position.z 
    };
  }

  // Calculate time elapsed since movement started
  const elapsedTimeSec = (timestamp - entity.movement.startTime) / 1000;
  
  // Calculate distance traveled
  const distanceTraveled = entity.movement.speed * elapsedTimeSec;
  
  // If no direction or speed is 0, return current position
  if (!entity.movement.dir || 
      entity.movement.speed === 0 || 
      (entity.movement.dir.x === 0 && entity.movement.dir.z === 0)) {
    return { 
      x: entity.position.x, 
      z: entity.position.z 
    };
  }
  
  // Calculate predicted position
  return {
    x: entity.position.x + entity.movement.dir.x * distanceTraveled,
    z: entity.position.z + entity.movement.dir.z * distanceTraveled
  };
}

/**
 * Calculate distance between two points in 2D space
 */
export function distance(a: VecXZ, b: VecXZ): number {
  const dx = a.x - b.x;
  const dz = a.z - b.z;
  return Math.sqrt(dx * dx + dz * dz);
}


// ==============================================================================
// FILE: shared/skillsDefinition.ts
// ==============================================================================

// Direct definitions without imports
export type SkillId = 'fireball'|'iceBolt'|'waterSplash'|'petrify';

export type SkillCategory = 'projectile'|'instant'|'beam'|'aura';

export type SkillEffectType = 
  | 'damage' 
  | 'stun' 
  | 'slow' 
  | 'dot'    // damage over time
  | 'burn'   // burn damage over time
  | 'poison' // poison damage over time
  | 'waterWeakness' // increases water damage taken
  | 'freeze' 
  | 'transform'; // for stone conversion

export interface SkillEffect {
  type: SkillEffectType;
  value: number; // damage amount, stun duration, slow percentage, etc.
  durationMs?: number; // how long the effect lasts, in ms
}

export interface SkillDef {
  id: SkillId;
  name: string;
  description: string;
  icon: string; // Path to icon image
  cat: SkillCategory;
  manaCost: number;
  castMs: number;
  cooldownMs: number;
  dmg?: number;
  range?: number;
  speed?: number;       // tiles/sec
  area?: number;        // tile radius
  levelRequired: number;
  effects: SkillEffect[];
  projectile?: { 
    speed?: number; 
    pierce?: boolean; 
    splashRadius?: number;
    hitRadius?: number;  // Explicit hit detection radius
    maxPierceHits?: number; // Maximum number of targets that can be hit with pierce
  };
}

// Define the SKILLS directly
export const SKILLS: Record<SkillId,SkillDef> = {
  fireball: {
    id: 'fireball',
    name: 'Fireball',
    description: 'Launches a ball of fire that deals damage and applies a burn effect',
    icon: '/skills/fireball.png',
    cat: 'projectile',
    manaCost: 20,
    castMs: 300,
    cooldownMs: 500,
    dmg: 150,
    range: 1800,
    speed: 22,
    levelRequired: 1,
    effects: [
      { type: 'damage', value: 150 },
      { type: 'burn', value: 1, durationMs: 5000 } // 5 seconds
    ],
    projectile: {
      speed: 22,
      pierce: false,
      hitRadius: 1.0
    }
  },
  iceBolt: {
    id: 'iceBolt',
    name: 'Ice Bolt',
    description: 'Fires a bolt of ice that poisons enemies and slows their movement',
    icon: '/skills/icebolt.png',
    cat: 'projectile',
    manaCost: 15,
    castMs: 500,
    cooldownMs: 3000,
    dmg: 30,
    range: 18,
    speed: 26,
    levelRequired: 3,
    effects: [
      { type: 'damage', value: 30 },
      { type: 'poison', value: 0.5, durationMs: 10000 }, // Poisons enemy for 0.5% damage for 10 seconds
      { type: 'slow', value: 50, durationMs: 10000 } // Slows enemy by 50% for 10 seconds
    ],
    projectile: {
      speed: 26,
      pierce: true,
      maxPierceHits: 2,
      hitRadius: 0.8
    }
  },
  waterSplash: {
    id: 'waterSplash',
    name: 'Water Splash',
    description: 'Creates a splash of water that damages enemies and slows them down',
    icon: '/skills/water.png',
    cat: 'projectile',
    manaCost: 25,
    castMs: 1500,
    cooldownMs: 8000,
    dmg: 20,
    range: 15,
    speed: 20,
    area: 3,
    levelRequired: 2,
    effects: [
      { type: 'damage', value: 20 },
      { type: 'waterWeakness', value: 30, durationMs: 5000 } // Makes enemy take 30% more damage from water attacks
    ],
    projectile: {
      speed: 20,
      pierce: false,
      splashRadius: 3,
      hitRadius: 1.2
    }
  },
  petrify: {
    id: 'petrify',
    name: 'Petrify',
    description: 'Temporarily stuns an enemy, preventing them from moving or attacking',
    icon: '/skills/petrify.png',
    cat: 'instant',
    manaCost: 40,
    castMs: 2000,
    cooldownMs: 15000,
    dmg: 10,
    range: 10,
    levelRequired: 4,
    effects: [
      { type: 'damage', value: 10 },
      { type: 'stun', value: 100, durationMs: 2000 } // Stuns enemy completely for 2 seconds
    ]
  }
};


// ==============================================================================
// FILE: shared/types.ts
// ==============================================================================

import { SkillId } from './skillsDefinition';
import { CharacterClass } from './classSystem';
import { VecXZ } from './messages';

export enum CastState { Casting = 0, Traveling = 1, Impact = 2 }

export interface CastSnapshot {
  castId: string;
  casterId: string;
  skillId: SkillId;
  state: CastState;
  origin: VecXZ;
  target?: VecXZ;
  startedAt: number;   // Timestamp
}

export interface StatusEffect {
    id: string;
    type: string;
    value: number;
    durationMs: number;
    startTimeTs: number;
    sourceSkill: string;
}

export interface Enemy {
    id: string;
    type: string;
    name: string;
    level: number;
    position: { x: number; y: number; z: number };
    spawnPosition: { x: number; y: number; z: number };
    rotation: { x: number; y: number; z: number };
    health: number;
    maxHealth: number;
    isAlive: boolean;
    attackDamage: number;
    attackRange: number;
    baseExperienceValue: number;
    experienceValue: number;
    statusEffects: StatusEffect[];
    targetId?: string | null;
    markedForRemoval?: boolean;
    deathTimeTs?: number;
    attackCooldown?: boolean;
    posHistory?: { ts: number; x: number; z: number }[];  // Position history buffer similar to players
    lastUpdateTime?: number;  // Track last update time
}

// Intent-based movement messages
// These have been moved to shared/messages.ts
// Only keeping old interface definitions for backward compatibility during migration
import type { VecXZ, PlayerMovementState } from './messages';
export type { VecXZ, PlayerMovementState };

export interface MoveStartMsg {
    type: 'moveStart';
    id: string;            // playerId
    from: VecXZ;           // current server-accepted pos (xz only)
    to: VecXZ;             // destination clicked on ground
    speed: number;         // client's intended speed (u/s)
    ts: number;            // client epoch ms when click happened
}

export interface MoveStopMsg {
    type: 'moveStop';
    id: string;
    pos: VecXZ;            // here the client thinks he stopped
    ts: number;
}

// Update PlayerState with optional movement field and class data
export interface PlayerState {
    id: string;
    socketId: string;
    name: string;
    position: { x: number; y: number; z: number };
    rotation: { x: number; y: number; z: number };
    health: number;
    maxHealth: number;
    mana: number;
    maxMana: number;
    className: CharacterClass;
    unlockedSkills: SkillId[];     // All skills the player has learned
    skillShortcuts: (SkillId | null)[];  // Skills assigned to number keys 1-9
    availableSkillPoints: number;  // Points available to learn new skills
    skillCooldownEndTs: Record<string, number>;
    statusEffects: StatusEffect[];
    level: number;
    experience: number;
    experienceToNextLevel: number;
    castingSkill: string | null;
    castingProgressMs: number;
    isAlive: boolean;
    deathTimeTs?: number;
    lastUpdateTime?: number;
    movement?: PlayerMovementState;
}


// ==============================================================================
// FILE: shared/zoneSystem.ts
// ==============================================================================

import { Enemy } from './types.js';

// Types for zone management
export interface Zone {
    id: string;
    name: string;
    description: string;
    position: { x: number; y: number; z: number };
    radius: number;
    minLevel: number;
    maxLevel: number;
    mobs: {
        type: string;
        weight: number;
        minCount: number;
        maxCount: number;
    }[];
}

export interface MobSpawnConfig {
    type: string;
    count: number;
}

export class ZoneManager {
    getZoneAtPosition(position: { x: number; y: number; z: number }): Zone | null {
        for (const zone of GAME_ZONES) {
            const dx = position.x - zone.position.x;
            const dz = position.z - zone.position.z;
            const distanceSquared = dx * dx + dz * dz;
            
            if (distanceSquared <= zone.radius * zone.radius) {
                return zone;
            }
        }
        return null;
    }

    getMobsToSpawn(zoneId: string): MobSpawnConfig[] {
        const zone = GAME_ZONES.find(z => z.id === zoneId);
        if (!zone) return [];

        return zone.mobs.map(mobConfig => {
            const count = Math.floor(
                Math.random() * (mobConfig.maxCount - mobConfig.minCount + 1) + 
                mobConfig.minCount
            );
            return {
                type: mobConfig.type,
                count
            };
        });
    }

    getRandomPositionInZone(zoneId: string): { x: number; y: number; z: number } | null {
        const zone = GAME_ZONES.find(z => z.id === zoneId);
        if (!zone) return null;

        // Get a random angle and distance within the zone's radius
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.sqrt(Math.random()) * zone.radius;

        return {
            x: zone.position.x + Math.cos(angle) * distance,
            y: 0.5, // Slightly above ground
            z: zone.position.z + Math.sin(angle) * distance
        };
    }

    getMobLevel(zoneId: string): number {
        const zone = GAME_ZONES.find(z => z.id === zoneId);
        if (!zone) return 1;

        return Math.floor(
            Math.random() * (zone.maxLevel - zone.minLevel + 1) + 
            zone.minLevel
        );
    }
    
    /**
     * Get all available game zones
     * @returns Array of all zones
     */
    getZones(): Zone[] {
        return GAME_ZONES;
    }
}

export const GAME_ZONES: Zone[] = [
    {
        id: 'starter_meadow',
        name: 'Peaceful Meadows',
        description: 'A tranquil starting area with gentle slopes and scattered trees',
        position: { x: 0, y: 0, z: 0 },
        radius: 100,
        minLevel: 1,
        maxLevel: 3,
        mobs: [
            { type: 'goblin', weight: 70, minCount: 5, maxCount: 8 },
            { type: 'wolf', weight: 30, minCount: 2, maxCount: 4 }
        ]
    },
    {
        id: 'dark_forest',
        name: 'Dark Forest',
        description: 'A dense forest with challenging enemies',
        position: { x: 200, y: 0, z: 200 },
        radius: 150,
        minLevel: 3,
        maxLevel: 5,
        mobs: [
            { type: 'wolf', weight: 40, minCount: 4, maxCount: 8 },
            { type: 'skeleton', weight: 60, minCount: 3, maxCount: 6 }
        ]
    }
];
