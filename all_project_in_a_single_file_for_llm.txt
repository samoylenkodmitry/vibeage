// Project Documentation
// Generated on: 2025-05-14T17:15:13.914Z
// This file contains the source code of all meaningful files in the project.



// ==============================================================================
// FILE: app/game/components/CastingBar.tsx
// ==============================================================================

'use client';

import React, { useEffect, useState } from 'react';
import { useGameStore } from '../systems/gameStore';
// Import getSkillById from the correct path using shared definitions
import { SKILLS as skillsDefinitionShared, SkillId as SkillIdShared } from '../../../shared/skillsDefinition';

interface CastingBarProps {
  playerId: string;
}

// Helper to get skill by ID using the shared definition
const getSkillById = (skillId: string | null | undefined): typeof skillsDefinitionShared[SkillIdShared] | null => {
  if (!skillId) return null;
  // Ensure SKILLS has the skillId as a key and it's a valid SkillIdShared
  if (Object.prototype.hasOwnProperty.call(skillsDefinitionShared, skillId)) {
    return skillsDefinitionShared[skillId as SkillIdShared] || null;
  }
  return null;
};

export default function CastingBar({ playerId }: CastingBarProps) {
  const player = useGameStore((state) => 
    playerId ? state.players[playerId] : null
  );
  
  const [progressPercentInternal, setProgressPercentInternal] = useState(0);
  const [currentLocalProgressMs, setCurrentLocalProgressMs] = useState(0);
  const [skillName, setSkillName] = useState('');
  const [isVisible, setIsVisible] = useState(false);
  
  useEffect(() => {
    if (!player) {
      setIsVisible(false);
      setCurrentLocalProgressMs(0); // Ensure reset if player disappears
      setProgressPercentInternal(0); // Ensure reset
      return;
    }
    
    const isCurrentlyCasting = !!player.castingSkill;
    const currentCastingSkillId = player.castingSkill;
    
    if (isCurrentlyCasting && currentCastingSkillId) {
      const skill = getSkillById(currentCastingSkillId);
      if (skill) {
        // THIS IS THE KEY CHANGE: Always reset local progress based on store when cast starts/changes
        const serverProgressMs = player.castingProgressMs || 0;
        setCurrentLocalProgressMs(serverProgressMs); 
        
        const castTimeMs = skill.castMs || 1000;
        // Calculate initial progress based on what the server says (should be 0 for new casts)
        const initialProgressPercent = Math.min(100, (serverProgressMs / castTimeMs) * 100);
        
        setProgressPercentInternal(initialProgressPercent);
        setSkillName(skill.name || currentCastingSkillId);
        setIsVisible(true);
      } else {
        setIsVisible(false); // Skill definition not found
        setCurrentLocalProgressMs(0); 
        setProgressPercentInternal(0);
      }
    } else {
      setIsVisible(false);
      setCurrentLocalProgressMs(0); 
      setProgressPercentInternal(0);
    }
  }, [player?.castingSkill, player?.castingProgressMs, player]); // player dependency is important
  
  useEffect(() => {
    if (!isVisible || !player?.castingSkill) return;

    const castingSkillId = player.castingSkill;
    const skill = getSkillById(castingSkillId);
    if (!skill) return;

    const castTimeMs = skill.castMs || 1000;

    const interval = setInterval(() => {
      setCurrentLocalProgressMs(prevMs => {
        const newMs = prevMs + 50; // Increment local progress
        if (newMs >= castTimeMs) {
          setProgressPercentInternal(100);
          // Server will eventually clear player.castingSkill, which will hide the bar via the other useEffect
          return castTimeMs; 
        }
        const newProgressPercent = Math.min(100, (newMs / castTimeMs) * 100);
        setProgressPercentInternal(newProgressPercent);
        return newMs;
      });
    }, 50);
    
    return () => clearInterval(interval);
  }, [isVisible, player?.castingSkill]); 
  
  if (!isVisible) return null;
  
  return (
    <div className="fixed bottom-32 left-1/2 transform -translate-x-1/2 w-64 bg-gray-800 border border-purple-600 rounded-md p-2 shadow-lg">
      <div className="flex justify-between items-center mb-1">
        <div className="text-white text-sm font-semibold">{skillName}</div>
        <div className="text-white text-xs">{Math.round(progressPercentInternal)}%</div>
      </div>
      <div className="h-4 bg-gray-700 rounded-sm overflow-hidden">
        <div 
          className="h-full bg-purple-600 transition-all duration-50 ease-linear"
          style={{ width: `${progressPercentInternal}%` }}
        ></div>
      </div>
    </div>
  );
}


// ==============================================================================
// FILE: app/game/components/ConnectionStatus.tsx
// ==============================================================================

'use client';

import React, { useEffect, useState } from 'react';
import { useGameStore } from '../systems/gameStore';

const ConnectionStatus: React.FC = () => {
  const isConnected = useGameStore(state => state.isConnected);
  const lastConnectionChangeTs = useGameStore(state => state.lastConnectionChangeTs);
  const [showNotification, setShowNotification] = useState(false);
  
  // Show notification for 3 seconds when connection status changes
  useEffect(() => {
    setShowNotification(true);
    const timer = setTimeout(() => {
      setShowNotification(false);
    }, 3000);
    
    return () => clearTimeout(timer);
  }, [lastConnectionChangeTs]);
  
  // Format time since connection change
  const getTimeSinceMs = () => {
    const elapsedMs = Date.now() - lastConnectionChangeTs;
    if (elapsedMs < 60000) return `${Math.floor(elapsedMs / 1000)}s ago`;
    if (elapsedMs < 3600000) return `${Math.floor(elapsedMs / 60000)}m ago`;
    return `${Math.floor(elapsedMs / 3600000)}h ago`;
  };
  
  return (
    <div className="connection-status">
      {/* Always visible status indicator */}
      <div 
        className={`connection-indicator ${isConnected ? 'connected' : 'disconnected'}`}
        title={`Server ${isConnected ? 'Connected' : 'Disconnected'} (${getTimeSinceMs()})`}
      >
        <div className="status-dot"></div>
        <span className="status-text">{isConnected ? 'Online' : 'Offline'}</span>
      </div>
      
      {/* Notification that fades away */}
      {showNotification && (
        <div className={`status-notification ${isConnected ? 'connected' : 'disconnected'}`}>
          Server {isConnected ? 'Connected' : 'Disconnected'}
        </div>
      )}
      
      <style jsx>{`
        .connection-status {
          position: fixed;
          bottom: 10px;
          right: 10px;
          z-index: 100;
        }
        
        .connection-indicator {
          display: flex;
          align-items: center;
          padding: 4px 10px;
          border-radius: 12px;
          font-size: 12px;
          font-weight: bold;
          background-color: rgba(0, 0, 0, 0.7);
          color: white;
        }
        
        .status-dot {
          width: 8px;
          height: 8px;
          border-radius: 50%;
          margin-right: 5px;
        }
        
        .connected .status-dot {
          background-color: #4CAF50;
          box-shadow: 0 0 5px #4CAF50;
        }
        
        .disconnected .status-dot {
          background-color: #F44336;
          box-shadow: 0 0 5px #F44336;
        }
        
        .status-notification {
          position: absolute;
          bottom: 100%;
          right: 0;
          margin-bottom: 10px;
          padding: 8px 15px;
          border-radius: 4px;
          font-size: 14px;
          font-weight: 500;
          animation: fadeOut 3s forwards;
          white-space: nowrap;
        }
        
        .status-notification.connected {
          background-color: rgba(76, 175, 80, 0.9);
          color: white;
        }
        
        .status-notification.disconnected {
          background-color: rgba(244, 67, 54, 0.9);
          color: white;
        }
        
        @keyframes fadeOut {
          0% { opacity: 1; }
          70% { opacity: 1; }
          100% { opacity: 0; }
        }
      `}</style>
    </div>
  );
};

export default ConnectionStatus;


// ==============================================================================
// FILE: app/game/components/DebugPanel.tsx
// ==============================================================================

'use client';

import { useState, useEffect } from 'react';
import { useGameStore, selectEnemyCount } from '../systems/gameStore';

export default function DebugPanel() {
  const [isVisible, setIsVisible] = useState(false);
  const enemyCount = useGameStore(selectEnemyCount);
  const enemies = useGameStore(state => state.enemies);
  const isConnected = useGameStore(state => state.isConnected);
  const myPlayerId = useGameStore(state => state.myPlayerId);
  
  // Toggle visibility with ~ key
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === '`' || e.key === '~') {
        setIsVisible(prev => !prev);
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);
  
  if (!isVisible) return null;
  
  return (
    <div className="fixed top-0 right-0 bg-black/80 text-white p-4 m-4 rounded-lg z-50 max-w-md max-h-[80vh] overflow-auto">
      <h2 className="text-xl font-bold mb-2">Debug Info</h2>
      <div className="space-y-2 text-sm">
        <p>Connection: <span className={isConnected ? "text-green-500" : "text-red-500"}>{isConnected ? "Connected" : "Disconnected"}</span></p>
        <p>Player ID: {myPlayerId || "Not assigned"}</p>
        <p>Enemy Count: {enemyCount}</p>
        
        <div className="mt-4">
          <h3 className="text-lg font-semibold mb-1">Enemies:</h3>
          {enemyCount > 0 ? (
            <ul className="space-y-1">
              {Object.entries(enemies).map(([id, enemy]) => (
                <li key={id} className="text-xs">
                  {enemy.name} (Lv.{enemy.level}) - Health: {enemy.health}/{enemy.maxHealth} - 
                  Pos: [{Math.round(enemy.position.x)}, {Math.round(enemy.position.y)}, {Math.round(enemy.position.z)}]
                </li>
              ))}
            </ul>
          ) : (
            <p className="text-yellow-500">No enemies found in game state</p>
          )}
        </div>
        
        <div className="mt-4">
          <button 
            className="bg-blue-600 hover:bg-blue-700 text-white px-2 py-1 rounded text-xs"
            onClick={() => {
              const socket = useGameStore.getState().socket;
              if (socket) {
                console.log('Requesting fresh game state');
                socket.emit('requestGameState');
              }
            }}
          >
            Request Game State
          </button>
        </div>
      </div>
    </div>
  );
}


// ==============================================================================
// FILE: app/game/components/Enemies.tsx
// ==============================================================================

'use client';

import { useFrame } from '@react-three/fiber';
import { useState, useRef } from 'react';
import { RigidBody } from '@react-three/rapier';
import { Html } from '@react-three/drei';

import * as THREE from 'three';
import { useGameStore } from '../systems/gameStore';

export default function Enemies() {
  const enemies = useGameStore(state => state.enemies);
  const selectedTargetId = useGameStore(state => state.selectedTargetId);
  const selectTarget = useGameStore(state => state.selectTarget);

  // Convert enemies object to array
  const enemiesArray = Object.values(enemies);

  useFrame(() => {
    // Enemy AI and movement logic here
  });

  return (
    <group>
      {enemiesArray.map((enemy) => (
        <Enemy 
          key={enemy.id}
          enemy={enemy}
          isSelected={selectedTargetId === enemy.id}
          onSelect={() => selectTarget(enemy.id)}
        />
      ))}
    </group>
  );
}

interface EnemyProps {
  enemy: any;
  isSelected: boolean;
  onSelect: () => void;
}

function Enemy({ enemy, isSelected, onSelect }: EnemyProps) {
  const meshRef = useRef<THREE.Mesh>(null);
  const { type, position, health, maxHealth, isAlive, level } = enemy;
  const [isHovered, setIsHovered] = useState(false);

  // Different models for different enemy types
  const getEnemyModel = () => {
    switch (type) {
      case 'goblin':
        return <GoblinModel isSelected={isSelected} isHovered={isHovered} />;
      case 'wolf':
        return <WolfModel isSelected={isSelected} isHovered={isHovered} />;
      case 'skeleton':
        return <SkeletonModel isSelected={isSelected} isHovered={isHovered} />;
      default:
        return <DefaultEnemyModel isSelected={isSelected} isHovered={isHovered} />;
    }
  };

  if (!isAlive) return null;
  
  // Get proper capitalized mob name
  const getMobName = (type: string) => {
    return type.charAt(0).toUpperCase() + type.slice(1);
  };
  
  return (
    <RigidBody type="fixed" position={[position.x, position.y, position.z]}>
      {/* Clickable area */}
      <mesh 
        ref={meshRef}
        onClick={(e) => {
          e.stopPropagation();
          onSelect();
        }}
        onPointerOver={(e) => {
          e.stopPropagation();
          document.body.style.cursor = 'pointer';
          setIsHovered(true);
        }}
        onPointerOut={(e) => {
          e.stopPropagation();
          document.body.style.cursor = 'default';
          setIsHovered(false);
        }}
      >
        <sphereGeometry args={[1.2, 8, 8]} />
        <meshBasicMaterial transparent opacity={0} />
      </mesh>
      
      {/* Enemy model */}
      {getEnemyModel()}
      
      {/* Health bar and name tag */}
      <Html position={[0, 2.5, 0]} center sprite>
        <div className="flex flex-col items-center pointer-events-none">
          <div className={`text-white text-xs font-medium bg-black/50 px-2 py-1 rounded mb-1 ${isSelected ? 'ring-2 ring-red-500' : ''}`}>
            {`${getMobName(type)} Lv.${level}`}
          </div>
          <div className="w-16 h-1.5 bg-gray-800 rounded-full overflow-hidden">
            <div
              className="h-full bg-red-600"
              style={{ width: `${(health / maxHealth) * 100}%` }}
            />
          </div>
        </div>
      </Html>
      
      {/* Selection indicator */}
      {isSelected && (
        <mesh position={[0, 0.1, 0]} rotation={[-Math.PI / 2, 0, 0]}>
          <ringGeometry args={[1.4, 1.6, 32]} />
          <meshBasicMaterial color="#ff0000" transparent opacity={0.6} />
        </mesh>
      )}
    </RigidBody>
  );
}

// Enhanced enemy models with selection/hover feedback

interface ModelProps {
  isSelected: boolean;
  isHovered: boolean;
}

function GoblinModel({ isSelected, isHovered }: ModelProps) {
  const baseColor = "#4a7c59";
  const hoverColor = "#5d8e6b";
  const selectedColor = "#6aaa7e";
  
  const color = isSelected ? selectedColor : (isHovered ? hoverColor : baseColor);
  
  return (
    <group>
      <mesh position={[0, 0.5, 0]} castShadow>
        <boxGeometry args={[0.6, 1.0, 0.6]} />
        <meshStandardMaterial color={color} />
      </mesh>
      <mesh position={[0, 1.2, 0]} castShadow>
        <sphereGeometry args={[0.4, 16, 16]} />
        <meshStandardMaterial color={color} />
      </mesh>
    </group>
  );
}

function WolfModel({ isSelected, isHovered }: ModelProps) {
  const baseColor = "#6e6e6e";
  const hoverColor = "#808080";
  const selectedColor = "#9a9a9a";
  
  const color = isSelected ? selectedColor : (isHovered ? hoverColor : baseColor);
  
  return (
    <group>
      <mesh position={[0, 0.5, 0]} rotation={[0, 0, Math.PI / 2]} castShadow>
        <capsuleGeometry args={[0.4, 1.0, 8, 16]} />
        <meshStandardMaterial color={color} />
      </mesh>
      <mesh position={[0.8, 0.5, 0]} castShadow>
        <boxGeometry args={[0.6, 0.3, 0.5]} />
        <meshStandardMaterial color={color} />
      </mesh>
    </group>
  );
}

function SkeletonModel({ isSelected, isHovered }: ModelProps) {
  const baseColor = "#d8d8d0";
  const hoverColor = "#e5e5dc";
  const selectedColor = "#f2f2ea";
  
  const color = isSelected ? selectedColor : (isHovered ? hoverColor : baseColor);
  
  return (
    <group>
      <mesh position={[0, 0.8, 0]} castShadow>
        <boxGeometry args={[0.6, 1.6, 0.3]} />
        <meshStandardMaterial color={color} />
      </mesh>
      <mesh position={[0, 1.8, 0]} castShadow>
        <sphereGeometry args={[0.4, 16, 16]} />
        <meshStandardMaterial color={color} />
      </mesh>
    </group>
  );
}

function DefaultEnemyModel({ isSelected, isHovered }: ModelProps) {
  const baseColor = "#8B0000";
  const hoverColor = "#A52A2A";
  const selectedColor = "#DC143C";
  
  const color = isSelected ? selectedColor : (isHovered ? hoverColor : baseColor);
  
  return (
    <mesh position={[0, 1, 0]} castShadow>
      <boxGeometry args={[1, 2, 1]} />
      <meshStandardMaterial color={color} />
    </mesh>
  );
}

// ==============================================================================
// FILE: app/game/components/Game.tsx
// ==============================================================================

'use client';

import { Canvas } from '@react-three/fiber';
import { Physics } from '@react-three/rapier';
import { KeyboardControls } from '@react-three/drei';
import { useEffect, useState, useCallback, useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import World from './World';
import Player from './Player';
import Enemies from './Enemies';
import UI from './UI';
import KeyboardShortcuts from './KeyboardShortcuts';
import TargetRing from './TargetRing';
import VfxManager from './VfxManager';
import GameHud from './GameHud';
import { useGameStore } from '../systems/gameStore';
import { GROUND_Y, getBuffer } from '../systems/interpolation'; 
import SocketManager from '../systems/SocketManager';
import { debugAndFixPlayerMovement, forceUpdatePlayerPosition } from '../systems/playerMovementFix';

// Define keyboard controls
const controls = [
  { name: 'forward', keys: ['ArrowUp', 'KeyW'] },
  { name: 'backward', keys: ['ArrowDown', 'KeyS'] },
  { name: 'left', keys: ['ArrowLeft', 'KeyA'] },
  { name: 'right', keys: ['ArrowRight', 'KeyD'] },
  { name: 'jump', keys: ['Space'] },
  { name: 'fireball', keys: ['Digit1', 'KeyQ'] },
  { name: 'icebolt', keys: ['Digit2', 'KeyE'] },
  { name: 'waterSplash', keys: ['Digit3', 'KeyR'] },
  { name: 'petrify', keys: ['Digit4', 'KeyF'] },
];

function CameraFollowPlayer() {
  const myId = useGameStore(s => s.myPlayerId);
  const players = useGameStore(s => s.players);
  const angleRef = useRef(Math.PI);

  // Listen for camera angle changes from Player.tsx
  useEffect(() => {
    const handleCameraAngleChange = (e: CustomEvent) => {
      angleRef.current = e.detail.angle;
    };

    window.addEventListener('cameraAngleChange', handleCameraAngleChange as EventListener);
    
    return () => {
      window.removeEventListener('cameraAngleChange', handleCameraAngleChange as EventListener);
    };
  }, []);

  useFrame(({camera})=>{
    if(!myId) return;
    
    // Get current player state
    const player = players[myId];
    if (!player) return;
    
    // Use consistent lag value of 100ms to avoid stuttering
    const s = getBuffer(myId).sample(performance.now()-100);
    
    // If buffer has valid data, use it for camera position
    if(s) {
      const dist=15, height=10, ang=angleRef.current;
      
      // Create target position
      const targetPos = new THREE.Vector3(
        s.x - Math.sin(ang)*dist,
        GROUND_Y + height,
        s.z - Math.cos(ang)*dist
      );
      
      // Use stronger lerp factor for smoother camera follow
      camera.position.lerp(targetPos, 0.15);
      camera.lookAt(s.x, GROUND_Y+1, s.z);
    } 
    // Fallback to state-based position if buffer doesn't have data yet
    else if (player.position) {
      const dist=15, height=10, ang=angleRef.current;
      
      // Create target position using state instead of buffer
      const targetPos = new THREE.Vector3(
        player.position.x - Math.sin(ang)*dist,
        GROUND_Y + height,
        player.position.z - Math.cos(ang)*dist
      );
      
      camera.position.lerp(targetPos, 0.15);
      camera.lookAt(player.position.x, GROUND_Y+1, player.position.z);
    }
  });
  
  return null;
}

export default function Game() {
  const [isGameStarted, setGameStarted] = useState(false);
  const [playerName, setPlayerName] = useState('');
  const isConnected = useGameStore(state => state.isConnected);
  const socket = useGameStore(state => state.socket);
  const hasJoinedGame = useGameStore(state => state.hasJoinedGame);
  const setHasJoinedGame = useGameStore(state => state.setHasJoinedGame);

  useEffect(() => {
    if (isGameStarted && socket && isConnected && playerName.trim() && !hasJoinedGame) {
      console.log('Joining game with player name:', playerName);
      socket.emit('joinGame', playerName);
      setHasJoinedGame(true);
    }
  }, [isGameStarted, socket, isConnected, playerName, hasJoinedGame, setHasJoinedGame]);

  const handleStartGame = useCallback(() => {
    if (playerName.trim()) {
      setGameStarted(true);
    }
  }, [playerName, isConnected]);

  if (!isGameStarted) {
    return (
      <div className="w-full h-screen flex items-center justify-center bg-black">
        <div className="bg-gray-900 p-8 rounded-lg max-w-md w-full">
          <h1 className="text-4xl font-bold mb-6 text-purple-500">
            VibeAge
          </h1>
          <p className="text-gray-300 mb-6">
            Enter the world of magic and combat. Defeat enemies, level up, and unlock powerful spells in this Lineage-inspired MMORPG!
          </p>
          <div className="mb-4">
            <label htmlFor="name" className="block text-sm font-medium text-gray-300 mb-2">
              Character Name
            </label>
            <input
              type="text"
              id="name"
              value={playerName}
              onChange={(e) => setPlayerName(e.target.value)}
              className="w-full px-4 py-2 rounded bg-gray-800 text-white focus:outline-none focus:ring-2 focus:ring-purple-500"
              placeholder="Enter your character name"
            />
          </div>
          <button
            onClick={handleStartGame}
            className="w-full py-2 px-4 bg-purple-600 hover:bg-purple-700 text-white font-medium rounded transition-colors"
          >
            Enter the World
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="relative w-full h-full">
      <SocketManager />
      <KeyboardShortcuts />
      <KeyboardControls map={controls}>
        <Canvas 
          className="w-full h-screen"
          shadows
          frameloop="always"
          performance={{ min: 0.5 }}
          camera={{ 
            position: [0, 10, 15], 
            fov: 60,
            near: 0.1,
            far: 1000
          }}
          onCreated={({ gl }) => {
            // Configure renderer for better performance
            gl.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            gl.setClearColor('#202060'); // Default background color
            console.log('Canvas created successfully!');
          }}
        >
          <fog attach="fog" args={['#202060', 0, 100]} />
          <ambientLight intensity={0.5} />
          <directionalLight
            position={[10, 10, 10]}
            intensity={0.8}
            castShadow
            shadow-mapSize={[2048, 2048]}
          />
          <Physics>
            <World />
            <Player />
            <Enemies />
            <TargetRing />
            <VfxManager />
            <CameraFollowPlayer />
          </Physics>
        </Canvas>
      </KeyboardControls>
      <GameHud>
        <UI />
      </GameHud>
    </div>
  );
}


// ==============================================================================
// FILE: app/game/components/GameHud.tsx
// ==============================================================================

import React from 'react';
import { DragProvider } from '../context/DragContext';

export default function GameHud({ children }: { children: React.ReactNode }){ 
  return (
    <DragProvider>
      {children}
    </DragProvider>
  ); 
}


// ==============================================================================
// FILE: app/game/components/HUD/CombatLog.tsx
// ==============================================================================

import { useCombatLogStore } from '../../stores/useCombatLogStore';
import { useEffect, useState } from 'react';

export default function CombatLog() {
  const list = useCombatLogStore(s => s.list);

  // to fade after 6s
  const [now, setNow] = useState(Date.now());
  useEffect(() => {
    const t = setInterval(() => setNow(Date.now()), 1000);
    return () => clearInterval(t);
  }, []);

  return (
    <div 
      data-testid="combat-log"
      className="absolute left-2 bottom-2 w-72 text-xs font-mono pointer-events-none"
    >
      {list.slice(-20).map(e => {
        const age = now - e.ts;
        const op = age > 6000 ? 0 : 1 - age/6000;
        
        // Don't render entries that are completely faded out
        if (op <= 0) return null;
        
        return (
          <div 
            key={e.id}
            data-testid="log-entry"
            style={{opacity: op}}
            className="leading-4 text-white drop-shadow-sm"
          >
            {e.text}
          </div>
        );
      })}
    </div>
  );
}


// ==============================================================================
// FILE: app/game/components/KeyboardShortcuts.tsx
// ==============================================================================

'use client';

import { useEffect } from 'react';
import { useGameStore } from '../systems/gameStore';
import { tryStartCast } from '../systems/castController';

/**
 * Component that handles keyboard shortcuts for the game
 * This component doesn't render anything but sets up event listeners
 */
export default function KeyboardShortcuts() {
  const getMyPlayer = useGameStore(state => state.getMyPlayer);
  const selectedTargetId = useGameStore(state => state.selectedTargetId);
  
  useEffect(() => {
    // Add keyboard event listener for skill shortcuts
    const handleKeyDown = (e: KeyboardEvent) => {
      // Skip if input or textarea is focused
      if (document.activeElement instanceof HTMLInputElement || 
          document.activeElement instanceof HTMLTextAreaElement) {
        return;
      }
      
      // Toggle combat log with L key
      if (e.key === 'l' || e.key === 'L') {
        document.body.classList.toggle('hide-combat-log');
        console.log('Combat log toggled with L key');
        return;
      }
      
      // Handle skill keybinds with more direct keyboard mapping
      switch (e.code) {
        case 'Digit1':
        case 'KeyQ':
          console.log('Hotkey 1/Q pressed');
          tryStartCast('fireball', selectedTargetId || undefined);
          break;
        case 'Digit2':
        case 'KeyE':
          console.log('Hotkey 2/E pressed');
          tryStartCast('iceBolt', selectedTargetId || undefined);
          break;
        case 'Digit3':
        case 'KeyR':
          console.log('Hotkey 3/R pressed');
          tryStartCast('waterSplash', selectedTargetId || undefined);
          break;
        case 'Digit4':
        case 'KeyF':
          console.log('Hotkey 4/F pressed');
          tryStartCast('petrify', selectedTargetId || undefined);
          break;
      }
    };
    
    // Add the event listener
    window.addEventListener('keydown', handleKeyDown);
    
    // Remove event listener on cleanup
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [getMyPlayer, selectedTargetId]);
  
  // This component doesn't render anything
  return null;
}


// ==============================================================================
// FILE: app/game/components/Player.tsx
// ==============================================================================

import React, { useRef, useEffect, useState, useCallback } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import { RigidBody, CapsuleCollider} from '@react-three/rapier';
import * as THREE from 'three';
import { useGameStore, selectPlayer, selectMyPlayerId, selectPlayerIds } from '../systems/gameStore';
import { GROUND_Y, getBuffer } from '../systems/interpolation';
import { VecXZ } from '../../../shared/messages';
import { MovementDebugger } from './SimpleMovementDebugger';

// Individual Player Component
function PlayerCharacter({ playerId, isControlledPlayer }: { playerId: string, isControlledPlayer: boolean }) {
  const playerRef = useRef<any>(null);
  const playerState = useGameStore(selectPlayer(playerId));
  const socket = useGameStore(state => state.socket);

  // --- Hooks and State specific to the controlled player ---
  const { camera, gl, raycaster } = useThree();
  const [isGrounded] = useState(false);
  const [hasJumped, setHasJumped] = useState(false);
  const [isRotating, setIsRotating] = useState(false);
  const previousMousePosition = useRef({ x: 0, y: 0 });
  const cameraAngleRef = useRef(Math.PI);
  const movementTimestampRef = useRef(0);

  // Initialize camera angle
  useEffect(() => {
    if (isControlledPlayer) {
      // Initialize with default value
      cameraAngleRef.current = Math.PI;
      
      // Dispatch initial angle to ensure the camera starts at the correct angle
      window.dispatchEvent(new CustomEvent('cameraAngleChange', { 
        detail: { angle: cameraAngleRef.current } 
      }));
    }
  }, [isControlledPlayer]);

  // Used for ground plane intersection calculations
  const moveDirection = useRef({ forward: 0, right: 0, jump: false });
  
  // --- Callbacks for Controlled Player Input ---
  const handleMouseClick = useCallback((e: MouseEvent) => {
    if (!isControlledPlayer || e.button !== 0 || isRotating) return;
    if ((e.target as HTMLElement).closest('.pointer-events-auto')) return;
    if (!socket || !playerState) return;

    console.log('Mouse click event:', e.clientX, e.clientY, 'Player controlled:', isControlledPlayer);

    try {
      // Make sure we're using the correct canvas dimensions for accurate clicking
      const canvasRect = gl.domElement.getBoundingClientRect();
      
      // Calculate normalized device coordinates (-1 to +1) using the canvas's actual position
      const mouseX = ((e.clientX - canvasRect.left) / canvasRect.width) * 2 - 1;
      const mouseY = -((e.clientY - canvasRect.top) / canvasRect.height) * 2 + 1;
      
      // Create the mouse vector and set it directly
      raycaster.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      raycaster.ray.direction.set(mouseX, mouseY, 0.5).unproject(camera).sub(raycaster.ray.origin).normalize();
      
      console.log('Ray direction:', raycaster.ray.direction);
      
      // Create a y-plane at ground level and check for intersection
      const planeY = GROUND_Y; 
      const rayDir = raycaster.ray.direction.clone();
      const rayOrig = raycaster.ray.origin.clone();
      
      // Calculate distance along ray to y plane
      if (rayDir.y === 0) {
        console.warn('Ray is parallel to ground plane, no intersection');
      } else {
        const t = (planeY - rayOrig.y) / rayDir.y;
        if (t >= 0) {
          // Calculate the intersection point manually to avoid type compatibility issues
          const rayPos = new THREE.Vector3(
            rayOrig.x + rayDir.x * t,
            rayOrig.y + rayDir.y * t,
            rayOrig.z + rayDir.z * t
          );
          console.log('Ray intersects ground at:', rayPos);
          
          // Create target position, ensuring Y is at ground level
          const newTarget = new THREE.Vector3(rayPos.x, GROUND_Y, rayPos.z);
          console.log('Setting movement target:', newTarget);
          
          // Record movement timestamp to prevent camera rotation during movement
          movementTimestampRef.current = Date.now();
        
          // Get reference to store to ensure we're using the proper state
          const store = useGameStore.getState();
          
          // Set target in global store for reference
          store.setTargetWorldPos(newTarget);
          
          // Send network message with move intent
          // The server will handle the movement and send back position updates
          store.sendMoveIntent({ 
            x: newTarget.x, 
            z: newTarget.z 
          });
          // --- BEGIN BUFFER RESET LOGIC for controlled player ---
          if (isControlledPlayer && playerRef.current) {
            const currentVisualPos = playerRef.current.translation();
            const buffer = getBuffer(playerId);
            buffer.clearBuffer(); // Add this method to SnapBuffer

            const syntheticSnap: Snap = {
              pos: { x: currentVisualPos.x, z: currentVisualPos.z },
              vel: { x: 0, z: 0 }, // Start with zero velocity, server will correct
              rot: cameraAngleRef.current, // Or current player Y rotation
              snapTs: performance.now() // Timestamp it as "now" from client's perspective
            };
            buffer.push(syntheticSnap);
            console.log(`[Player.tsx] Cleared buffer and pushed synthetic snap for ${playerId} at`, syntheticSnap.pos);
          }
          // --- END BUFFER RESET LOGIC ---
        } else {
          console.warn('Ray did not intersect ground plane');
        }
      }
    } catch (err) {
      console.error('Error in handleMouseClick:', err);
    }
  }, [isControlledPlayer, isRotating, camera, raycaster, gl, socket, playerState]);

  const emitMoveStop = useCallback((position: THREE.Vector3) => {
    if (!socket || !playerState) return;
    
    // Send a final intent to the current position to stop movement
    useGameStore.getState().sendMoveIntent({ x: position.x, z: position.z });
    
    // Clear target in global store
    useGameStore.getState().setTargetWorldPos(null);
  }, [socket, playerState]);

  const handleMouseDown = useCallback((e: MouseEvent) => {
    if (!isControlledPlayer || e.button !== 2) return;
    setIsRotating(true);
    previousMousePosition.current = { x: e.clientX, y: e.clientY };
    document.body.style.cursor = 'grabbing';
    e.preventDefault(); e.stopPropagation();
  }, [isControlledPlayer]);

  const handleMouseUp = useCallback((e: MouseEvent) => {
    if (!isControlledPlayer || e.button !== 2) return;
    setIsRotating(false);
    document.body.style.cursor = 'default';
    e.preventDefault(); e.stopPropagation();
  }, [isControlledPlayer]);

  const handleMouseMove = useCallback((e: MouseEvent) => {
    if (!isControlledPlayer || !isRotating) return;
    const deltaX = e.clientX - previousMousePosition.current.x;
    // Update the local ref directly
    cameraAngleRef.current = cameraAngleRef.current - deltaX * 0.02;
    
    // Dispatch a custom event to notify the camera of the angle change
    window.dispatchEvent(new CustomEvent('cameraAngleChange', { 
      detail: { angle: cameraAngleRef.current } 
    }));
    
    previousMousePosition.current = { x: e.clientX, y: e.clientY };
    e.preventDefault(); e.stopPropagation();
  }, [isControlledPlayer, isRotating]);

  const handleContextMenu = useCallback((e: MouseEvent) => {
    if (!isControlledPlayer) return;
    e.preventDefault(); e.stopPropagation();
  }, [isControlledPlayer]);

  const handleKeyDown = useCallback((e: KeyboardEvent) => {
    if (!isControlledPlayer) return;
    
    // Handle space for jumping
    if (e.code === 'Space' && !hasJumped && isGrounded) {
      moveDirection.current.jump = true;
      setHasJumped(true);
    }
    
    // Handle S key for force stop
    if (e.code === 'KeyS' && playerState?.movement?.targetPos) {
      if (playerRef.current) {
        const position = playerRef.current.translation();
        emitMoveStop(position);
      }
    }
  }, [isControlledPlayer, hasJumped, isGrounded, playerState, emitMoveStop]);

  const handleKeyUp = useCallback(() => {
    // Empty handler kept for future use
  }, [isControlledPlayer]);

  // --- Register event listeners for controlled player ---
  useEffect(() => {
    if (!isControlledPlayer) return;

    window.addEventListener('click', handleMouseClick);
    window.addEventListener('mousedown', handleMouseDown);
    window.addEventListener('mouseup', handleMouseUp);
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('contextmenu', handleContextMenu);
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    document.body.style.cursor = 'default';

    return () => {
      window.removeEventListener('click', handleMouseClick);
      window.removeEventListener('mousedown', handleMouseDown);
      window.removeEventListener('mouseup', handleMouseUp);
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('contextmenu', handleContextMenu);
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [isControlledPlayer, handleMouseClick, handleMouseDown, handleMouseUp, handleMouseMove, handleContextMenu, handleKeyDown, handleKeyUp]);

  // --- Update Player.tsx useFrame handler to use position snapshots from the module-global buffer ---
  useFrame(() => {
    if (!playerRef.current || !playerState) return;

    try {
      const buf = getBuffer(playerId);
      // Use a consistent lag value of 100ms (matching the camera)
      const lag = 200;
      const tick = performance.now() - lag;
      const s = buf.sample(tick);
      if (isControlledPlayer && Math.random() < 0.05) { // Log ~5% of frames
          const now = performance.now();
          if (buf.getBufferLength() > 0) {
              const firstTs = buf.debugDump()[0].snapTs.toFixed(0);
              const lastTs = buf.debugDump()[buf.getBufferLength()-1].snapTs.toFixed(0);
          }
      }
      
      if (s) {
          const targetStatePos = new THREE.Vector3(s.x, GROUND_Y, s.z);

          // Get the current actual position of the physics body
          const currentActualPos = playerRef.current.translation();

          // Gently lerp the physics body towards the interpolated target state.
          // Use a HIGH lerp factor to mostly snap but smooth out tiny residuals.
          const lerpFactor = 0.75; // Experiment with 0.6 to 0.9
          const smoothedPos = new THREE.Vector3().lerpVectors(
              currentActualPos,
              targetStatePos,
              lerpFactor
          );
          playerRef.current.setNextKinematicTranslation(smoothedPos);

        // Apply interpolated rotation
        playerRef.current.setNextKinematicRotation({
          x: 0,
          y: Math.sin(s.rot/2),
          z: 0,
          w: Math.cos(s.rot/2)
        });
      } else if (playerState.position) {
        // Fallback to using the playerState position if no buffer sample
        // This should rarely happen once the system is working correctly
        console.warn(`No position sample for player ${playerId}, falling back to state position`);
        playerRef.current.setNextKinematicTranslation({
          x: playerState.position.x,
          y: GROUND_Y,
          z: playerState.position.z
        });
        
        // Apply current rotation from state
        const rotY = playerState.rotation?.y || 0;
        playerRef.current.setNextKinematicRotation({
          x: 0,
          y: Math.sin(rotY/2),
          z: 0,
          w: Math.cos(rotY/2)
        });
      }
      
    } catch (err) {
      console.error("Error in useFrame handler:", err);
    }
  });

  // --- Effect to handle server corrections for controlled player ---
  useEffect(() => {
    if (!socket) return;

    // Handle position updates from server - just for logging/debugging purposes
    const handlePosSnap = (data: { type: string, snaps: Array<{ id: string, pos: VecXZ, vel: VecXZ, snapTs: number }> }) => {
      if (data.type !== 'PosSnap') return;
      if (!data.snaps || !Array.isArray(data.snaps)) return;
      
      // Find this player's snap in the snaps array
      const thisPlayerSnap = data.snaps.find(snap => snap && snap.id === playerId);
      if (!thisPlayerSnap || !thisPlayerSnap.pos) return;
      
      // For debugging only - log significant position jumps for the controlled player
      if (isControlledPlayer && playerRef.current) {
        const currentPosition = playerRef.current.translation();
        if (!currentPosition) return;
        
        const serverPos = thisPlayerSnap.pos;
        const distance = Math.sqrt(
          Math.pow(serverPos.x - currentPosition.x, 2) + 
          Math.pow(serverPos.z - currentPosition.z, 2)
        );
        
        // Only log if the difference is significant and reduce frequency
        if (distance > 3.0 && Math.random() < 0.3) {
          console.log(`Position difference detected: ${distance.toFixed(2)} units`);
          
          // If distance is extremely large (teleport-like), implement stronger smoothing
          if (distance > 10.0) {
            console.log(`Large teleport detected: (${currentPosition.x.toFixed(2)}, ${currentPosition.z.toFixed(2)}) → (${serverPos.x.toFixed(2)}, ${serverPos.z.toFixed(2)})`);
            
            // Add metadata to help with debugging
            if (isControlledPlayer) {
              const buf = getBuffer(playerId);
              console.log(`Buffer info: length=${buf.getBufferLength()}`);
            }
          }
        }
      }
    };
    
    // Listen for position snapshots
    socket.on('msg', handlePosSnap);
    
    return () => {
      socket.off('msg', handlePosSnap);
    };
  }, [playerId, socket, isControlledPlayer]);

  // --- Listen for player position requests from skill effects ---
  useEffect(() => {
    if (!isControlledPlayer || !playerRef.current) return;

    const handleRequestPosition = (e: CustomEvent) => {
      const { callback } = e.detail;
      if (playerRef.current) {
        const currentPosition = playerRef.current.translation();
        // Provide the accurate client-side position for skill effects
        callback({
          x: currentPosition.x,
          y: currentPosition.y,
          z: currentPosition.z
        });
      }
    };

    window.addEventListener('requestPlayerPosition', handleRequestPosition as EventListener);
    
    return () => {
      window.removeEventListener('requestPlayerPosition', handleRequestPosition as EventListener);
    };
  }, [isControlledPlayer]);

  // Log player state on mount
  useEffect(() => {
    console.log(`PlayerCharacter mounting: id=${playerId}, isControlled=${isControlledPlayer}`, {
      position: playerState?.position,
      playerStateExists: !!playerState,
      allPlayers: Object.keys(useGameStore.getState().players)
    });

    return () => {
      console.log(`PlayerCharacter unmounting: id=${playerId}, isControlled=${isControlledPlayer}`);
    };
  }, [playerId, isControlledPlayer, playerState]);

  // Render the player model
  if (!playerState) return null; // Don't render if state doesn't exist yet

  return (
    <>
      <RigidBody
        ref={playerRef}
        position={[playerState.position.x, playerState.position.y, playerState.position.z]} // Initial position from store
        enabledRotations={[false, true, false]} // Allow Y rotation for facing direction
        colliders={false}
        mass={isControlledPlayer ? 10 : 1}
        type="kinematicPosition" // Both controlled and remote players use kinematic positioning
        lockRotations={!isControlledPlayer} // Lock rotation for non-controlled players if needed
        linearDamping={isControlledPlayer ? 0.5 : 0}
        angularDamping={isControlledPlayer ? 0.95 : 0}
        friction={isControlledPlayer ? 0.2 : 0}
        restitution={0.0}
        gravityScale={0} // Disable gravity for all players - server handles physics
        ccd={true}
        key={playerId} // Important for React to identify elements correctly
        userData={{ type: 'player', id: playerId }} // Add userData for identification
      >
        <CapsuleCollider args={[0.5, 0.6]} />
        {/* Single unified player model */}
        <group>
          {/* Body */}
          <mesh castShadow position={[0, 0.5, 0]}>
            <capsuleGeometry args={[0.5, 1.2, 8, 16]} />
            <meshStandardMaterial color={isControlledPlayer ? "#3870c4" : "#5a8cd9"} />
          </mesh>
          {/* Head */}
          <mesh castShadow position={[0, 1.6, 0]}>
            <sphereGeometry args={[0.3, 16, 16]} />
            <meshStandardMaterial color="#f5deb3" />
          </mesh>
        </group>
      </RigidBody>

      {/* Add movement debugger */}
      <MovementDebugger 
        playerId={playerId}
        playerRef={playerRef}
        isControlledPlayer={isControlledPlayer}
      />
    </>
  );
}

// Main Players Component (Renders all players)
export default function Player() {
  const playerIds = useGameStore(selectPlayerIds);
  const myPlayerId = useGameStore(selectMyPlayerId);

  return (
    <>
      {playerIds.map(id => (
        <PlayerCharacter 
          key={id} 
          playerId={id} 
          isControlledPlayer={id === myPlayerId} 
        />
      ))}
    </>
  );
}

// ==============================================================================
// FILE: app/game/components/SimpleMovementDebugger.tsx
// ==============================================================================

// Helper component for debugging player movement in the game
import React, { useRef, useState, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { Text } from '@react-three/drei';
import { useGameStore } from '../systems/gameStore';
import { getBuffer } from '../systems/interpolation';

interface MovementDebuggerProps {
  playerId: string;
  playerRef: React.RefObject<any>;
  isControlledPlayer: boolean;
}

export function MovementDebugger({ playerId, playerRef, isControlledPlayer }: MovementDebuggerProps) {
  // Only show debugging for the controlled player
  if (!isControlledPlayer) return null;
  
  const targetMarkerRef = useRef<THREE.Mesh>(null);
  const [showDebug, setShowDebug] = useState(false);
  const [stats, setStats] = useState({ 
    distance: 0, 
    bufferSize: 0,
    position: { x: 0, z: 0 } 
  });
  
  // Get the target position from the game store
  const targetPos = useGameStore(state => state.targetWorldPos);
  
  // Toggle debug visualization with 'D' key
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'd' || e.key === 'D') {
        setShowDebug(prev => !prev);
        console.log(`Movement debugger ${!showDebug ? 'enabled' : 'disabled'}`);
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [showDebug]);
  
  // Update visualization on each frame
  useFrame(() => {
    if (!showDebug || !playerRef?.current) return;
    
    // Get current player position
    const currentPos = playerRef.current.translation();
    if (!currentPos) return;
    
    // Update the target indicator
    if (targetMarkerRef.current && targetPos) {
      targetMarkerRef.current.position.set(targetPos.x, 0.1, targetPos.z);
      targetMarkerRef.current.visible = true;
      
      // Calculate distance to target
      const distance = Math.sqrt(
        Math.pow(currentPos.x - targetPos.x, 2) + 
        Math.pow(currentPos.z - targetPos.z, 2)
      );
      
      // Get buffer info
      const buffer = getBuffer(playerId);
      const bufferSize = buffer ? buffer.getBufferLength() : 0;
      
      // Update stats
      setStats({
        distance,
        bufferSize,
        position: { x: currentPos.x, z: currentPos.z }
      });
    } else if (targetMarkerRef.current) {
      targetMarkerRef.current.visible = false;
    }
  });
  
  if (!showDebug) return null;
  
  return (
    <group>
      {/* Target marker */}
      <mesh ref={targetMarkerRef} position={[0, 0.1, 0]} visible={false}>
        <ringGeometry args={[0.3, 0.4, 16]} />
        <meshBasicMaterial color="yellow" transparent opacity={0.6} />
      </mesh>
      
      {/* Debug text */}
      {targetPos && (
        <Text
          position={[0, 2, 0]}
          fontSize={0.15}
          color="white"
          anchorX="center"
          anchorY="middle"
          outlineWidth={0.02}
          outlineColor="#000000"
        >
          {`Dist: ${stats.distance.toFixed(2)}m
Buffer: ${stats.bufferSize} entries
Pos: (${stats.position.x.toFixed(2)}, ${stats.position.z.toFixed(2)})`}
        </Text>
      )}
    </group>
  );
}


// ==============================================================================
// FILE: app/game/components/SkillTreeUI.tsx
// ==============================================================================

'use client';

import React, { useState, useEffect } from 'react';
import { useGameStore } from '../systems/gameStore';
import { SKILLS, SkillId } from '../models/Skill';
import { CLASS_SKILL_TREES, canLearnSkill, CharacterClass } from '../../../shared/classSystem';
import { useDraggedSkill, useSetDragged } from '../context/DragContext';
import skillUtils from '../systems/skillUtils';
import styles from '../styles/SkillTreeUI.module.css';
import Image from 'next/image';

const SkillTreeUI: React.FC = () => {
  const socket = useGameStore(state => state.socket);
  const player = useGameStore(state => state.getMyPlayer());
  const [availableSkills, setAvailableSkills] = useState<SkillId[]>([]);
  const [selectedClass, setSelectedClass] = useState<CharacterClass | null>(null);
  const [isSkillTreeOpen, setIsSkillTreeOpen] = useState(false);
  // New state for skill shortcuts (keys 1-9)
  const [skillShortcuts, setSkillShortcuts] = useState<(SkillId | null)[]>([null, null, null, null, null, null, null, null, null]);
  // Use the React context for drag state
  const dragged = useDraggedSkill();
  const setDragged = useSetDragged();
  
  useEffect(() => {
    // Debug log to see if component is rendering and has proper data
    console.log('SkillTreeUI rendering:', { 
      player, 
      className: player?.className,
      skillPoints: player?.availableSkillPoints,
      draggedSkill: dragged
    });
    
    // Update selected class when player data changes
    if (player?.className) {
      setSelectedClass(player.className as CharacterClass);
    }
  }, [player, dragged]);

  useEffect(() => {
    // Calculate available skills when relevant data changes
    if (selectedClass && player) {
      // Get unlearned skills that are available to learn
      const availableSkillsList: SkillId[] = [];
      const classTree = CLASS_SKILL_TREES[selectedClass];
      
      console.log('DEBUG: Calculating available skills', {
        className: selectedClass,
        level: player.level,
        unlockedSkills: player.unlockedSkills,
        skillPoints: player.availableSkillPoints
      });
      
      if (classTree) {
        for (const [skillId, requirement] of Object.entries(classTree.skillProgression)) {
          // Skip skills player already has
          if (player.unlockedSkills.includes(skillId as SkillId)) {
            console.log(`DEBUG: Skipping already unlocked skill: ${skillId}`);
            continue;
          }
          
          // Check if player can learn this skill
          const canLearn = canLearnSkill(
            skillId as SkillId,
            selectedClass,
            player.level,
            player.unlockedSkills as SkillId[]
          );
          
          console.log(`DEBUG: Skill ${skillId} can be learned: ${canLearn}`, {
            levelRequirement: requirement.level,
            playerLevel: player.level,
            requiredSkills: requirement.requiredSkills
          });
          
          if (canLearn) {
            availableSkillsList.push(skillId as SkillId);
          }
        }
      }
      
      console.log('Available skills to learn:', availableSkillsList);
      setAvailableSkills(availableSkillsList);
    }
  }, [player, selectedClass]);

  useEffect(() => {
    // Update skill shortcuts when player data changes
    if (player?.skillShortcuts) {
      setSkillShortcuts(player.skillShortcuts);
    }
  }, [player?.skillShortcuts]);
  
  // Add debugging for drag and drop events
  useEffect(() => {
    // Debug drag and drop issues
    if (typeof window !== 'undefined') {
      console.log('Setting up drag and drop debugging');
      
      const logDragEvent = (e: DragEvent, name: string) => {
        console.log(`Drag event ${name}:`, {
          types: e.dataTransfer ? Array.from(e.dataTransfer.types) : [],
          target: e.target
        });
      };
      
      window.addEventListener('dragstart', (e) => logDragEvent(e, 'dragstart'), false);
      window.addEventListener('drop', (e) => logDragEvent(e, 'drop'), false);
      
      return () => {
        window.removeEventListener('dragstart', (e) => logDragEvent(e, 'dragstart'), false);
        window.removeEventListener('drop', (e) => logDragEvent(e, 'drop'), false);
      };
    }
  }, []);

  const learnSkill = (skillId: SkillId) => {
    console.log('Attempting to learn skill:', skillId, {
      hasSocket: !!socket,
      skillPoints: player?.availableSkillPoints
    });
    
    if (socket && player?.availableSkillPoints && player.availableSkillPoints > 0) {
      console.log('Sending LearnSkill message to server');
      // Send learn skill request to server
      socket.emit('msg', {
        type: 'LearnSkill',
        skillId: skillId
      });
    } else {
      console.log('Cannot learn skill - no socket or skill points:', {
        socket: !!socket,
        skillPoints: player?.availableSkillPoints
      });
    }
  };

  const setSkillShortcut = (skillId: SkillId, slotIndex: number) => {
    if (!socket) {
      console.error('Cannot set skill shortcut: No socket connection');
      return;
    }
    
    if (!player) {
      console.error('Cannot set skill shortcut: No player data');
      return;
    }

    // Validate skill ID - make sure it's an actual skill ID, not a path or something else
    if (!SKILLS[skillId]) {
      console.error(`Cannot set skill shortcut: Invalid skill ID "${skillId}"`);
      return;
    }

    console.log(`Setting skill ${skillId} to shortcut slot ${slotIndex+1}`);
    
    try {
      // First, check if this skill already exists in another slot
      const existingIndex = skillShortcuts.findIndex(s => s === skillId);
      
      // If the skill exists somewhere else and we're not replacing it with itself,
      // clear the old slot first to prevent duplicates
      if (existingIndex !== -1 && existingIndex !== slotIndex) {
        console.log(`Skill ${skillId} already exists in slot ${existingIndex + 1}, removing it first`);
        const newShortcuts = [...skillShortcuts];
        newShortcuts[existingIndex] = null;
        setSkillShortcuts(newShortcuts);
      }
      
      // Send request to set skill shortcut
      socket.emit('msg', {
        type: 'SetSkillShortcut',
        slotIndex: slotIndex,
        skillId: skillId
      });
      
      // Immediately update local state for responsive UI
      const newShortcuts = [...skillShortcuts];
      newShortcuts[slotIndex] = skillId;
      setSkillShortcuts(newShortcuts);
      
      // Add visual feedback
      const slotElement = document.querySelector(`.${styles.shortcutSlot}:nth-child(${slotIndex + 1})`);
      if (slotElement) {
        slotElement.classList.add(styles.shortcutSuccess);
        setTimeout(() => {
          slotElement.classList.remove(styles.shortcutSuccess);
        }, 500);
      }
      
    } catch (err) {
      console.error('Error setting skill shortcut:', err);
    }
  };

  const toggleSkillTree = (e: React.MouseEvent) => {
    // Prevent event from propagating to the world
    e.preventDefault();
    e.stopPropagation();
    
    console.log('Toggle skill tree clicked');
    setIsSkillTreeOpen(!isSkillTreeOpen);
  };

  console.log('SkillTreeUI render checks:', { 
    hasPlayer: !!player, 
    playerClassName: player?.className,
    selectedClass,
    classTreeExists: selectedClass ? !!CLASS_SKILL_TREES[selectedClass] : false 
  });

  // If we don't have player data yet, render just the button for now
  if (!player) {
    console.log('No player data yet, rendering only button');
    return (
      <button 
        className={styles.skillTreeButton} 
        onClick={toggleSkillTree}
        onMouseDown={(e) => e.stopPropagation()}
        onMouseUp={(e) => e.stopPropagation()}
      >
        Skill Tree
      </button>
    );
  }

  // If we don't have a class selected or the class tree doesn't exist, just show button
  if (!selectedClass || !CLASS_SKILL_TREES[selectedClass]) {
    console.log('No class selected or class tree missing');
    return (
      <button 
        className={styles.skillTreeButton} 
        onClick={toggleSkillTree}
        onMouseDown={(e) => e.stopPropagation()}
        onMouseUp={(e) => e.stopPropagation()}
      >
        Skill Tree ({player.className})
      </button>
    );
  }

  const classTree = selectedClass ? CLASS_SKILL_TREES[selectedClass] : null;
  const canDrag = typeof window !== 'undefined' && window.matchMedia('(pointer:fine)').matches;

  return (
    <>
      <button 
        className={styles.skillTreeButton} 
        onClick={toggleSkillTree}
        onMouseDown={(e) => e.stopPropagation()}
        onMouseUp={(e) => e.stopPropagation()}
      >
        Skill Tree
      </button>

      {isSkillTreeOpen && classTree && (
        <div 
          className={styles.skillTreeOverlay}
          onClick={(e) => {
            e.stopPropagation();
            // Clear drag state when clicking the overlay
            if (dragged) setDragged(null);
          }}
        >
          <div className={styles.skillTreeContainer}>
            <div className={styles.skillTreeHeader}>
              <h2>{classTree.className} Skill Tree</h2>
              <p>{classTree.description}</p>
              <p>Available Skill Points: {player.availableSkillPoints}</p>
              <button 
                className={styles.closeButton}
                onClick={toggleSkillTree}
              >
                Close
              </button>
            </div>

            <div className={styles.skillsContainer}>
              <div className={styles.unlockedSkills}>
                <h3>Unlocked Skills</h3>
                {player.unlockedSkills.length === 0 ? (
                  <p>No skills unlocked yet</p>
                ) : (
                  <div className={styles.skillsList}>
                    {player.unlockedSkills.map((skillId) => {
                      const skill = SKILLS[skillId];
                      return (
                        <div key={skillId} 
                          className={`${styles.skillItem} ${dragged === skillId ? styles.tapSelect : ''}`}
                        >
                          <Image 
                            src={skillUtils.getSkillIconPath(skillId)} 
                            width={50}
                            height={50}
                            alt={skill.name} 
                            title={skill.description}
                            onClick={() => {
                              if (!dragged) {
                                setDragged(skillId);
                              } else {
                                setDragged(null);
                              }
                            }}
                            onDoubleClick={() => {
                              // When double-clicking a skill, assign it to the first available slot
                              console.log('Skill double-clicked:', skillId);
                              const availableSlotIndex = skillShortcuts.findIndex(skill => skill === null);
                              if (availableSlotIndex !== -1) {
                                console.log(`Assigning to first available slot: ${availableSlotIndex + 1}`);
                                setSkillShortcut(skillId, availableSlotIndex);
                              } else {
                                // If no empty slots, assign to slot 1
                                console.log('No empty slots, assigning to slot 1');
                                setSkillShortcut(skillId, 0);
                              }
                            }}
                            draggable={canDrag}
                            onDragStart={canDrag ? (e) => {
                              // Make sure we have a valid skill ID to start the drag
                              if (!SKILLS[skillId]) {
                                console.error(`Attempting to drag invalid skill: ${skillId}`);
                                return;
                              }

                              console.log('Drag started with skill ID:', skillId);

                              // Store the skill ID in our global drag state
                              setDragged(skillId);

                              // Set the drag effect to copy
                              e.dataTransfer.effectAllowed = 'copy';
                            } : undefined}
                            onDragEnd={() => {
                              console.log('Drag ended, clearing drag state');
                              setDragged(null);
                            }}
                          />
                          <span>{skill.name}</span>
                          <div className={styles.skillDetails}>
                            <p>Level Required: {skill.levelRequired}</p>
                            <p>Mana Cost: {skill.manaCost}</p>
                            <p>Cooldown: {skill.cooldownMs}ms</p>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>

              <div className={styles.availableSkills}>
                <h3>Available to Learn</h3>
                {availableSkills.length === 0 ? (
                  <p>No skills available to learn</p>
                ) : (
                  <div className={styles.skillsList}>
                    {availableSkills.map((skillId) => {
                      const skill = SKILLS[skillId];
                      return (
                        <div key={skillId} className={styles.skillItem}>
                          <Image 
                            src={skillUtils.getSkillIconPath(skillId)} 
                            alt={skill.name} 
                            title={skill.description}
                            width={50}
                            height={50}
                          />
                          <span>{skill.name}</span>
                          <div className={styles.skillDetails}>
                            <p>Level Required: {skill.levelRequired}</p>
                            <p>Mana Cost: {skill.manaCost}</p>
                            <p>Cooldown: {skill.cooldownMs}ms</p>
                          </div>
                          <button 
                            className={styles.learnButton}
                            disabled={player.availableSkillPoints <= 0}
                            onClick={() => learnSkill(skillId)}
                          >
                            Learn
                          </button>
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>
            </div>

            <div className={styles.activeSkillsSection}>
              <h3>Skill Shortcuts (1-9)</h3>
              <p>Click a skill then a number to assign it as a shortcut, or click directly to cast</p>
              
              {/* Shortcut slots */}
              <div className={styles.shortcutsPanel}>
                {skillShortcuts.map((skillId, index) => (
                  <div 
                    key={index} 
                    className={styles.shortcutSlot}
                    data-slot-index={index}
                    onClick={() => {
                      // If we have a selected skill and the user clicks a slot,
                      // set the skill to that slot (alternative to drag and drop)
                      if (dragged && SKILLS[dragged] &&
                          player?.unlockedSkills.includes(dragged)) {
                        console.log(`Slot ${index+1} clicked with skill ${dragged} selected`);
                        setSkillShortcut(dragged, index);
                        setDragged(null);
                      }
                    }}
                    onDragOver={(e) => {
                      e.preventDefault(); // Necessary to allow drop
                      e.stopPropagation();
                      e.dataTransfer.dropEffect = 'copy';
                      e.currentTarget.classList.add(styles.dragOver);
                    }}
                    onDragEnter={(e) => {
                      e.preventDefault();
                      e.currentTarget.classList.add(styles.dragOver);
                    }}
                    onDragLeave={(e) => {
                      e.preventDefault();
                      e.currentTarget.classList.remove(styles.dragOver);
                    }}
                    onDrop={(e) => {
                      e.preventDefault();
                      e.currentTarget.classList.remove(styles.dragOver);
                      
                      console.log('Drop event triggered on slot', index + 1);

                      const skillIdRaw = dragged;
                      console.log('Raw skill ID from drag state:', skillIdRaw);
                      setDragged(null);

                      // Validate and normalize the skill ID
                      const skillId = skillUtils.validateSkillId(skillIdRaw);
                      console.log('Validated skill ID:', skillId);
                      
                      if (skillId) {
                        console.log(`Valid skill found: ${skillId}, adding to slot ${index + 1}`);
                        // Add visual feedback for the drop
                        e.currentTarget.classList.add(styles.dropSuccess);
                        setTimeout(() => {
                          try {
                              e.currentTarget.classList.remove(styles.dropSuccess);
                          } catch {
                              // Ignoring errors when removing class if element no longer exists
                              console.debug('Failed to remove drop success class');
                          }
                        }, 500);
                        
                        // Set the shortcut with the validated skill ID
                        setSkillShortcut(skillId, index);
                        
                      } else {
                        console.error('Failed to get valid skill ID from drop event. Value:', skillIdRaw);
                        
                      }
                    }}
                  >
                    <div className={styles.keyNumber}>{index + 1}</div>
                    {skillId ? (
                      <Image 
                        src={skillUtils.getSkillIconPath(skillId)} 
                        alt={SKILLS[skillId] ? SKILLS[skillId].name : skillId} 
                        title={SKILLS[skillId] ? SKILLS[skillId].description : skillId}
                        width={50}
                        height={50}
                      />
                    ) : (
                      <div className={styles.emptySlot} />
                    )}
                  </div>
                ))}
              </div>
              
            </div>
          </div>
        </div>
      )}
    </>
  );
};

export default SkillTreeUI;


// ==============================================================================
// FILE: app/game/components/StatusEffects.tsx
// ==============================================================================

'use client';

import React, { useCallback, useMemo } from 'react';
import { useGameStore, StatusEffect } from '../systems/gameStore';
import Image from 'next/image';

interface StatusEffectsProps {
  targetId: string | 'player';
  position?: 'top' | 'right' | 'bottom' | 'left';
  inline?: boolean;
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
const StatusEffects = React.memo(React.forwardRef<HTMLDivElement, StatusEffectsProps>(({ targetId, position = 'top', inline = false }, ref) => {
  // Format to show time remaining
  const formatTimeRemainingMs = useCallback((effect: StatusEffect) => {
    const currentTimeMs = Date.now();
    const elapsedTimeMs = currentTimeMs - effect.startTimeTs;
    const remainingTimeMs = Math.max(0, effect.durationMs - elapsedTimeMs);
    // Return actual millisecond value for precise display
    return remainingTimeMs;
  }, []);

  // Get position classes
  const getPositionClasses = useCallback(() => {
    if (inline) return "flex flex-wrap gap-1";
    
    switch(position) {
      case 'top': return "absolute -top-7 left-1/2 transform -translate-x-1/2 flex gap-1";
      case 'bottom': return "absolute -bottom-7 left-1/2 transform -translate-x-1/2 flex gap-1";
      case 'left': return "absolute top-1/2 -left-7 transform -translate-y-1/2 flex flex-col gap-1";
      case 'right': return "absolute top-1/2 -right-7 transform -translate-y-1/2 flex flex-col gap-1";
      default: return "absolute -top-7 left-1/2 transform -translate-x-1/2 flex gap-1";
    }
  }, [inline, position]);

  // Create a stable memoized selector to avoid infinite loops
  const selectEffects = useMemo(() => {
    // Cache for the last result to compare with shallow equality
    let lastResult: StatusEffect[] = [];
    
    // Return a selector function that's stable across renders
    return (state: any) => {
      let newResult: StatusEffect[];
      
      if (targetId === 'player') {
        const pid = state.myPlayerId;
        newResult = pid ? state.players[pid]?.statusEffects ?? [] : [];
      } else {
        newResult = state.enemies[targetId]?.statusEffects ?? [];
      }
      
      // Only update the reference if the content has changed
      // This is a simple shallow comparison - checks if arrays have the same items
      const hasChanged = 
        lastResult.length !== newResult.length || 
        newResult.some((effect, i) => effect !== lastResult[i]);
      
      if (hasChanged) {
        lastResult = newResult;
      }
      
      return lastResult;
    };
  }, [targetId]);
  
  // Use the memoized selector with the store
  const effects = useGameStore(selectEffects);
  
  if (effects.length === 0) return null;

  return (
    <div className={getPositionClasses()}>
      {effects.map((effect: StatusEffect) => {
        const effectClassName = `effect-${effect.type}`;
        
        return (
          <div 
            key={effect.id} 
            className={`bg-gray-600 w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold text-white relative overflow-hidden ${effectClassName}`}
            title={`${effect.type}: ${effect.value}% - ${formatTimeRemainingMs(effect)}ms remaining`}
            style={{
              backgroundColor: `var(--effect-${effect.type}-color, #6b7280)`
            }}
          >
            <Image 
              src={`/game/skills/effect_${effect.type}.png`} 
              width={24}
              height={24}
              alt={effect.type} 
              className="w-full h-full object-cover"
              onError={(e) => {
                e.currentTarget.style.display = 'none';
                e.currentTarget.parentElement!.innerHTML = effect.type.charAt(0).toUpperCase();
              }}
            />
            <div className="absolute -bottom-4 left-1/2 transform -translate-x-1/2 text-[10px] bg-black/50 px-1 rounded">
              {formatTimeRemainingMs(effect)}ms
            </div>
          </div>
        );
      })}
    </div>
  );
}));

StatusEffects.displayName = 'StatusEffects';

export default StatusEffects;

// ==============================================================================
// FILE: app/game/components/TargetRing.tsx
// ==============================================================================

import { useGameStore } from '../systems/gameStore';
import { memo } from 'react';

export default memo(function TargetRing() {
  const pos = useGameStore(s => s.targetWorldPos);
  
  if (!pos) return null;
  
  return (
    <mesh position={[pos.x, pos.y, pos.z]} rotation={[-Math.PI/2, 0, 0]}>
      <ringGeometry args={[0.3, 0.5, 16]} />
      <meshBasicMaterial color="#ffff00" transparent opacity={0.6} />
    </mesh>
  );
});


// ==============================================================================
// FILE: app/game/components/UI.tsx
// ==============================================================================

'use client';

import React, { useEffect, useState, useRef, useCallback, useMemo } from 'react';
import { useGameStore } from '../systems/gameStore';
import { SKILLS, Skill, SkillId } from '../models/Skill';
import StatusEffects from './StatusEffects';
import ConnectionStatus from './ConnectionStatus';
import SkillTreeUI from './SkillTreeUI';
import CombatLog from './HUD/CombatLog';
import { GAME_ZONES } from '../systems/zoneSystem';
import Image from 'next/image';
import { tryStartCast } from '../systems/castController';

// Helper function to validate if a string is a valid SkillId
function isValidSkillId(id: string | null): id is SkillId {
  if (!id) return false;
  return id in SKILLS; // Check if the ID exists in the SKILLS object
}


// Add explicit global window typings for our custom method
declare global {
  interface Window {
    castFireball?: () => void;
  }
}

interface SkillButtonProps {
  skill: Skill;
  cooldownEndMs: number; // timestamp in milliseconds when cooldown ends
  isCasting: boolean;
  castProgressMs: number;
  onClick: (event: React.MouseEvent) => void;
  selectedTarget: any;
  isFlashing?: boolean; // Added to handle cast fail visual feedback
}

// Memoize SkillButton to prevent unnecessary re-renders
const SkillButton = React.memo(({ skill, cooldownEndMs, isCasting, castProgressMs, onClick, selectedTarget, isFlashing = false }: SkillButtonProps) => {
  const initial = Math.max(0, cooldownEndMs - Date.now());
  const [remainingCooldownMs, setRemainingCooldownMs] = useState(initial);
  const [castProgress, setCastProgress] = useState(0); // 0-100 percentage of cast completion
  const buttonRef = useRef<HTMLButtonElement>(null);
  
  // Update cooldown timer
  useEffect(() => {
    const update = () => 
      setRemainingCooldownMs(Math.max(0, cooldownEndMs - Date.now()));
    
    update(); // Update immediately
    if (cooldownEndMs <= Date.now()) return; // Already over
    
    const interval = setInterval(update, 100); // Keep in sync
    
    return () => clearInterval(interval);
  }, [cooldownEndMs]);
  
  // Update cast progress
  useEffect(() => {
    if (!isCasting) {
      setCastProgress(0);
      return;
    }
    
    const updateCastProgress = () => {
      if (skill.castTimeMs <= 0) return; // Instant cast
      
      // Calculate progress percentage (0-100)
      const progress = Math.min(100, (castProgressMs / skill.castTimeMs) * 100);
      setCastProgress(progress);
    };
    
    updateCastProgress();
    const interval = setInterval(updateCastProgress, 50);
    
    return () => clearInterval(interval);
  }, [isCasting, castProgressMs, skill.castTimeMs]);
  
  const isOnCooldown = remainingCooldownMs > 0;
  const isUsable = Boolean(selectedTarget) && !isOnCooldown && !isCasting;
  
  // Handle click with stopPropagation
  const handleClick = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (isUsable) {
      onClick(e);
    }
  }, [isUsable, onClick]);
  
  // Extract debuff effects from the skill
  const debuffEffects = useMemo(() => 
    skill.effects.filter(effect => effect.type !== 'damage' && effect.type !== 'dot'),
    [skill.effects]
  );

  useEffect(() => {
    const button = buttonRef.current;
    if (!button) return;
    
    const handleMouseEnter = () => {
      if (isUsable) {
        button.style.transform = 'scale(1.1)';
        button.style.boxShadow = '0 0 10px #9945FF';
      }
    };
    
    const handleMouseLeave = () => {
      button.style.transform = 'scale(1)';
      button.style.boxShadow = 'none';
    };
    
    button.addEventListener('mouseenter', handleMouseEnter);
    button.addEventListener('mouseleave', handleMouseLeave);
    
    return () => {
      button.removeEventListener('mouseenter', handleMouseEnter);
      button.removeEventListener('mouseleave', handleMouseLeave);
    };
  }, [isUsable]);

  // Map skill IDs to their correct image paths
  const getSkillImagePath = (skillId: string) => {
    // Special case mapping for waterSplash which uses the water image
    if (skillId === 'waterSplash') return '/game/skills/skill_water.png';
    return `/game/skills/skill_${skillId}.png`;
  };

  return (
    <div className="flex flex-col items-center">
      <button
        ref={buttonRef}
        className={`relative w-12 h-12 rounded transition-all duration-200 ${
          isFlashing ? 'bg-red-700 ring-2 ring-red-500' :
          isCasting ? 'bg-purple-700 ring-2 ring-purple-300' :
          isOnCooldown ? 'bg-gray-600' : 
          !selectedTarget ? 'bg-gray-500 opacity-50' :
          'bg-gray-800 hover:bg-gray-700'
        } flex items-center justify-center pointer-events-auto focus:outline-none overflow-hidden`}
        onClick={handleClick}
        disabled={!isUsable}
        style={{ transition: 'transform 0.2s, box-shadow 0.2s' }}
      >
        {/* Skill icon - using mapped path */}
        <Image 
          src={getSkillImagePath(skill.id)}
          alt={skill.name} 
          width={48}
          height={48}
          className="w-full h-full object-cover"
          onError={(e) => {
            // If image fails to load, show fallback
            if (e.currentTarget.parentElement) {
              e.currentTarget.style.display = 'none';
              // Create a text node with the first letter instead of using innerHTML
              const fallbackText = document.createTextNode(skill.id.charAt(0).toUpperCase());
              e.currentTarget.parentElement.appendChild(fallbackText);
            }
          }}
        />
        
        {/* Cooldown overlay */}
        {isOnCooldown && (
          <>
            <div 
              className="absolute inset-0 bg-gray-800 opacity-70"
              style={{ 
                // Reveal skill icon from top to bottom as cooldown progresses
                clipPath: `inset(${(1 - remainingCooldownMs / skill.cooldownMs) * 100}% 0 0 0)` 
              }}
            ></div>
            <div className="absolute text-white font-bold text-sm">
              {Math.ceil(remainingCooldownMs / 1000)}s
            </div>
          </>
        )}
        
        {/* Casting progress overlay */}
        {isCasting && (
          <>
            <div 
              className="absolute inset-0 bg-purple-600 opacity-70"
              style={{ 
                // Fill from bottom to top as cast progresses
                clipPath: `inset(${100 - castProgress}% 0 0 0)` 
              }}
            ></div>
            <div className="absolute text-white font-bold text-sm">
              {Math.ceil((skill.castTimeMs - castProgressMs) / 1000)}s
            </div>
          </>
        )}
        
        {/* Tooltip */}
        <div className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 w-48 bg-gray-800 p-2 rounded text-xs text-white opacity-0 hover:opacity-100 transition-opacity z-50 pointer-events-none">
          <div className="font-bold">{skill.name}</div>
          <div className="mt-1">{skill.description}</div>
          <div className="mt-1">Mana: {skill.manaCost}</div>
          <div className="mt-1">Cooldown: {skill.cooldownMs}ms</div>
          {skill.castTimeMs > 0 && <div>Cast Time: {skill.castTimeMs}ms</div>}
          {skill.damage && <div>Damage: {skill.damage}</div>}
          
          {/* Show skill effects in tooltip */}
          {debuffEffects.length > 0 && (
            <div className="mt-1 pt-1 border-t border-gray-600">
              <div className="font-bold text-yellow-300">Effects:</div>
              <ul className="list-disc list-inside">
                {debuffEffects.map((effect, index) => (
                  <li key={index}>
                    {effect.type.charAt(0).toUpperCase() + effect.type.slice(1)}: 
                    {                    effect.type === 'burn' || effect.type === 'poison' ? 
                      ` ${effect.value}% damage over time` : 
                      effect.type === 'slow' || effect.type === 'waterWeakness' ? 
                      ` ${effect.value}%` : 
                      ` ${effect.value}`}
                    {effect.durationMs ? ` for ${effect.durationMs / 1000}s` : ''}
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>
      </button>
      
      {/* Debuff effects indicators - icons only, no labels */}
      {debuffEffects.length > 0 && (
        <div className="mt-1 flex space-x-1 justify-center">
          {debuffEffects.map((effect, index) => {
            // Generic emoji mapping for fallbacks (if needed)
            const defaultEmojis: Record<string, string> = {
              default: "⚠️"  // Default fallback
            };
            
            // Generate colored background dynamically based on effect type
            const effectClassName = `effect-${effect.type}`;
            
            return (
              <div
                key={index}
                className={`bg-gray-600 w-4 h-4 rounded-full flex items-center justify-center text-[10px] text-white overflow-hidden ${effectClassName}`}
                title={`${effect.type}: ${effect.value}%${effect.durationMs ? ` for ${effect.durationMs / 1000}s` : ''}`}
                style={{
                  // Dynamic background color based on effect type
                  backgroundColor: `var(--effect-${effect.type}-color, #6b7280)`
                }}
              >
                <Image 
                  src={`/game/skills/effect_${effect.type}.png`}
                  alt={effect.type} 
                  width={16}
                  height={16}
                  className="w-full h-full object-cover"
                  onError={(e) => {
                    // If image fails to load, use first character of effect type
                    e.currentTarget.style.display = 'none';
                    e.currentTarget.parentElement!.innerHTML = defaultEmojis[effect.type] || 
                      effect.type.charAt(0).toUpperCase();
                  }}
                />
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
}, (prevProps, nextProps) => {
  // Custom comparison function for memo
  return prevProps.skill.id === nextProps.skill.id &&
    prevProps.cooldownEndMs === nextProps.cooldownEndMs &&
    prevProps.isCasting === nextProps.isCasting &&
    prevProps.castProgressMs === nextProps.castProgressMs &&
    prevProps.selectedTarget?.id === nextProps.selectedTarget?.id;
});

SkillButton.displayName = 'SkillButton';

export default React.memo(function UI() {
  const player = useGameStore((state) => state.getMyPlayer());
  const enemies = useGameStore((state) => state.enemies);
  const selectedTargetId = useGameStore((state) => state.selectedTargetId);
  const skillCooldownEndTs = player?.skillCooldownEndTs ?? {};
  const castingSkill = player?.castingSkill ?? null;
  const castingProgressMs = player?.castingProgressMs ?? 0;
  const currentZoneId = useGameStore(state => state.currentZoneId);
  const flashingSkill = useGameStore(state => state.flashingSkill);
  
  // Memoize selected target lookup
  const selectedTarget = useMemo(() => 
    selectedTargetId ? enemies[selectedTargetId] : null,
    [selectedTargetId, enemies]
  );
  
  // Memoize available skills filtering
  const availableSkills = useMemo(() => {
    if (!player || !player.skillShortcuts) return [];
    
    // Filter out null values and map to skill objects
    return player.skillShortcuts
      .filter(skillId => skillId !== null && isValidSkillId(skillId))
      .map(skillId => SKILLS[skillId as SkillId])
      .filter((skill): skill is Skill => skill !== undefined);
  }, [player?.skillShortcuts]);

  // Debug log when skills panel renders
  useEffect(() => {
    console.log('Skills panel render:', {
      skillCount: availableSkills.length,
      skillIds: availableSkills.map(s => s.id),
      hasPlayer: !!player,
      selectedTargetId
    });
  }, [availableSkills, player, selectedTargetId]);
  
  const currentZone = useMemo(() => 
    GAME_ZONES.find(zone => zone.id === currentZoneId),
    [currentZoneId]
  );
  
  const handleSkillClick = useCallback((skillId: string) => (event: React.MouseEvent) => {
    event.stopPropagation();
    console.log('Attempting to cast skill via UI component');
    
    // Use the unified cast controller
    if (isValidSkillId(skillId)) {
      tryStartCast(skillId, selectedTargetId || undefined);
    } else {
      console.warn(`Invalid skill ID: ${skillId}`);
    }
  }, [selectedTargetId]);

  return (
    <div className="fixed inset-0 pointer-events-none">
      {/* Top UI - Target info */}
      {selectedTarget && (
        <div className="absolute top-5 left-1/2 transform -translate-x-1/2 bg-gray-900/80 p-3 rounded-lg flex items-center space-x-4">
          <div className="text-white font-bold">{selectedTarget.name}</div>
          <div className="w-48 h-2 bg-gray-700 rounded-full overflow-hidden">
            <div 
              className="h-full bg-red-600"
              style={{ width: `${(selectedTarget.health / selectedTarget.maxHealth) * 100}%` }}
            ></div>
          </div>
          <div className="text-white text-sm">
            {selectedTarget.health}/{selectedTarget.maxHealth} HP
          </div>
          {/* Display debuffs on target */}
          <div className="relative pl-2">
            <StatusEffects targetId={selectedTarget.id} position="right" />
          </div>
        </div>
      )}
      
      {/* Bottom UI - Player stats and skills */}
      <div className="absolute bottom-5 left-1/2 transform -translate-x-1/2 w-full max-w-3xl px-5">
        {/* Casting Bar */}
        {castingSkill && (
          <div className="mt-3 bg-gray-900/80 p-3 rounded-lg">
            <div className="flex justify-between text-sm text-white mb-1">
              <div>Casting: {SKILLS[castingSkill]?.name}</div>
              <div>{castingProgressMs}ms / {SKILLS[castingSkill]?.castTimeMs}ms</div>
            </div>
            <div className="w-full h-2 bg-gray-700 rounded-full overflow-hidden">
              <div 
                className="h-full bg-purple-600"
                style={{ 
                  width: `${(castingProgressMs / SKILLS[castingSkill]?.castTimeMs) * 100}%` 
                }}
              ></div>
            </div>
          </div>
        )}
        {/* Player Info */}
        <div className="bg-gray-900/80 p-3 rounded-lg mb-3">
          <div className="flex justify-between items-center mb-2">
            <div className="text-white font-bold">{player?.name || 'Player'} {player?.level || 1}</div>
            <div className="text-gray-300 text-sm">
              XP: {player?.experience || 0}/{player?.experienceToNextLevel || 100}
            </div>
          </div>
          
          {/* Experience Bar */}
          <div className="mb-2">
            <div className="w-full h-1 bg-gray-700 rounded-full overflow-hidden">
              <div 
                className="h-full bg-gray-400"
                style={{ width: `${player?.experience && player?.experienceToNextLevel ? (player.experience / player.experienceToNextLevel) * 100 : 0}%` }}
              ></div>
            </div>
          </div>
          
          {/* Health Bar */}
          <div className="mb-2">
            <div className="w-full h-2 bg-gray-700 rounded-full overflow-hidden">
              <div 
                className="h-full bg-red-600"
                style={{ width: `${player?.health && player?.maxHealth ? (player.health / player.maxHealth) * 100 : 0}%` }}
              ></div>
            </div>
            <div className="flex justify-between text-sm text-white mt-1">
              <div>HP</div>
              <div>{player ? Math.floor(player.health) : 0}/{player?.maxHealth || 100}</div>
            </div>
          </div>
          
          {/* Mana Bar */}
          <div>
            <div className="w-full h-2 bg-gray-700 rounded-full overflow-hidden">
              <div 
                className={`h-full ${useGameStore(state => state.manaBarFlash) ? 'bg-red-600' : 'bg-blue-600'}`}
                style={{ width: `${player?.mana && player?.maxMana ? (player.mana / player.maxMana) * 100 : 0}%` }}
              ></div>
            </div>
            <div className="flex justify-between text-sm text-white mt-1">
              <div>MP</div>
              <div>{player ? Math.floor(player.mana) : 0}/{player?.maxMana || 100}</div>
            </div>
          </div>
          
          {/* Player status effects */}
          <div className="mt-2">
            <StatusEffects targetId="player" inline={true} />
          </div>
        </div>
        
        {/* Skills */}
        <div className="bg-gray-900/80 p-3 rounded-lg">
          <div className="flex space-x-3">
            {availableSkills.map((skill, index) => (
              <SkillButton 
                key={`${skill.id}-${index}`} // Add index to ensure uniqueness
                skill={skill}
                cooldownEndMs={skillCooldownEndTs[skill.id] || 0}
                isCasting={castingSkill === skill.id}
                castProgressMs={castingProgressMs}
                onClick={handleSkillClick(skill.id)}
                selectedTarget={selectedTarget}
                isFlashing={flashingSkill === skill.id}
              />
            ))}
          </div>
        </div>
        
      </div>

      {/* Zone indicator */}
      <div className="absolute top-4 left-4 bg-black/50 text-white p-4 rounded-lg">
        <h2 className="text-xl font-bold">
          {currentZone?.name || 'Wilderness'}
        </h2>
        {currentZone && (
          <div className="text-sm opacity-80">
            <p>{currentZone.description}</p>
            <p className="mt-1">Level {currentZone.minLevel}-{currentZone.maxLevel}</p>
          </div>
        )}
      </div>
      
      {/* Skill Tree UI */}
      <SkillTreeUI />
      
      {/* Connection status indicator */}
      <ConnectionStatus />

      {/* Combat Log */}
      <CombatLog />
    </div>
  );
});

// ==============================================================================
// FILE: app/game/components/VfxManager.tsx
// ==============================================================================

import { useEffect, useState, useCallback, useMemo } from 'react';
import { Group } from 'three';
import FireballProjectile from '../vfx/FireballProjectile';
import IceBoltVfx from '../vfx/IceBoltVfx';
import WaterProjectile from '../vfx/WaterProjectile';
import ProjectileVfx from '../vfx/ProjectileVfx';
import SplashVfx from '../vfx/SplashVfx';
import { PetrifyFlash } from '../vfx/PetrifyFlash';
import { InstantHit } from '../../../shared/messages';
import { useProjectileStore, ProjectileData } from '../systems/projectileStore';
import { get as poolGet, recycle, registerPool } from '../systems/vfxPool';

// Types for VFX instances
interface BaseVfxInstance {
  id: string;
  type: string;
  createdAt: number;
  expiresAt?: number;
}

interface ProjectileVfxInstance extends BaseVfxInstance {
  type: 'projectile';
  skillId: string;
  origin: { x: number; y: number; z: number };
  dir: { x: number; y: number; z: number };
  speed: number;
  launchTs: number;
}

interface SplashVfxInstance extends BaseVfxInstance {
  type: 'splash';
  position: { x: number; y: number; z: number };
  radius: number;
}

interface FlashVfxInstance extends BaseVfxInstance {
  type: 'flash';
  flashType: 'stun' | 'petrify';
  position: { x: number; y: number; z: number };
}

type VfxInstance = ProjectileVfxInstance | SplashVfxInstance | FlashVfxInstance;

export default function VfxManager() {
  // Store all active VFX instances
  const [vfxInstances, setVfxInstances] = useState<VfxInstance[]>([]);
  
  // Get projectiles from the store directly
  const liveProjectiles = useProjectileStore(state => state.live);
  const recycleProjectiles = useProjectileStore(state => state.toRecycle);
  const clearRecycled = useProjectileStore(state => state.clearRecycled);
  
  // Cache the projectiles array with useMemo to prevent unnecessary re-renders
  const projectileArray = useMemo(() => {
    const projArray = Object.values(liveProjectiles);
    console.log('[VfxManager] Rendering projectileArray:', projArray.map(p => ({ 
      castId: p.castId, 
      skillId: p.skillId 
    })));
    
    // Add specific logging for fireball
    const fireballs = projArray.filter(p => p.skillId === 'fireball');
    if (fireballs.length > 0) {
      console.log(`[VfxManager] Fireballs in projectileArray (${fireballs.length}):`, fireballs.map(f => ({ 
        castId: f.castId, 
        origin: f.origin, 
        dir: f.dir, 
        speed: f.speed, 
        launchTs: f.launchTs 
      })));
    } else if (projArray.some(p => p.skillId === 'fireball')) {
      console.log('[VfxManager] Fireball detected but not logged in detail.');
    }
    
    // Check for duplicate castIds which would cause multiple projectiles
    const castIds = projArray.map(p => p.castId);
    const duplicates = castIds.filter((id, index) => castIds.indexOf(id) !== index);
    if (duplicates.length > 0) {
      console.warn('[VfxManager] Duplicate projectile castIds detected:', duplicates);
    }
    
    return projArray;
  }, [liveProjectiles]);
  
  // Track active pooled projectiles
  const [pooledInstances, setPooledInstances] = useState<Map<string, Group>>(new Map());
  
  // Initialize pools
  useEffect(() => {
    // Register pools for each projectile type
    registerPool('fireball', () => {
      const group = new Group();
      return group;
    });
    
    registerPool('iceBolt', () => {
      const group = new Group();
      return group;
    });
    
    registerPool('waterSplash', () => {
      const group = new Group();
      return group;
    });
    
    registerPool('default', () => {
      const group = new Group();
      return group;
    });
    
    return () => {
      // Cleanup if needed
    };
  }, []);

  // Handle instant hit events
  const handleInstantHit = useCallback((e: CustomEvent<InstantHit>) => {
    console.log('VfxManager: Instant hit', e.detail);
    
    if (e.detail.skillId && e.detail.targetPos) {
      const position = e.detail.targetPos;
      
      // Generate effects based on skill type
      switch (e.detail.skillId) {
        case 'petrify':
          createFlashEffect(position, 'petrify');
          break;
      }
    }
  }, []);
  
  // Create a splash effect
  const createSplashEffect = useCallback((position: any, radius: number) => {
    const id = `splash-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
    const newSplash: SplashVfxInstance = {
      id,
      type: 'splash',
      position,
      radius,
      createdAt: performance.now(),
      expiresAt: performance.now() + 1000, // 1s duration for splashes
    };
    
    setVfxInstances(prev => [...prev, newSplash]);
  }, []);
  
  // Handle custom splash spawn events
  const handleSpawnSplash = useCallback((e: CustomEvent<{position: any, radius: number}>) => {
    createSplashEffect(e.detail.position, e.detail.radius);
  }, []);
  
  // Create a flash effect (stun or petrify)
  const createFlashEffect = useCallback((position: any, flashType: 'stun' | 'petrify') => {
    const id = `${flashType}-flash-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
    const newFlash: FlashVfxInstance = {
      id,
      type: 'flash',
      flashType,
      position,
      createdAt: performance.now(),
      expiresAt: performance.now() + 500, // 0.5s duration for flashes
    };
    
    setVfxInstances(prev => [...prev, newFlash]);
  }, []);
  
  // Handle stun flash events
  const handleSpawnStunFlash = useCallback((e: CustomEvent<{position: any}>) => {
    createFlashEffect(e.detail.position, 'stun');
  }, [createFlashEffect]);
  
  // Handle petrify flash events
  const handleSpawnPetrifyFlash = useCallback((e: CustomEvent<{position: any}>) => {
    createFlashEffect(e.detail.position, 'petrify');
  }, [createFlashEffect]);
  
  // Register and unregister event listeners
  useEffect(() => {
    // Register event listeners for non-projectile events
    window.addEventListener('instanthit', handleInstantHit as EventListener);
    window.addEventListener('spawnSplash', handleSpawnSplash as EventListener);
    window.addEventListener('spawnStunFlash', handleSpawnStunFlash as EventListener);
    window.addEventListener('petrifyFlash', handleSpawnPetrifyFlash as EventListener);
    
    // Cleanup expired effects periodically
    const cleanupInterval = setInterval(() => {
      const now = performance.now();
      
      // Filter out expired and projectile effects (projectiles now come from the store)
      setVfxInstances(prev => prev.filter(vfx => 
        (vfx.type !== 'projectile') && (!vfx.expiresAt || vfx.expiresAt > now)
      ));
      
      // Process projectiles that need to be recycled
      Object.entries(recycleProjectiles).forEach(([castId, projectile]) => {
        if (pooledInstances.has(castId)) {
          const type = projectile.skillId || 'default';
          const instance = pooledInstances.get(castId);
          
          if (instance) {
            console.log(`[VfxManager] Recycling projectile with castId: ${castId}`);
            // Make sure the instance is invisible before recycling
            instance.visible = false;
            // Recycle the projectile
            recycle(type, instance);
            // Remove from active instances
            setPooledInstances(prev => {
              const newMap = new Map(prev);
              newMap.delete(castId);
              return newMap;
            });
            // Clear from store
            clearRecycled(castId);
          }
        } else {
          // If there's a projectile to recycle but no pooled instance, just clear it from the store
          console.log(`[VfxManager] No pooled instance found for projectile ${castId}, just clearing from store`);
          clearRecycled(castId);
        }
      });
    }, 100);
    
    // Cleanup on unmount
    return () => {
      window.removeEventListener('instanthit', handleInstantHit as EventListener);
      window.removeEventListener('spawnSplash', handleSpawnSplash as EventListener);
      window.removeEventListener('spawnStunFlash', handleSpawnStunFlash as EventListener);
      window.removeEventListener('petrifyFlash', handleSpawnPetrifyFlash as EventListener);
      clearInterval(cleanupInterval);
    };
  }, [
    handleInstantHit, 
    handleSpawnSplash, 
    handleSpawnStunFlash, 
    handleSpawnPetrifyFlash,
    recycleProjectiles,
    pooledInstances,
    clearRecycled
  ]);
  
  // Render all active VFX instances
  return (
    <>
      {/* Render projectiles from the store */}
      {projectileArray.map((proj: ProjectileData) => {
        // For each projectile in the store, create the appropriate VFX
        const skillId = proj.skillId || 'default';
        const origin = { 
          x: proj.origin.x, 
          y: proj.origin.y || 1.5, // Use server-provided y or default to 1.5
          z: proj.origin.z 
        };
        const dir = { 
          x: proj.dir.x, 
          y: 0, // No vertical movement
          z: proj.dir.z 
        };
        
        // Get or create a pooled group for this projectile
        let group: Group;
        if (!pooledInstances.has(proj.castId)) {
          // Only create a new pooled instance if one doesn't already exist
          console.log(`[VfxManager] Creating new pooled group for projectile ${proj.castId}`);
          group = poolGet(skillId);
          
          // Add to active instances
          setPooledInstances(prev => {
            const newMap = new Map(prev);
            newMap.set(proj.castId, group);
            return newMap;
          });
        } else {
          group = pooledInstances.get(proj.castId)!;
          console.log(`[VfxManager] Reusing existing pooled group for projectile ${proj.castId}`);
        }
        
        // Explicitly ensure the group is visible
        group.visible = true;
        
        // Render appropriate projectile with pooled group
        const handleDone = () => {
          if (pooledInstances.has(proj.castId)) {
            console.log(`[VfxManager] handleDone called for projectile ${proj.castId}`);
            const skillType = skillId || 'default';
            const pooledGroup = pooledInstances.get(proj.castId)!;
            
            // Make sure it's invisible before recycling
            pooledGroup.visible = false;
            recycle(skillType, pooledGroup);
            
            setPooledInstances(prev => {
              const newMap = new Map(prev);
              newMap.delete(proj.castId);
              return newMap;
            });
          }
        };
        
        switch (skillId) {
          case 'fireball':
            console.log(`[VfxManager] Rendering FireballProjectile for castId: ${proj.castId}, pooled group ID: ${group.uuid}, visible: ${group.visible}`);
            return (
              <FireballProjectile
                key={proj.castId}
                id={proj.castId}
                origin={origin}
                dir={dir}
                speed={proj.speed}
                launchTs={proj.launchTs}
                pooled={group}
                onDone={handleDone}
              />
            );
          case 'iceBolt':
            return (
              <IceBoltVfx
                key={proj.castId}
                id={proj.castId}
                origin={origin}
                dir={dir}
                speed={proj.speed}
                launchTs={proj.launchTs}
                pooled={group}
                onDone={handleDone}
              />
            );
          case 'waterSplash':
            return (
              <WaterProjectile
                key={proj.castId}
                id={proj.castId}
                origin={origin}
                dir={dir}
                speed={proj.speed}
                launchTs={proj.launchTs}
                pooled={group}
                onDone={handleDone}
              />
            );
          default:
            return (
              <ProjectileVfx
                key={proj.castId}
                id={proj.castId}
                origin={origin}
                dir={dir}
                speed={proj.speed}
                launchTs={proj.launchTs}
                pooled={group}
                onDone={handleDone}
              />
            );
        }
      })}
      
      {/* Render other VFX instances */}
      {vfxInstances.map(vfx => {
        if (vfx.type === 'splash') {
          return (
            <SplashVfx
              key={vfx.id}
              position={vfx.position}
              radius={vfx.radius}
            />
          );
        } else if (vfx.type === 'flash') {
          if (vfx.flashType === 'petrify') {
            return (
              <PetrifyFlash
                key={vfx.id}
                position={vfx.position}
              />
            );
          } else {
            // Stun flash would go here if it were a separate component
            return (
              <SplashVfx
                key={vfx.id}
                position={vfx.position}
                radius={0.8}
              />
            );
          }
        }
        
        return null;
      })}
    </>
  );
}


// ==============================================================================
// FILE: app/game/components/World.tsx
// ==============================================================================

'use client';

import { RigidBody } from '@react-three/rapier';
import { useRef} from 'react';
import { useFrame } from '@react-three/fiber';
import { Billboard, Text } from '@react-three/drei';
import { useGameStore } from '../systems/gameStore';
import { GAME_ZONES } from '../systems/zoneSystem';
import * as THREE from 'three';

export default function World() {
  const terrainRef = useRef<THREE.Mesh>(null);
  const updatePlayerZone = useGameStore(state => state.updatePlayerZone);
  
  // Update player's current zone
  useFrame(() => {
    updatePlayerZone();
  });
  
  return (
    <>
      {/* Ground - Expanded to 10x size */}
      <RigidBody type="fixed" colliders="trimesh">
        <mesh 
          ref={terrainRef} 
          position={[0, -0.5, 0]} 
          rotation={[-Math.PI / 2, 0, 0]} 
          receiveShadow
          userData={{ groundPlane: true }}
        >
          <planeGeometry args={[1000, 1000, 64, 64]} />
          <meshStandardMaterial 
            color="#3a7e4c" 
            roughness={0.8}
            side={THREE.DoubleSide} // Render both sides to ensure visibility
          />
        </mesh>
      </RigidBody>
      
      {/* Zone Markers */}
      {GAME_ZONES.map(zone => (
        <group key={zone.id}>
          {/* Zone boundary indicator - semi-transparent circle */}
          <mesh 
            position={[zone.position.x, 0.1, zone.position.z]} 
            rotation={[-Math.PI / 2, 0, 0]}
          >
            <circleGeometry args={[zone.radius, 32]} />
            <meshBasicMaterial 
              color={getZoneColor(zone.id)} 
              transparent 
              opacity={0.1} 
            />
          </mesh>
          
          {/* Zone name text - Raised higher and made smaller */}
          <Billboard 
            position={[zone.position.x, 8, zone.position.z]}
            follow={true}
            lockX={false}
            lockY={false}
            lockZ={false}
          >
            <Text
              color="white"
              fontSize={3}
              outlineWidth={0.3}
              outlineColor="black"
              textAlign="center"
              material-transparent
              material-opacity={0.7}
            >
              {zone.name}
              {`\nLevel ${zone.minLevel}-${zone.maxLevel}`}
            </Text>
          </Billboard>
        </group>
      ))}
      
      {/* Environmental Objects */}
      <group>
        {/* Distribute environmental objects based on zones */}
        {GAME_ZONES.map(zone => (
          <group key={`env-${zone.id}`}>
            {zone.id === 'dark_forest' && (
              <Forest 
                position={[zone.position.x, 0, zone.position.z]} 
                count={50} 
                spread={zone.radius * 0.8} 
              />
            )}
            
            {zone.id === 'rocky_highlands' && (
              <>
                <Rocks 
                  position={[zone.position.x, 0, zone.position.z]} 
                  count={20} 
                  spread={zone.radius * 0.7} 
                />
                <BoulderField 
                  position={[zone.position.x, 0, zone.position.z]} 
                  count={15} 
                  spread={zone.radius * 0.6} 
                />
              </>
            )}
            
            {zone.id === 'misty_lake' && (
              <>
                <mesh 
                  position={[zone.position.x, -0.2, zone.position.z]} 
                  rotation={[-Math.PI / 2, 0, 0]}
                >
                  <circleGeometry args={[zone.radius * 0.6, 32]} />
                  <meshStandardMaterial 
                    color="#0077be" 
                    transparent 
                    opacity={0.8} 
                  />
                </mesh>
                <Bushes 
                  position={[zone.position.x, 0, zone.position.z]} 
                  count={30} 
                  spread={zone.radius * 0.8} 
                />
              </>
            )}
            
            {zone.id === 'starter_meadow' && (
              <>
                <Forest 
                  position={[zone.position.x, 0, zone.position.z]} 
                  count={20} 
                  spread={zone.radius * 0.7} 
                />
                <Bushes 
                  position={[zone.position.x, 0, zone.position.z]} 
                  count={40} 
                  spread={zone.radius * 0.8} 
                />
                <FallenLogs 
                  position={[zone.position.x, 0, zone.position.z]} 
                  count={8} 
                  spread={zone.radius * 0.6} 
                />
              </>
            )}
          </group>
        ))}
      </group>
    </>
  );
}

// Helper function to get color for zone visualization
function getZoneColor(zoneId: string): string {
  const colors: { [key: string]: string } = {
    starter_meadow: '#90EE90',    // Light green
    dark_forest: '#228B22',       // Forest green
    rocky_highlands: '#A0522D',   // Brown
    misty_lake: '#4682B4',        // Steel blue
    cursed_ruins: '#800080',      // Purple
    dragon_peaks: '#FF4500',      // Red-Orange
    shadow_valley: '#483D8B',     // Dark slate blue
    crystal_caverns: '#00CED1'    // Turquoise
  };
  return colors[zoneId] || '#FFFFFF';
}

// Helper component to create a forest with customizable spread
function Forest({ position = [0, 0, 0], count = 5, spread = 40 }) {
  const trees = [];
  
  for (let i = 0; i < count; i++) {
    const x = position[0] + (Math.random() - 0.5) * spread;
    const z = position[2] + (Math.random() - 0.5) * spread;
    
    trees.push(
      <Tree key={`tree-${i}`} position={[x, position[1], z]} scale={1.5 + Math.random() * 1.0} />
    );
  }
  
  return <group>{trees}</group>;
}

// Simple tree component - Made slightly larger
function Tree({ position = [0, 0, 0], scale = 1 }) {
  return (
    <group position={[position[0], position[1], position[2]]} scale={scale}>
      {/* Tree trunk */}
      <mesh position={[0, 1, 0]} castShadow>
        <cylinderGeometry args={[0.2, 0.4, 2]} />
        <meshStandardMaterial color="#8B4513" />
      </mesh>
      
      {/* Tree foliage */}
      <mesh position={[0, 3, 0]} castShadow>
        <coneGeometry args={[1.5, 3, 8]} />
        <meshStandardMaterial color="#2e8b57" />
      </mesh>
    </group>
  );
}

// Rock formation component with customizable spread
function Rocks({ position = [0, 0, 0], count = 3, spread = 20 }) {
  const rocks = [];
  
  for (let i = 0; i < count; i++) {
    const x = position[0] + (Math.random() - 0.5) * spread;
    const z = position[2] + (Math.random() - 0.5) * spread;
    const scale = 1.0 + Math.random() * 1.5; // Larger rocks
    
    rocks.push(
      <RigidBody key={`rock-${i}`} type="fixed" position={[x, position[1], z]}>
        <mesh castShadow>
          <dodecahedronGeometry args={[scale, 0]} />
          <meshStandardMaterial color="#808080" roughness={0.8} />
        </mesh>
      </RigidBody>
    );
  }
  
  return <group>{rocks}</group>;
}

// Larger boulders with more diverse shapes
function BoulderField({ position = [0, 0, 0], count = 5, spread = 30 }) {
  const boulders = [];
  
  for (let i = 0; i < count; i++) {
    const x = position[0] + (Math.random() - 0.5) * spread;
    const z = position[2] + (Math.random() - 0.5) * spread;
    const scale = 2.0 + Math.random() * 2.5; // Much larger than regular rocks
    const rotationY = Math.random() * Math.PI * 2;
    
    // Choose between different boulder shapes
    const shape = Math.floor(Math.random() * 3);
    
    boulders.push(
      <RigidBody key={`boulder-${i}`} type="fixed" position={[x, position[1] + scale/3, z]}>
        <mesh castShadow rotation={[Math.random() * 0.3, rotationY, Math.random() * 0.3]}>
          {shape === 0 && <icosahedronGeometry args={[scale, 0]} />}
          {shape === 1 && <octahedronGeometry args={[scale, 0]} />}
          {shape === 2 && <boxGeometry args={[scale, scale * 0.7, scale * 0.9]} />}
          <meshStandardMaterial color="#615e5d" roughness={0.9} />
        </mesh>
      </RigidBody>
    );
  }
  
  return <group>{boulders}</group>;
}

// Bushes and small vegetation
function Bushes({ position = [0, 0, 0], count = 15, spread = 30 }) {
  const bushes = [];
  
  for (let i = 0; i < count; i++) {
    const x = position[0] + (Math.random() - 0.5) * spread;
    const z = position[2] + (Math.random() - 0.5) * spread;
    const scale = 0.5 + Math.random() * 1.0;
    const rotationY = Math.random() * Math.PI * 2;
    
    // Randomize bush color slightly
    const greenHue = 0.3 + Math.random() * 0.1;
    const colorVariation = Math.random() * 0.2;
    const color = `rgb(${Math.floor((0.15 + colorVariation) * 255)}, 
                      ${Math.floor((greenHue + colorVariation) * 255)}, 
                      ${Math.floor((0.15 + colorVariation) * 255)})`;
    
    bushes.push(
      <group key={`bush-${i}`} position={[x, position[1], z]} rotation={[0, rotationY, 0]} scale={scale}>
        <mesh position={[0, 0.4, 0]} castShadow>
          <sphereGeometry args={[0.8, 8, 8]} />
          <meshStandardMaterial color={color} roughness={0.8} />
        </mesh>
        <mesh position={[0.4, 0.6, 0.4]} castShadow>
          <sphereGeometry args={[0.6, 8, 8]} />
          <meshStandardMaterial color={color} roughness={0.8} />
        </mesh>
        <mesh position={[-0.4, 0.5, 0.2]} castShadow>
          <sphereGeometry args={[0.7, 8, 8]} />
          <meshStandardMaterial color={color} roughness={0.8} />
        </mesh>
      </group>
    );
  }
  
  return <group>{bushes}</group>;
}

// Fallen logs scattered in the forest
function FallenLogs({ position = [0, 0, 0], count = 5, spread = 30 }) {
  const logs = [];
  
  for (let i = 0; i < count; i++) {
    const x = position[0] + (Math.random() - 0.5) * spread;
    const z = position[2] + (Math.random() - 0.5) * spread;
    const scaleX = 0.5 + Math.random() * 0.3;
    const scaleZ = 0.5 + Math.random() * 0.3;
    const length = 3 + Math.random() * 5;
    const rotationY = Math.random() * Math.PI * 2;
    
    logs.push(
      <RigidBody key={`log-${i}`} type="fixed" position={[x, position[1], z]}>
        <group rotation={[0, rotationY, Math.random() * 0.3 - 0.15]}>
          {/* Log body */}
          <mesh position={[0, 0.5 * scaleZ, 0]} castShadow>
            <cylinderGeometry args={[scaleX, scaleX, length, 8]} />
            <mesh rotation={[0, 0, Math.PI / 2]} />
            <meshStandardMaterial color="#654321" roughness={0.9} />
          </mesh>
          
          {/* End caps */}
          <mesh position={[length/2, 0.5 * scaleZ, 0]} rotation={[0, 0, Math.PI / 2]} castShadow>
            <circleGeometry args={[scaleX, 8]} />
            <meshStandardMaterial color="#5a3a1a" roughness={0.95} />
          </mesh>
          
          <mesh position={[-length/2, 0.5 * scaleZ, 0]} rotation={[0, 0, -Math.PI / 2]} castShadow>
            <circleGeometry args={[scaleX, 8]} />
            <meshStandardMaterial color="#5a3a1a" roughness={0.95} />
          </mesh>
        </group>
      </RigidBody>
    );
  }
  
  return <group>{logs}</group>;
}


// ==============================================================================
// FILE: app/game/context/DragContext.tsx
// ==============================================================================

import React, { createContext, useContext, useState, ReactNode } from 'react';
import type { SkillId } from '../../../shared/skillsDefinition';

type Ctx = [SkillId|null, (s:SkillId|null)=>void];
const DragCtx = createContext<Ctx|undefined>(undefined);

export function DragProvider({ children }:{children:ReactNode}) {
  const state = useState<SkillId|null>(null);
  return <DragCtx.Provider value={state}>{children}</DragCtx.Provider>;
}

export function useDraggedSkill() {
  const ctx = useContext(DragCtx);
  if (!ctx) throw new Error('useDraggedSkill outside DragProvider');
  return ctx[0];
}
export function useSetDragged() {
  const ctx = useContext(DragCtx);
  if (!ctx) throw new Error('useSetDragged outside DragProvider');
  return ctx[1];
}


// ==============================================================================
// FILE: app/game/models/Character.ts
// ==============================================================================

import { StatusEffect } from '../systems/gameStore';
import { CharacterClass } from '../../../shared/classSystem';
import { SkillId } from '../../../shared/skillsDefinition';

export interface Character {
  id: string;
  name: string;
  level: number;
  position: { x: number; y: number; z: number };
  rotation: { x: number; y: number; z: number };
  health: number;
  maxHealth: number;
  mana: number;
  maxMana: number;
  className: CharacterClass;
  unlockedSkills: SkillId[];     // All skills the player has learned
  availableSkillPoints: number;  // Points available to learn new skills
  activeSkill: string | null;    // ID of currently selected skill
  skillShortcuts?: (SkillId | null)[];  // Skills assigned to number keys 1-9
  isAlive?: boolean;             // Character alive status
  experience?: number;           // Current experience points
  experienceToNextLevel?: number; // Experience needed for next level
  statusEffects?: StatusEffect[]; // Active status effects
}

export const createCharacter = (name: string): Character => {
  return {
    id: `character-${Math.random().toString(36).substring(2, 9)}`,
    name,
    level: 1,
    position: { x: 0, y: 0, z: 0 },
    rotation: { x: 0, y: 0, z: 0 },
    health: 100,
    maxHealth: 100,
    mana: 50,
    maxMana: 50,
    className: 'mage',
    unlockedSkills: ['fireball'],
    availableSkillPoints: 0,
    activeSkill: 'fireball',
    skillShortcuts: ['fireball', null, null, null, null, null, null, null, null]
  };
};

// ==============================================================================
// FILE: app/game/models/Enemy.ts
// ==============================================================================

import { StatusEffect } from '../systems/gameStore';

// Configuration object for experience and other game settings
export const GameConfig = {
  experience: {
    baseMultiplier: 2.5,
    levelScaling: 0.25,
    donationBoost: 0.0,
    bonusEvents: {
      active: false,
      multiplier: 1.0
    }
  }
};

export interface Enemy {
  id: string;
  type: string;
  name: string;
  level: number;
  position: { x: number; y: number; z: number };
  spawnPosition: { x: number; y: number; z: number }; // Track original spawn position
  rotation: { x: number; y: number; z: number };
  health: number;
  maxHealth: number;
  isAlive: boolean;
  attackDamage: number;
  attackRange: number;
  baseExperienceValue: number; // Store the base value without multipliers
  experienceValue: number; // Store the final calculated value with multipliers
  statusEffects: StatusEffect[]; // Active status effects (made non-optional)
  targetId?: string | null; // Which player the enemy is targeting
  markedForRemoval?: boolean; // Flag for client-side cleanup
  deathTimeTs?: number; // Timestamp when the enemy died
  attackCooldown?: boolean; // Whether the enemy is in attack cooldown
}


// ==============================================================================
// FILE: app/game/models/Skill.ts
// ==============================================================================

import { SKILLS as SHARED_SKILLS, SkillId, SkillEffect as SharedSkillEffect, SkillEffectType as SharedSkillEffectType } from '../../../shared/skillsDefinition';

// Client-side skill interface that extends the shared definition
// with additional client-specific properties
export interface Skill {
  id: string;
  name: string;
  description: string;
  icon: string; // Path to icon image
  damage?: number;
  manaCost: number;
  cooldownMs: number; // time in milliseconds
  range: number;
  areaOfEffect?: number;
  levelRequired: number;
  effects: SkillEffect[];
  castTimeMs: number; // 0 for instant cast, in ms
  projectileSpeed?: number; // for projectile-based skills
  durationMs?: number; // for skills with duration effects, in ms
}

// Re-export shared types
export type { SkillId };
export type SkillEffectType = SharedSkillEffectType;

// Client-side skill effect interface - explicitly add client-side property
export interface SkillEffect extends SharedSkillEffect {
  clientRendered?: boolean;
}

// Map shared skills to client-side format
function mapSharedSkillToClient(skillId: SkillId): Skill {
  const sharedSkill = SHARED_SKILLS[skillId];
  
  return {
    id: sharedSkill.id,
    name: sharedSkill.name,
    description: sharedSkill.description,
    icon: sharedSkill.icon,
    damage: sharedSkill.dmg,
    manaCost: sharedSkill.manaCost,
    cooldownMs: sharedSkill.cooldownMs,
    range: sharedSkill.range || 10,
    areaOfEffect: sharedSkill.area,
    levelRequired: sharedSkill.levelRequired,
    castTimeMs: sharedSkill.castMs,
    projectileSpeed: sharedSkill.speed,
    effects: sharedSkill.effects
  };
}

// Generate client-side skills from shared definitions
export const SKILLS: Record<string, Skill> = Object.fromEntries(
  Object.keys(SHARED_SKILLS).map(skillId => [
    skillId, 
    mapSharedSkillToClient(skillId as SkillId)
  ])
);

// Special case handling for iceBolt/icebolt name mismatch
SKILLS['icebolt'] = SKILLS['iceBolt'];

// ==============================================================================
// FILE: app/game/skills/Fireball.tsx
// ==============================================================================

'use client';

import { useRef, useState, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { Vector3, MathUtils } from 'three';
import * as THREE from 'three';
import { SKILLS } from '../models/Skill';

interface FireballProps {
  startPosition: Vector3;
  targetPosition: Vector3;
  onHit: () => void;
}

export function FireballProjectile({ startPosition, targetPosition, onHit }: FireballProps) {
  const meshRef = useRef<THREE.Mesh>(null);
  const groupRef = useRef<THREE.Group>(null);
  const direction = new Vector3().subVectors(targetPosition, startPosition).normalize();
  const speed = SKILLS.fireball.projectileSpeed || 10;
  const [reachedTarget, setReachedTarget] = useState(false);
  const initialPositionSet = useRef(false);
  const timeOffset = useRef(Math.random() * Math.PI * 2);
  const [intensity, setIntensity] = useState(2);
  
  // Trail particles
  const particles = useRef<Array<{
    position: Vector3;
    scale: number;
    opacity: number;
    lifetimeMs: number;
    rotationSpeed: Vector3;
  }>>([]);
  
  useEffect(() => {
    console.log("Fireball created: From", startPosition, "To", targetPosition);
    
    // Immediately set the initial position when the component mounts
    if (meshRef.current) {
      meshRef.current.position.copy(startPosition);
      initialPositionSet.current = true;
    }
    
    // Clean up particles when component unmounts
    return () => {
      particles.current = [];
    };
  }, [startPosition, targetPosition]);
  
  useFrame((state, delta) => {
    if (reachedTarget || !meshRef.current) return;
    
    // Set initial position only once
    if (!initialPositionSet.current && meshRef.current) {
      meshRef.current.position.copy(startPosition);
      initialPositionSet.current = true;
    }
    
    // Ensure we have a ref before attempting to move
    if (!meshRef.current) return;
    
    // Move projectile toward target
    const moveAmount = direction.clone().multiplyScalar(speed * delta);
    meshRef.current.position.add(moveAmount);
    
    // Make the fireball pulsate
    const pulseFactor = MathUtils.lerp(0.9, 1.1, Math.sin(state.clock.elapsedTime * 8 + timeOffset.current));
    meshRef.current.scale.set(pulseFactor, pulseFactor, pulseFactor);
    
    // Random wobble movement for more dynamic feel
    if (groupRef.current) {
      groupRef.current.position.x += Math.sin(state.clock.elapsedTime * 15) * 0.02;
      groupRef.current.position.y += Math.cos(state.clock.elapsedTime * 12) * 0.02;
    }
    
    // Varying light intensity
    const newIntensity = 2 + Math.sin(state.clock.elapsedTime * 10 + timeOffset.current) * 0.5;
    setIntensity(newIntensity);
    
    // Add trail particles at varying rates based on speed
    const particleChance = 0.5 + (speed / 30);
    if (Math.random() > (1 - particleChance)) {
      particles.current.push({
        position: meshRef.current.position.clone().add(
          new Vector3(
            (Math.random() - 0.5) * 0.3,
            (Math.random() - 0.5) * 0.3,
            (Math.random() - 0.5) * 0.3
          )
        ),
        scale: 0.1 + Math.random() * 0.3,
        opacity: 0.8,
        lifetimeMs: 800 + Math.random() * 300, // 0.5 + 0.3 seconds in ms
        rotationSpeed: new Vector3(
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2
        )
      });
    }
    
    // Update trail particles
    for (let i = particles.current.length - 1; i >= 0; i--) {
      const particle = particles.current[i];
      particle.lifetimeMs -= delta * 1000;
      particle.opacity = Math.max(0, particle.lifetimeMs / 500); // fade out over 0.5s
      particle.scale *= 0.97;
      if (particle.lifetimeMs <= 0) {
        particles.current.splice(i, 1);
      }
    }
    
    // Check if we reached the target
    const currentDist = meshRef.current.position.distanceTo(targetPosition);
    if (currentDist < 0.8) {
      console.log("Fireball hit target");
      setReachedTarget(true);
      onHit();
    }
    
    // Rotate to face direction
    meshRef.current.lookAt(
      meshRef.current.position.clone().add(direction)
    );
    
    // Spin the fireball around its forward axis
    meshRef.current.rotateZ(delta * 5);
  });
  
  if (reachedTarget) {
    return <FireballImpact position={targetPosition} />;
  }
  
  return (
    <group ref={groupRef}>
      {/* Main fireball */}
      <mesh ref={meshRef}>
        <sphereGeometry args={[0.3, 16, 16]} />
        <meshStandardMaterial
          emissive="#ff6600"
          emissiveIntensity={intensity}
          color="#ff0000"
          toneMapped={false}
        />
        <pointLight color="#ff6600" intensity={intensity} distance={5} />
      </mesh>
      
      {/* Inner core - more intense glow */}
      <mesh position={meshRef.current ? meshRef.current.position : startPosition} scale={0.7}>
        <sphereGeometry args={[0.2, 12, 12]} />
        <meshStandardMaterial
          emissive="#ffff00"
          emissiveIntensity={intensity * 1.2}
          color="#ffcc00"
          toneMapped={false}
        />
      </mesh>
      
      {/* Trail particles */}
      {particles.current.map((particle, index) => (
        <mesh key={index} position={particle.position}>
          <sphereGeometry args={[particle.scale, 8, 8]} />
          <meshStandardMaterial
            emissive="#ff6600"
            emissiveIntensity={1}
            color="#ff4500"
            transparent
            opacity={particle.opacity}
          />
        </mesh>
      ))}
    </group>
  );
}

interface ImpactProps {
  position: Vector3;
}

function FireballImpact({ position }: ImpactProps) {
  const [lifetimeMs, setLifetimeMs] = useState(2500);
  const meshRef = useRef<THREE.Mesh>(null);
  const fragments = useRef<Array<{
    position: Vector3;
    velocity: Vector3;
    scale: number;
    opacity: number;
    rotationSpeed: Vector3;
  }>>([]);
  
  // Create explosion fragments
  useEffect(() => {
    // Create fragments that fly outward
    for (let i = 0; i < 15; i++) {
      const angle = Math.random() * Math.PI * 2;
      const height = Math.random() * Math.PI - Math.PI / 2;
      const speed = 2 + Math.random() * 5;
      
      fragments.current.push({
        position: position.clone(),
        velocity: new Vector3(
          Math.cos(angle) * Math.cos(height) * speed,
          Math.sin(height) * speed,
          Math.sin(angle) * Math.cos(height) * speed
        ),
        scale: 0.1 + Math.random() * 0.2,
        opacity: 1.0,
        rotationSpeed: new Vector3(
          Math.random() * 5,
          Math.random() * 5, 
          Math.random() * 5
        )
      });
    }
  }, [position]);
  
  useFrame((state, delta) => {

    if (meshRef.current) {
      // Expand impact with controlled scaling instead of additive
      const maxScale = 5.0;
      const currentProgress = 1 - (lifetimeMs / 2500);
      const targetScale = 1 + (maxScale * currentProgress);
      
      // Use lerp for smoother scaling regardless of frame rate
      meshRef.current.scale.set(targetScale, targetScale, targetScale);
      
      // Decrease opacity over time matched to the new lifetime
      if (meshRef.current.material instanceof THREE.Material) {
        (meshRef.current.material as THREE.MeshStandardMaterial).opacity = lifetimeMs / 2500;
      }
    }
    
    // Update fragments
    for (const fragment of fragments.current) {
      // Apply gravity
      fragment.velocity.y -= delta * 4;
      
      // Update position
      fragment.position.addScaledVector(fragment.velocity, delta);
      
      // Fade out more slowly
      fragment.opacity = Math.max(0, fragment.opacity - delta * 0.7);
      
      // Shrink slightly, but more slowly
      fragment.scale *= 0.99;
    }
    
    // Update lifetime at a slower rate
    setLifetimeMs(prev => Math.max(0, prev - delta * 800));
  });
  
  if (lifetimeMs <= 0) return null;
  
  return (
    <group>
      {/* Main impact shockwave */}
      <mesh ref={meshRef} position={position}>
        <sphereGeometry args={[0.5, 16, 16]} />
        <meshStandardMaterial
          emissive="#ff6600"
          emissiveIntensity={2}
          color="#ff4500"
          transparent
          opacity={lifetimeMs / 2500}
        />
        <pointLight color="#ff6600" intensity={4 * (lifetimeMs / 2500)} distance={10} />
      </mesh>
      
      {/* Secondary flash */}
      <mesh position={position} scale={lifetimeMs < 500 ? (lifetimeMs / 500) * 2 : 1}>
        <sphereGeometry args={[0.8, 12, 12]} />
        <meshStandardMaterial
          emissive="#ffff00"
          emissiveIntensity={3}
          color="#ffcc00"
          transparent
          opacity={Math.min(1, (lifetimeMs / 833))}
        />
      </mesh>
      
      {/* Flying fragments */}
      {fragments.current.map((fragment, index) => (
        <mesh
          key={index}
          position={fragment.position}
          scale={fragment.scale}
        >
          <dodecahedronGeometry args={[1, 0]} />
          <meshStandardMaterial
            emissive="#ff6600"
            emissiveIntensity={2}
            color="#ff4500"
            transparent
            opacity={fragment.opacity}
          />
        </mesh>
      ))}
    </group>
  );
}

// ==============================================================================
// FILE: app/game/skills/IceBolt.tsx
// ==============================================================================

'use client';

import { useRef, useState, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { Vector3, MathUtils } from 'three';
import * as THREE from 'three';
import { SKILLS } from '../models/Skill';

interface IceBoltProps {
  startPosition: Vector3;
  targetPosition: Vector3;
  onHit: () => void;
}

export function IceBoltProjectile({ startPosition, targetPosition, onHit }: IceBoltProps) {
  const meshRef = useRef<THREE.Mesh>(null);
  const groupRef = useRef<THREE.Group>(null);
  const direction = new Vector3().subVectors(targetPosition, startPosition).normalize();
  const speed = SKILLS.icebolt.projectileSpeed || 15;
  const [reachedTarget, setReachedTarget] = useState(false);
  const initialPositionSet = useRef(false);
  const spiralOffset = useRef(Math.random() * Math.PI * 2);
  const spiralRadius = useRef(0.1 + Math.random() * 0.1);
  const [intensity, setIntensity] = useState(1.5);
  
  // Ice crystal particles
  const crystals = useRef<Array<{
    position: Vector3;
    scale: number;
    opacity: number;
    lifetimeMs: number;
    rotation: { x: number, y: number, z: number };
  }>>([]);
  
  useEffect(() => {
    console.log("Ice Bolt created: From", startPosition, "To", targetPosition);
    // Clean up particles when component unmounts
    return () => {
      crystals.current = [];
    };
  }, [startPosition, targetPosition]);
  
  useFrame((state, delta) => {
    if (reachedTarget || !meshRef.current) return;
    
    // Set initial position only once
    if (!initialPositionSet.current && meshRef.current) {
      meshRef.current.position.copy(startPosition);
      initialPositionSet.current = true;
    }
    
    // Calculate the spiral path around the direct line to target
    const spiralTime = state.clock.elapsedTime * 5;
    const spiralVector = new Vector3();
    
    // Find perpendicular vectors to create a spiral around the direction vector
    const up = new Vector3(0, 1, 0);
    const right = new Vector3().crossVectors(direction, up).normalize();
    if (right.lengthSq() === 0) {
      right.set(1, 0, 0); // Fallback if direction is parallel to up
    }
    const perpendicular = new Vector3().crossVectors(direction, right).normalize();
    
    // Create a spiral motion
    spiralVector.addScaledVector(right, Math.cos(spiralTime + spiralOffset.current) * spiralRadius.current);
    spiralVector.addScaledVector(perpendicular, Math.sin(spiralTime + spiralOffset.current) * spiralRadius.current);
    
    // Move projectile toward target with spiral offset
    const directMove = direction.clone().multiplyScalar(speed * delta);
    meshRef.current.position.add(directMove);
    meshRef.current.position.add(spiralVector.clone().multiplyScalar(0.1));
    
    // Pulsating ice effect
    const pulseFactor = MathUtils.lerp(0.9, 1.1, Math.sin(state.clock.elapsedTime * 10) * 0.5 + 0.5);
    if (meshRef.current) {
      meshRef.current.scale.set(pulseFactor, pulseFactor, pulseFactor);
    }
    
    // Rotate the ice bolt for a spinning effect with wobble
    if (meshRef.current) {
      meshRef.current.rotation.z += delta * 12;
      meshRef.current.rotation.x += delta * Math.sin(state.clock.elapsedTime * 3) * 0.2;
    }
    
    // Varying light intensity
    const newIntensity = 1.5 + Math.sin(state.clock.elapsedTime * 8) * 0.3;
    setIntensity(newIntensity);
    
    // Add trail crystal at varying rates
    const crystalChance = 0.4 + (speed / 40);
    if (Math.random() > (1 - crystalChance)) {
      crystals.current.push({
        position: meshRef.current.position.clone().add(
          new Vector3(
            (Math.random() - 0.5) * 0.3,
            (Math.random() - 0.5) * 0.3,
            (Math.random() - 0.5) * 0.3
          )
        ),
        scale: 0.05 + Math.random() * 0.15,
        opacity: 0.9,
        lifetimeMs: 700 + Math.random() * 300, // 0.4 + 0.3 seconds in ms
        rotation: {
          x: Math.random() * Math.PI,
          y: Math.random() * Math.PI,
          z: Math.random() * Math.PI
        }
      });
    }
    
    // Update trail crystals
    for (let i = crystals.current.length - 1; i >= 0; i--) {
      const crystal = crystals.current[i];
      crystal.lifetimeMs -= delta * 1000;
      crystal.opacity = Math.max(0, crystal.lifetimeMs / 450); // fade out over 0.45s
      crystal.scale *= 0.97;
      if (crystal.lifetimeMs <= 0) {
        crystals.current.splice(i, 1);
      }
    }
    
    // Check if we reached the target
    const currentDist = meshRef.current.position.distanceTo(targetPosition);
    if (currentDist < 0.8) {
      console.log("Ice Bolt hit target");
      setReachedTarget(true);
      onHit();
    }
    
    // Look in direction of travel
    meshRef.current.lookAt(
      meshRef.current.position.clone().add(direction)
    );
  });
  
  if (reachedTarget) {
    return <IceBoltImpact position={targetPosition} />;
  }
  
  return (
    <group ref={groupRef}>
      {/* Main ice bolt */}
      <mesh ref={meshRef}>
        <coneGeometry args={[0.2, 0.9, 8]} />
        <meshStandardMaterial
          emissive="#88cfff"
          emissiveIntensity={intensity}
          color="#ffffff"
          toneMapped={false}
          transparent
          opacity={0.8}
        />
        <pointLight color="#88cfff" intensity={intensity} distance={4} />
      </mesh>
      
      {/* Secondary ice shard components */}
      <group position={meshRef.current ? meshRef.current.position : startPosition}>
        <mesh rotation={[Math.PI / 4, 0, Math.PI / 6]} scale={0.6}>
          <octahedronGeometry args={[0.3, 0]} />
          <meshStandardMaterial
            emissive="#a0d8ff"
            emissiveIntensity={intensity * 0.7}
            color="#ffffff"
            transparent
            opacity={0.7}
          />
        </mesh>
        <mesh rotation={[-Math.PI / 4, Math.PI / 2, -Math.PI / 6]} scale={0.5} position={[0, 0.2, 0]}>
          <octahedronGeometry args={[0.25, 0]} />
          <meshStandardMaterial
            emissive="#cceeff"
            emissiveIntensity={intensity * 0.5}
            color="#ffffff"
            transparent
            opacity={0.6}
          />
        </mesh>
      </group>
      
      {/* Frost aura */}
      <mesh position={meshRef.current ? meshRef.current.position : startPosition} scale={1.2}>
        <sphereGeometry args={[0.3, 12, 12]} />
        <meshStandardMaterial
          emissive="#88cfff"
          emissiveIntensity={0.5}
          color="#ffffff"
          transparent
          opacity={0.2}
        />
      </mesh>
      
      {/* Trail crystals */}
      {crystals.current.map((crystal, index) => (
        <mesh 
          key={index} 
          position={crystal.position}
          rotation={[crystal.rotation.x, crystal.rotation.y, crystal.rotation.z]}
        >
          <octahedronGeometry args={[crystal.scale, 0]} />
          <meshStandardMaterial
            emissive="#88cfff"
            emissiveIntensity={1}
            color="#b0e0ff"
            transparent
            opacity={crystal.opacity}
          />
        </mesh>
      ))}
    </group>
  );
}

interface ImpactProps {
  position: Vector3;
}

function IceBoltImpact({ position }: ImpactProps) {
  const [lifetimeMs, setLifetimeMs] = useState(3000);
  const mainImpactRef = useRef<THREE.Mesh>(null);
  const iceCrystalsRef = useRef<Array<{
    position: Vector3;
    scale: number;
    opacity: number;
    rotation: Vector3;
    velocity: Vector3;
  }>>([]);
  
  // Create ice crystal explosion
  useEffect(() => {
    // Create outward crystals
    for (let i = 0; i < 20; i++) {
      const angle = (i / 20) * Math.PI * 2;
      const height = (Math.random() - 0.5) * Math.PI;
      const distance = 0.2 + Math.random() * 0.4;
      const speed = 1 + Math.random() * 3;
      
      const direction = new Vector3(
        Math.cos(angle) * Math.cos(height),
        Math.sin(height),
        Math.sin(angle) * Math.cos(height)
      ).normalize();
      
      iceCrystalsRef.current.push({
        position: position.clone().add(direction.clone().multiplyScalar(distance)),
        scale: 0.05 + Math.random() * 0.15,
        opacity: 1.0,
        rotation: new Vector3(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        ),
        velocity: direction.multiplyScalar(speed)
      });
    }
  }, [position]);
  
  useFrame((state, delta) => {
    // Update lifetime at a slower rate
    setLifetimeMs(prev => Math.max(0, prev - delta * 800));
    
    // Expand the main impact effect
    if (mainImpactRef.current) {
      const expansionScale = Math.min(2, 0.5 + (1 - lifetimeMs / 3000) * 3); 
      mainImpactRef.current.scale.set(expansionScale, expansionScale, expansionScale);
      
      if (mainImpactRef.current.material instanceof THREE.Material) {
        (mainImpactRef.current.material as THREE.MeshStandardMaterial).opacity = Math.min(1, lifetimeMs / 600);
      }
    }      // Update crystal fragments
    for (const crystal of iceCrystalsRef.current) {
      // Apply movement and some gravity, but slower
      crystal.velocity.y -= delta * 1.5; // Gentler gravity
      crystal.position.addScaledVector(crystal.velocity, delta * 0.7); // Slower movement
      
      // Add some rotation, slightly slower
      crystal.rotation.x += delta * (Math.random() * 0.3 + 0.3);
      crystal.rotation.y += delta * (Math.random() * 0.3 + 0.3);
      crystal.rotation.z += delta * (Math.random() * 0.3 + 0.3);
      
      // Set opacity based on lifetime, slower fade-out
      crystal.opacity = Math.max(0, lifetimeMs * 0.6 / 3000);
      
      // Shrink more gradually
      crystal.scale *= 0.995;
    }
  });
  
  if (lifetimeMs <= 0) return null;
  
  return (
    <group>
      {/* Initial flash */}
      <mesh position={position}>
        <sphereGeometry args={[0.6, 16, 16]} />
        <meshStandardMaterial
          emissive="#ffffff"
          emissiveIntensity={3}
          color="#88cfff"
          transparent
          opacity={Math.min(1, lifetimeMs / 300)}
        />
      </mesh>
      
      {/* Main frost sphere */}
      <mesh ref={mainImpactRef} position={position}>
        <sphereGeometry args={[0.5, 16, 16]} />
        <meshStandardMaterial
          emissive="#88cfff"
          emissiveIntensity={2}
          color="#ffffff"
          transparent
          opacity={lifetimeMs * 0.7 / 1000}
        />
        <pointLight color="#88cfff" intensity={2 * (lifetimeMs / 1000)} distance={8} />
      </mesh>
      
      {/* Frost ring */}
      <mesh position={position} rotation={[Math.PI / 2, 0, 0]} scale={0.3 + (1 - lifetimeMs / 1500) * 2.5}>
        <torusGeometry args={[1, 0.1, 16, 36]} />
        <meshStandardMaterial
          emissive="#88cfff"
          emissiveIntensity={1}
          color="#ffffff"
          transparent
          opacity={Math.max(0, lifetimeMs * 0.7 / 1000)}
        />
      </mesh>
      
      {/* Ice crystal fragments */}
      {iceCrystalsRef.current.map((crystal, index) => (
        <mesh 
          key={index} 
          position={crystal.position}
          rotation={[crystal.rotation.x, crystal.rotation.y, crystal.rotation.z]}
          scale={crystal.scale}
        >
          <octahedronGeometry args={[1, 0]} />
          <meshStandardMaterial
            emissive="#88cfff"
            emissiveIntensity={0.5}
            color="#ffffff"
            transparent
            opacity={crystal.opacity}
          />
        </mesh>
      ))}
      
      {/* Ground frost effect (appears to spread on ground) */}
      <mesh position={[position.x, 0.05, position.z]} rotation={[-Math.PI / 2, 0, 0]} scale={1 + (1 - lifetimeMs / 1500) * 3}>
        <circleGeometry args={[1, 32]} />
        <meshStandardMaterial
          emissive="#88cfff"
          emissiveIntensity={0.5}
          color="#ffffff"
          transparent
          opacity={Math.max(0, lifetimeMs * 0.4 / 1000)}
        />
      </mesh>
    </group>
  );
}

// ==============================================================================
// FILE: app/game/skills/Petrify.tsx
// ==============================================================================

'use client';

import { useRef, useState, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { Vector3, MathUtils } from 'three';
import * as THREE from 'three';

interface PetrifyProps {
  startPosition: Vector3;
  targetPosition: Vector3;
  onHit: () => void;
}

export function PetrifyProjectile({ startPosition, targetPosition, onHit }: PetrifyProps) {
  const meshRef = useRef<THREE.Mesh>(null);
  const coreRef = useRef<THREE.Mesh>(null);
  const orbitRef = useRef<THREE.Group>(null);
  const [reachedTarget, setReachedTarget] = useState(false);
  const initialPositionSet = useRef(false);
  const [intensity, setIntensity] = useState(2.2);
  const timeOffset = useRef(Math.random() * 10);

  // Dust particles that orbit the main projectile
  const particles = useRef<Array<{
    position: Vector3;
    scale: number;
    opacity: number;
    lifetimeMs: number;
    orbitSpeed: number;
    orbitRadius: number;
    orbitOffset: number;
    height: number;
  }>>([]);

  const direction = new Vector3().subVectors(targetPosition, startPosition).normalize();
  const speed = 12; // Slightly slower than ice bolt for a weightier feel

  useEffect(() => {
    console.log("Petrify created: From", startPosition, "To", targetPosition);
    
    // Create initial orbiting dust particles
    for (let i = 0; i < 12; i++) {
      particles.current.push({
        position: new Vector3(),
        scale: 0.05 + Math.random() * 0.12,
        opacity: 0.7 + Math.random() * 0.3,
        lifetimeMs: 1000,
        orbitSpeed: 1.0 + Math.random() * 2.0,
        orbitRadius: 0.3 + Math.random() * 0.4,
        orbitOffset: Math.random() * Math.PI * 2,
        height: Math.random() * 0.4 - 0.2
      });
    }
    
    // Clean up particles when component unmounts
    return () => {
      particles.current = [];
    };
  }, [startPosition, targetPosition]);

  useFrame((state, delta) => {
    if (reachedTarget || !meshRef.current) return;

    // Set initial position only once
    if (!initialPositionSet.current && meshRef.current) {
      meshRef.current.position.copy(startPosition);
      initialPositionSet.current = true;
    }

    // Move projectile toward target
    const moveAmount = direction.clone().multiplyScalar(speed * delta);
    meshRef.current.position.add(moveAmount);

    // Orbital rotation effect
    if (orbitRef.current) {
      orbitRef.current.rotation.y += delta * 2.0;
      orbitRef.current.rotation.z += delta * 1.2;
    }

    // Pulsate the core
    if (coreRef.current) {
      const pulseFactor = MathUtils.lerp(0.8, 1.2, Math.sin(state.clock.elapsedTime * 5 + timeOffset.current) * 0.5 + 0.5);
      coreRef.current.scale.set(pulseFactor, pulseFactor, pulseFactor);
    }

    // Varying light intensity
    const newIntensity = 2.2 + Math.sin(state.clock.elapsedTime * 6 + timeOffset.current) * 0.3;
    setIntensity(newIntensity);

    // Update orbiting particles
    for (const particle of particles.current) {
      const time = state.clock.elapsedTime * particle.orbitSpeed + particle.orbitOffset;
      
      // Orbit around the projectile
      particle.position.x = Math.cos(time) * particle.orbitRadius;
      particle.position.z = Math.sin(time) * particle.orbitRadius;
      particle.position.y = Math.sin(time * 1.5) * 0.1 + particle.height;
    }

    // Check if we reached the target
    const currentDist = meshRef.current.position.distanceTo(targetPosition);
    if (currentDist < 0.8) {
      console.log("Petrify hit target");
      setReachedTarget(true);
      onHit();
    }

    // Look in direction of travel
    meshRef.current.lookAt(meshRef.current.position.clone().add(direction));
  });

  if (reachedTarget) {
    return <PetrifyImpact position={targetPosition} />;
  }

  return (
    <group>
      {/* Main petrify projectile body */}
      <mesh ref={meshRef}>
        <dodecahedronGeometry args={[0.35, 0]} />
        <meshStandardMaterial
          emissive="#aaaaaa"
          emissiveIntensity={intensity * 0.3}
          color="#444444"
          roughness={0.7}
          metalness={0.2}
        />

        {/* Inner glowing core */}
        <mesh ref={coreRef} scale={0.6}>
          <sphereGeometry args={[0.5, 16, 16]} />
          <meshStandardMaterial
            emissive="#c0c0c0"
            emissiveIntensity={intensity}
            color="#606060"
            transparent={true}
            opacity={0.9}
          />
        </mesh>

        {/* Stone fragments orbiting the core */}
        <group ref={orbitRef}>
          <mesh position={[0.25, 0, 0]} scale={0.2}>
            <tetrahedronGeometry args={[1, 0]} />
            <meshStandardMaterial
              color="#505050"
              roughness={1.0}
              metalness={0.1}
            />
          </mesh>
          <mesh position={[-0.2, 0.15, 0.2]} rotation={[0.5, 0.3, 0.2]} scale={0.15}>
            <dodecahedronGeometry args={[1, 0]} />
            <meshStandardMaterial
              color="#606060"
              roughness={1.0}
              metalness={0.1}
            />
          </mesh>
          <mesh position={[0, -0.2, -0.2]} rotation={[0.2, 0.5, 0]} scale={0.18}>
            <octahedronGeometry args={[1, 0]} />
            <meshStandardMaterial
              color="#555555"
              roughness={0.9}
              metalness={0.1}
            />
          </mesh>
        </group>

        {/* Light source */}
        <pointLight color="#e0e0e0" intensity={intensity * 0.6} distance={4} />
      </mesh>

      {/* Dust particles orbiting the projectile */}
      {particles.current.map((particle, index) => (
        <mesh 
          key={index} 
          position={[
            meshRef.current ? meshRef.current.position.x + particle.position.x : startPosition.x,
            meshRef.current ? meshRef.current.position.y + particle.position.y : startPosition.y,
            meshRef.current ? meshRef.current.position.z + particle.position.z : startPosition.z
          ]}
          scale={particle.scale}
        >
          <dodecahedronGeometry args={[1, 0]} />
          <meshStandardMaterial
            color="#909090"
            transparent={true}
            opacity={particle.opacity * 0.7}
            roughness={1.0}
          />
        </mesh>
      ))}
    </group>
  );
}

interface ImpactProps {
  position: Vector3;
}

function PetrifyImpact({ position }: ImpactProps) {
  const [lifetimeMs, setLifetimeMs] = useState(4000);
  const waveRef = useRef<THREE.Mesh>(null);
  const crystalsRef = useRef<THREE.Group>(null);
  const centralPillarRef = useRef<THREE.Mesh>(null);

  // Stone fragments that emerge from the ground
  const fragments = useRef<Array<{
    position: Vector3;
    rotation: Vector3;
    initialScale: number;
    targetScale: number;
    currentScale: number;
    velocity: Vector3;
    rotationSpeed: Vector3;
    riseDelayMs: number;
    lifetime: number;
    retreating: boolean;
  }>>([]);
  
  // Dust particles for the impact
  const dustParticles = useRef<Array<{
    position: Vector3;
    initialY: number;
    scale: number;
    opacity: number;
    velocity: Vector3;
    rotationSpeed: Vector3;
    rotation: Vector3;
    lifetimeMs: number;
    maxLifetimeMs: number;
  }>>([]);

  useEffect(() => {
    // Create stone fragments that emerge from the ground in a circular pattern
    for (let i = 0; i < 24; i++) {
      const angle = (i / 24) * Math.PI * 2;
      const distance = 0.5 + Math.random() * 0.8;
      const delay = (distance / 2.0) * 0.5; // Outer fragments rise later
      
      fragments.current.push({
        position: new Vector3(
          position.x + Math.cos(angle) * distance,
          0, // Start at ground level
          position.z + Math.sin(angle) * distance
        ),
        rotation: new Vector3(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        ),
        initialScale: 0,
        targetScale: 0.1 + Math.random() * 0.2,
        currentScale: 0,
        velocity: new Vector3(0, 1 + Math.random() * 2, 0),
        rotationSpeed: new Vector3(
          Math.random() * 0.5,
          Math.random() * 0.5,
          Math.random() * 0.5
        ),
        riseDelayMs: delay,
        lifetime: 2.5,
        retreating: false
      });
    }
    
    // Create dust particles that burst outward
    for (let i = 0; i < 30; i++) {
      const angle = Math.random() * Math.PI * 2;
      const height = Math.random() * Math.PI - Math.PI / 2;
      const speed = 1 + Math.random() * 3;
      const maxLifetime = 1.0 + Math.random() * 1.0;
      
      const direction = new Vector3(
        Math.cos(angle) * Math.cos(height),
        Math.abs(Math.sin(height)) * 1.5, // Ensure dust goes upward
        Math.sin(angle) * Math.cos(height)
      ).normalize();
      
      dustParticles.current.push({
        position: position.clone().add(
          new Vector3(
            (Math.random() - 0.5) * 0.2,
            0,
            (Math.random() - 0.5) * 0.2
          )
        ),
        initialY: position.y,
        scale: 0.05 + Math.random() * 0.15,
        opacity: 0.5 + Math.random() * 0.5,
        velocity: direction.multiplyScalar(speed),
        rotationSpeed: new Vector3(
          Math.random() * 5,
          Math.random() * 5,
          Math.random() * 5
        ),
        rotation: new Vector3(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        ),
        lifetimeMs: maxLifetime,
        maxLifetimeMs: maxLifetime
      });
    }
    
  }, [position]);
  
  useFrame((state, delta) => {
    const cappedDeltaMs = Math.min(delta, 0.1) * 1000;
    setLifetimeMs(prev => Math.max(0, prev - cappedDeltaMs));
    
    // Expand stone wave on ground
    if (waveRef.current) {
      // Calculate wave scale based on lifetime (grows quickly, then slows)
      const waveProgress = 1 - (lifetimeMs / 4000);
      const waveScale = Math.min(4, waveProgress * 5);
      waveRef.current.scale.set(waveScale, 1, waveScale);
      
      // Adjust opacity to fade out over time
      if (waveRef.current.material instanceof THREE.Material) {
        (waveRef.current.material as THREE.MeshStandardMaterial).opacity = Math.max(0, lifetimeMs * 0.4 / 1600);
      }
    }
    
    // Rise and rotate central pillar
    if (centralPillarRef.current) {
      if (lifetimeMs > 2400) {
        const riseProgress = (4000 - lifetimeMs) * 2 / 1600;
        const targetHeight = Math.min(0.8, riseProgress * 0.5);
        centralPillarRef.current.position.y = targetHeight / 2;
        centralPillarRef.current.scale.y = targetHeight;
      } else if (lifetimeMs > 800) {
        // Hold the pillar up for longer
        centralPillarRef.current.position.y = 0.4;
        centralPillarRef.current.scale.y = 0.8;
      } else {
        // Sink back down in final phase
        const sinkProgress = (lifetimeMs / 800);
        const targetHeight = Math.max(0, sinkProgress * 0.8);
        centralPillarRef.current.position.y = targetHeight / 2;
        centralPillarRef.current.scale.y = targetHeight;
      }
      
      // Rotate slowly
      centralPillarRef.current.rotation.y += cappedDeltaMs * 0.5;
    }
    
    // Animate central crystals
    if (crystalsRef.current) {
      // Rotate crystal group, but slower for longer effect
      crystalsRef.current.rotation.y += cappedDeltaMs * 0.6;
      
      // Pulse scale
      const pulsePhase = Math.sin(state.clock.elapsedTime * 2) * 0.1 + 0.9;
      
      // Scale based on lifetime
      let scaleMultiplier;
      if (lifetimeMs > 2400) {
        // Growing phase - slower growth for longer duration
        scaleMultiplier = ((4000 - lifetimeMs) / 1600) * pulsePhase;
      } else if (lifetimeMs > 800) {
        // Maintain full size during middle of animation
        scaleMultiplier = pulsePhase;
      } else {
        // Shrinking phase at the end
        scaleMultiplier = (lifetimeMs / 800) * pulsePhase;
      }
      crystalsRef.current.scale.set(
        scaleMultiplier, 
        scaleMultiplier, 
        scaleMultiplier
      );
    }
    
    // Update stone fragments
    for (const fragment of fragments.current) {
      // Handle delay
      if (fragment.riseDelayMs > 0) {
        fragment.riseDelayMs -= cappedDeltaMs;
        continue;
      }
      
      if (!fragment.retreating) {
        // Rising from the ground
        if (fragment.position.y < (0.3 + Math.random() * 0.3)) {
          fragment.position.addScaledVector(fragment.velocity, cappedDeltaMs * 0.4); // Slower rise
          
          // Gradually grow to target size
          fragment.currentScale = MathUtils.lerp(
            fragment.currentScale,
            fragment.targetScale,
            cappedDeltaMs * 2.5 // Slower scaling
          );
        } else {
          // Hover and rotate at peak
          fragment.position.y += Math.sin(state.clock.elapsedTime * 1.5) * cappedDeltaMs * 0.03;
        }
        
        // Start retreating when lifetime is below threshold
        if (lifetimeMs < 1500) { // Later retreat time
          fragment.retreating = true;
          // Reverse velocity for retreat
          fragment.velocity.multiplyScalar(-0.3); // Slower retreat
        }
      } else {
        // Retreating back into ground
        if (fragment.position.y > 0) {
          fragment.position.addScaledVector(fragment.velocity, cappedDeltaMs * 0.8); // Slower descent
          
          // Shrink as it retreats
          fragment.currentScale = MathUtils.lerp(
            fragment.currentScale,
            0,
            cappedDeltaMs * 4
          );
        }
      }
      
      // Apply rotation
      fragment.rotation.x += fragment.rotationSpeed.x * cappedDeltaMs;
      fragment.rotation.y += fragment.rotationSpeed.y * cappedDeltaMs;
      fragment.rotation.z += fragment.rotationSpeed.z * cappedDeltaMs;
    }
    
    // Update dust particles
    for (let i = dustParticles.current.length - 1; i >= 0; i--) {
      const dust = dustParticles.current[i];
      
      // Apply gravity
      dust.velocity.y -= cappedDeltaMs * 3;
      
      // Update position
      dust.position.addScaledVector(dust.velocity, cappedDeltaMs);
      
      // Update rotation
      dust.rotation.x += dust.rotationSpeed.x * cappedDeltaMs;
      dust.rotation.y += dust.rotationSpeed.y * cappedDeltaMs;
      dust.rotation.z += dust.rotationSpeed.z * cappedDeltaMs;
      
      // Update lifetime
      dust.lifetimeMs -= cappedDeltaMs;
      dust.opacity = Math.max(0, dust.lifetimeMs / dust.maxLifetimeMs) * 0.5;
      
      // Remove dead particles
      if (dust.lifetimeMs <= 0) {
        dustParticles.current.splice(i, 1);
      }
    }
  });
  
  if (lifetimeMs <= 0) return null;
  
  return (
    <group>
      {/* Ground circular wave that expands outward */}
      <mesh 
        ref={waveRef} 
        position={[position.x, 0.02, position.z]} 
        rotation={[-Math.PI / 2, 0, 0]}
      >
        <ringGeometry args={[0.2, 0.7, 32]} />
        <meshStandardMaterial
          color="#757575"
          transparent={true}
          opacity={0.6}
          depthWrite={false}
        />
      </mesh>
      
      {/* Central pillar of stone that rises up */}
      <mesh
        ref={centralPillarRef}
        position={[position.x, 0, position.z]}
        scale={[0.4, 0, 0.4]}
      >
        <cylinderGeometry args={[1, 1.3, 1, 6, 1]} />
        <meshStandardMaterial
          color="#5a5a5a"
          roughness={0.9}
          metalness={0.2}
        />
      </mesh>
      
      {/* Crystal formation at the center */}
      <group
        ref={crystalsRef}
        position={[position.x, 0.4, position.z]}
      >
        <mesh rotation={[0.5, 0, 0.3]}>
          <octahedronGeometry args={[0.3, 0]} />
          <meshStandardMaterial
            color="#444444"
            emissive="#a0a0a0"
            emissiveIntensity={0.2}
            roughness={0.7}
            metalness={0.3}
          />
        </mesh>
        
        <mesh position={[0.1, 0.15, 0]} rotation={[-0.3, 0.5, 0.1]}>
          <octahedronGeometry args={[0.2, 0]} />
          <meshStandardMaterial
            color="#555555"
            emissive="#a0a0a0"
            emissiveIntensity={0.2}
            roughness={0.7}
            metalness={0.3}
          />
        </mesh>
        
        <mesh position={[-0.15, 0.08, 0.05]} rotation={[0.2, -0.3, 0.5]}>
          <octahedronGeometry args={[0.25, 0]} />
          <meshStandardMaterial
            color="#505050"
            emissive="#a0a0a0"
            emissiveIntensity={0.2}
            roughness={0.7}
            metalness={0.3}
          />
        </mesh>
      </group>
      
      {/* Initial flash */}
      <mesh position={[position.x, position.y, position.z]}>
        <sphereGeometry args={[0.5, 16, 16]} />
        <meshStandardMaterial
          emissive="#ffffff"
          emissiveIntensity={2}
          color="#aaaaaa"
          transparent={true}
          opacity={Math.min(1, lifetimeMs * 5 / 1000)}
        />
        <pointLight color="#ffffff" intensity={Math.min(3, lifetimeMs * 10 / 1000)} distance={5} decay={2} />
      </mesh>
      
      {/* Stone fragments rising from ground */}
      {fragments.current.map((fragment, index) => (
        <mesh
          key={`fragment-${index}`}
          position={fragment.position}
          rotation={[fragment.rotation.x, fragment.rotation.y, fragment.rotation.z]}
          scale={fragment.currentScale}
        >
          <dodecahedronGeometry args={[1, 0]} />
          <meshStandardMaterial
            color={`rgb(${70 + Math.floor(Math.random() * 30)}, ${70 + Math.floor(Math.random() * 30)}, ${70 + Math.floor(Math.random() * 30)})`}
            roughness={0.9}
            metalness={0.1}
          />
        </mesh>
      ))}
      
      {/* Dust particles */}
      {dustParticles.current.map((dust, index) => (
        <mesh
          key={`dust-${index}`}
          position={dust.position}
          rotation={[dust.rotation.x, dust.rotation.y, dust.rotation.z]}
          scale={dust.scale}
        >
          <dodecahedronGeometry args={[1, 0]} />
          <meshStandardMaterial
            color="#808080"
            transparent={true}
            opacity={dust.opacity}
            depthWrite={false}
          />
        </mesh>
      ))}
    </group>
  );
}

// ==============================================================================
// FILE: app/game/skills/WaterSplash.tsx
// ==============================================================================

import * as THREE from 'three';
import { useRef, useState, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { Vector3, Color, MathUtils } from 'three';

interface WaterSplashProps {
  position: Vector3;
  radius?: number; // Area of effect radius
  onComplete: () => void;
}

export function WaterSplash({ position, radius = 5, onComplete }: WaterSplashProps) {
  const [lifetimeMs, setLifetimeMs] = useState(3500);
  const rippleRef = useRef<THREE.Mesh>(null);
  const isCompletingRef = useRef(false);
  
  // Water droplet particles
  const [particles, setParticles] = useState(() => {
    const particleCount = 35;
    return Array.from({ length: particleCount }, () => ({
      position: position.clone().add(
        new Vector3(
          (Math.random() - 0.5) * radius * 0.6, // Spread particles based on radius
          Math.random() * 0.5,
          (Math.random() - 0.5) * radius * 0.6  // Spread particles based on radius
        )
      ),
      initialY: position.y,
      velocity: new Vector3(
        (Math.random() - 0.5) * 10,
        Math.random() * 8 + 6,
        (Math.random() - 0.5) * 10
      ),
      scale: 0.1 + Math.random() * 0.25,
      opacity: 1.0,
      color: new Color().setHSL(0.58 + Math.random() * 0.05, 0.8, 0.5 + Math.random() * 0.2),
      rotationSpeed: new Vector3(
        Math.random() * 5, 
        Math.random() * 5, 
        Math.random() * 5
      ),
      rotation: new Vector3(),
      stretching: 1.0
    }));
  });
  
  // Water vapor/mist particles
  const mistParticles = useRef<Array<{
    position: Vector3;
    scale: number;
    opacity: number;
    velocity: Vector3;
    lifetimeMs: number;
    maxLifetimeMs: number;
  }>>([]);

  // Create initial mist particles
  useEffect(() => {
    // Clear existing mist particles to prevent duplicates
    mistParticles.current = [];
    
    // Create more mist particles for larger radius
    const mistCount = Math.floor(25 * (radius / 3));
    
    for (let i = 0; i < mistCount; i++) {
      const angle = Math.random() * Math.PI * 2;
      const height = Math.random() * 0.5;
      const distance = (0.3 + Math.random() * 0.7) * radius;
      const maxLifetimeMs = 500 + Math.random() * 1500;
      mistParticles.current.push({
        position: position.clone().add(new Vector3(
          Math.cos(angle) * distance * 0.7,
          height,
          Math.sin(angle) * distance * 0.7
        )),
        scale: 0.3 + Math.random() * 0.4,
        opacity: 0.4 + Math.random() * 0.3,
        velocity: new Vector3(
          Math.cos(angle) * (0.5 + Math.random()),
          0.7 + Math.random() * 0.5,
          Math.sin(angle) * (0.5 + Math.random())
        ),
        lifetimeMs: maxLifetimeMs,
        maxLifetimeMs
      });
    }
    
    // Reset the completing state when a new splash is created
    isCompletingRef.current = false;
    
    return () => {
      // Ensure particles are cleared when component unmounts
      mistParticles.current = [];
    };
    
  }, [position, radius]);

  useFrame((state, delta) => {
    // Use a smaller delta cap to prevent large time steps that can cause visual glitches
    const cappedDelta = Math.min(delta, 0.1);
    
    // Create time-based ripple with radius reflecting the area of effect
    const rippleScale = MathUtils.lerp(0.2, radius * 2, 1 - lifetimeMs / 3500);
    const rippleOpacity = MathUtils.lerp(0, 0.6, lifetimeMs / 3500);
    
    if (rippleRef.current) {
      rippleRef.current.scale.set(rippleScale, 1, rippleScale);
      if (rippleRef.current.material) {
        const material = rippleRef.current.material as THREE.Material;
        if (material.transparent !== undefined && material.opacity !== undefined) {
          material.opacity = rippleOpacity;
        }
      }
    }

    // Update water droplet particles
    setParticles(prevParticles => 
      prevParticles.map(particle => {
        // Apply gravity
        particle.velocity.y -= 15 * cappedDelta;
        
        // Update position
        particle.position.add(
          particle.velocity.clone().multiplyScalar(cappedDelta)
        );
        
        // Calculate stretching based on vertical velocity (for water droplet effect)
        particle.stretching = MathUtils.lerp(
          1.0, 
          1.5,
          Math.min(1, Math.abs(particle.velocity.y) / 10)
        );

        // Update rotation
        particle.rotation.x += particle.rotationSpeed.x * cappedDelta;
        particle.rotation.y += particle.rotationSpeed.y * cappedDelta;
        particle.rotation.z += particle.rotationSpeed.z * cappedDelta;

        // Bounce off ground with dampening
        if (particle.position.y < 0.1) {
          particle.position.y = 0.1;
          
          // Create splash mist when hitting ground with force
          if (-particle.velocity.y > 8) {
            for (let i = 0; i < 2; i++) {
              const angle = Math.random() * Math.PI * 2;
              const maxLifetimeMs = 300 + Math.random() * 600;
              
              // Distribute splash particles throughout the area of effect
              const splashDistance = Math.random() * radius * 0.8;
              
              mistParticles.current.push({
                position: particle.position.clone().add(new Vector3(
                  Math.cos(angle) * splashDistance,
                  0.1,
                  Math.sin(angle) * splashDistance
                )),
                scale: 0.2 + Math.random() * 0.2,
                opacity: 0.3 + Math.random() * 0.2,
                velocity: new Vector3(
                  Math.cos(angle) * (0.3 + Math.random() * 0.7),
                  0.3 + Math.random() * 0.4,
                  Math.sin(angle) * (0.3 + Math.random() * 0.7)
                ),
                lifetimeMs: maxLifetimeMs,
                maxLifetimeMs
              });
            }
          }
          
          // Reflect velocity with dampening
          particle.velocity.y = Math.abs(particle.velocity.y) * 0.3;
          
          // Add some horizontal movement on bounce
          particle.velocity.x *= 0.9;
          particle.velocity.z *= 0.9;
          
          // Reduce scale slightly on impact
          particle.scale *= 0.95;
        }

        // Update opacity based on lifetime and altitude
        // Water droplets fade as they reach maximum height or as lifetime ends
        const heightFactor = Math.max(0, 1 - Math.abs(particle.position.y - particle.initialY) / 6);
        particle.opacity = Math.min(lifetimeMs / 1000, heightFactor) * 0.9;

        return particle;
      })
    );
    
    // Update mist particles
    for (let i = mistParticles.current.length - 1; i >= 0; i--) {
      const mist = mistParticles.current[i];
      mist.lifetimeMs -= cappedDelta * 1000;
      mist.position.addScaledVector(mist.velocity, cappedDelta);
      mist.velocity.multiplyScalar(0.97);
      mist.scale = MathUtils.lerp(
        mist.scale,
        mist.scale * 1.1,
        cappedDelta * 2
      );
      const normalizedLife = mist.lifetimeMs / mist.maxLifetimeMs;
      mist.opacity = Math.sin(normalizedLife * Math.PI) * 0.5;
      if (mist.lifetimeMs <= 0) {
        mistParticles.current.splice(i, 1);
      }
    }

    // Update lifetime more slowly
    setLifetimeMs(prev => {
      const newLifetime = Math.max(0, prev - cappedDelta * 800);
      if (newLifetime <= 0 && !isCompletingRef.current) {
        isCompletingRef.current = true;
        setTimeout(() => {
          onComplete();
        }, 50);
      }
      return newLifetime;
    });
  });

  // If no lifetime left, don't render anything
  if (lifetimeMs <= 0) return null;

  return (
    <group>
      {/* Initial splash burst */}
      <mesh position={position}>
        <sphereGeometry args={[radius * 0.3, 16, 16]} />
        <meshStandardMaterial
          key={`splash-${position.x}-${position.z}`}
          color="#80c0ff"
          emissive="#4080ff"
          emissiveIntensity={0.5}
          transparent={true}
          opacity={Math.min(0.7, lifetimeMs * 2 / 1000)}
        />
        <pointLight
          color="#60a0ff"
          intensity={Math.min(2, lifetimeMs * 5 / 1000)}
          distance={radius * 2}
          decay={2}
        />
      </mesh>

      {/* Area of effect indicator on ground */}
      <mesh ref={rippleRef} position={[position.x, 0.05, position.z]} rotation={[-Math.PI / 2, 0, 0]}>
        <ringGeometry args={[0.3, 1, 32]} />
        <meshStandardMaterial
          key={`ripple-${position.x}-${position.z}`}
          color="#80c0ff"
          emissive="#4080ff"
          emissiveIntensity={0.3}
          transparent={true}
          opacity={0.6}
          depthWrite={false}
        />
      </mesh>

      {/* Water column base - scale with radius */}
      <mesh position={[position.x, position.y * 0.5, position.z]} scale={[radius * 0.4, Math.min(1.5, lifetimeMs * 4 / 1000), radius * 0.4]}>
        <cylinderGeometry args={[0.4, 0.7, 0.5, 16]} />
        <meshStandardMaterial
          key={`column-${position.x}-${position.z}`}
          color="#60a0ff"
          emissive="#4080ff"
          emissiveIntensity={0.3}
          transparent={true}
          opacity={Math.min(0.8, lifetimeMs * 2 / 1000)}
        />
      </mesh>

      {/* Water droplets */}
      {particles.map((particle, i) => (
        <mesh 
          key={`droplet-${i}-${position.x}-${position.z}`}
          position={particle.position}
          rotation={[particle.rotation.x, particle.rotation.y, particle.rotation.z]}
          scale={[particle.scale, particle.scale * particle.stretching, particle.scale]}
        >
          <sphereGeometry args={[1, 8, 8]} />
          <meshStandardMaterial
            color={particle.color}
            emissive="#4080ff"
            emissiveIntensity={0.2}
            transparent={true}
            opacity={particle.opacity}
          />
        </mesh>
      ))}

      {/* Mist/vapor particles */}
      {mistParticles.current.map((mist, i) => (
        <mesh
          key={`mist-${i}-${position.x}-${position.z}`}
          position={mist.position}
          scale={mist.scale}
        >
          <sphereGeometry args={[1, 8, 8]} />
          <meshStandardMaterial
            color="#b0e0ff"
            emissive="#80c0ff"
            emissiveIntensity={0.1}
            transparent={true}
            opacity={mist.opacity}
            depthWrite={false}
          />
        </mesh>
      ))}
      
      {/* Area of effect indicator */}
      <mesh position={[position.x, 0.1, position.z]} rotation={[-Math.PI / 2, 0, 0]}>
        <ringGeometry args={[radius * 0.9, radius, 32]} />
        <meshBasicMaterial
          color="#40a0ff"
          transparent={true}
          opacity={lifetimeMs * 0.3 / 1000}
          depthWrite={false}
        />
      </mesh>
    </group>
  );
}

// ==============================================================================
// FILE: app/game/stores/useCombatLogStore.ts
// ==============================================================================

import { create } from 'zustand';
import { persist } from 'zustand/middleware';

export interface LogEntry {
  id: number;        // unique, incremental
  text: string;      // already formatted
  ts: number;        // Date.now()
}

interface State {
  list: LogEntry[];
  push: (e: LogEntry) => void;
  trim: () => void;
}

export const useCombatLogStore = create<State>()(
  persist(
    (set, get) => ({
      list: [],
      push: (e) => set({ list: [...get().list, e] }),
      trim: () => set({ list: get().list.slice(-40) }) // keep last 40
    }),
    { 
      name: 'combat-log',
      // For tests, we'll use a storage that quietly fails instead of throwing errors
      // This helps avoid errors in tests while keeping the code simple
      storage: {
        getItem: () => null,
        setItem: () => { /* empty implementation */ },
        removeItem: () => { /* empty implementation */ }
      }
    }
  )
);


// ==============================================================================
// FILE: app/game/systems/SocketManager.tsx
// ==============================================================================

'use client';

import { useEffect, useCallback, useRef } from 'react';
import { io } from 'socket.io-client';
import { useGameStore } from './gameStore';
import { getBuffer, GROUND_Y } from './interpolation';
import { hookVfx } from './vfxDispatcher';
import { initProjectileListeners } from './projectileManager';
import * as THREE from 'three';
import { 
  // MoveIntent is actually used in type definitions
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  MoveIntent,
  CastReq, 
  PosSnap,
  PosDelta,
  VecXZ,
  CastSnapshotMsg,
  EffectSnapshotMsg,
  CombatLogMsg,
  // CastFail is used in the handleCastFail callback
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  CastFail
} from '../../../shared/messages';
import { CM_PER_UNIT } from '../../../shared/netConstants';
import { SkillId } from '../../../shared/skillsDefinition';
import { CastState } from '../../../shared/types';
import { useCombatLogStore } from '../stores/useCombatLogStore';
import { useProjectileStore } from './projectileStore'; // Ensure this is imported
import { SKILLS } from '../../../shared/skillsDefinition'; // Ensure SKILLS is imported

// Variable for generating unique log entry IDs
let nextId = 1;

export default function SocketManager() {
  // Use individual selectors to prevent unnecessary re-renders
  const setSocket = useGameStore(state => state.setSocket);
  const setMyPlayerId = useGameStore(state => state.setMyPlayerId);
  const setGameState = useGameStore(state => state.setGameState);
  const addPlayer = useGameStore(state => state.addPlayer);
  const removePlayer = useGameStore(state => state.removePlayer);
  const updatePlayer = useGameStore(state => state.updatePlayer);
  const updateEnemy = useGameStore(state => state.updateEnemy);
  
  // Maps to track last positions and velocities for delta updates
  const lastPosMap = useRef<Record<string, VecXZ>>({});
  const lastVelMap = useRef<Record<string, VecXZ>>({});

  // Get connection status update functions
  const setConnectionStatus = useCallback((isConnected: boolean) => {
    useGameStore.setState({ 
      isConnected, 
      lastConnectionChangeTs: Date.now() 
    });
  }, []);

  // Memoize event handlers to prevent recreating them on every render
  const handlePlayerLeft = useCallback((playerId: string) => {
    removePlayer(playerId);
  }, [removePlayer]);

  const handlePlayerUpdated = useCallback((playerData: any) => {
    console.log('[SocketManager] Player updated:', playerData);
    
    // Check if skill points are included in the update
    if (playerData.availableSkillPoints !== undefined) {
      console.log(`[SocketManager] Skill points updated for player ${playerData.id}: ${playerData.availableSkillPoints}`);
    }
    
    updatePlayer(playerData);
  }, [updatePlayer]);

  // Add a more efficient player move handler that directly updates player positions
  // without triggering full state updates
  const handlePlayerMoved = useCallback((moveData: { 
    id: string; 
    x: number; 
    y: number; 
    z: number; 
    ry: number;
  }) => {
    // Get current state and players
    const state = useGameStore.getState();
    const players = state.players;
    const player = players[moveData.id];
    
    if (player) {
      // Directly update the position and rotation without triggering a full state update
      player.position.x = moveData.x;
      player.position.y = moveData.y;
      player.position.z = moveData.z;
      player.rotation.y = moveData.ry;
    }
  }, []);

  // Handle position snapshot from server
  const handlePosSnap = useCallback((data: PosSnap) => {
    try {
      if (!data.snaps || !Array.isArray(data.snaps)) {
        console.warn("Invalid PosSnap data received: missing or non-array snaps property", data);
        return;
      }
      
      // Debug log to trace PosSnap messages (only 5% to avoid flooding console)
      if (Math.random() < 0.05) {
        console.log(`Received PosSnap with ${data.snaps.length} entries:`, JSON.stringify(data));
      }
      
      const state = useGameStore.getState();
      const myPlayerId = state.myPlayerId;
      const clientReceiveTs = performance.now();
      
      // Process each player snapshot in the batch
      for (const snap of data.snaps) {
        const { id, pos, vel, snapTs: serverSnapTs } = snap;
        
        if (!id || !pos || !serverSnapTs) {
          console.warn("Invalid snapshot entry:", snap);
          continue;
        }
        
        const player = state.players[id];
        if (player) {
          // Get global buffer reference for this player
          const buffer = getBuffer(id);
          
          // Use velocity from snapshot or default to zero if not provided
          const velocity = vel || { x: 0, z: 0 };
          
          // Create a properly timestamped snap object
          const snapObject = {
            pos: pos,
            vel: velocity,
            rot: player.rotation?.y || 0,
            snapTs: clientReceiveTs,
            serverSnapTs: serverSnapTs
          };
          
          // Enhanced debugging to see what's being pushed to the buffer
          if (id === myPlayerId && Math.random() < 0.1) {
            console.log("Pushing to position buffer:", {
              id,
              pos,
              vel,
              serverSnapTs,
              clientReceiveTs,
              currentBufferLength: buffer.getBufferLength()
            });
          }
          
          // Additional validation to check for invalid position data
          if (pos.x === 0 && pos.z === 0) {
            console.warn(`Position at (0,0) detected in PosSnap for player ${id}. This might cause movement issues.`);
          }
          
          // Check for duplicates before pushing
          const existingSnap = buffer.getBufferLength() > 0 ? 
            buffer.sample(serverSnapTs) : null;
            
          if (existingSnap && 
              Math.abs(existingSnap.x - pos.x) < 0.001 && 
              Math.abs(existingSnap.z - pos.z) < 0.001) {
            // Skip duplicate position to prevent animation repeating
            // Just update the maps and continue
            lastPosMap.current[id] = pos;
            lastVelMap.current[id] = velocity;
            continue;
          }
          
          // Push to the module-global buffer for calculations
          buffer.push(snapObject);
          
          // Track last known server position for this player
          useGameStore.getState().serverLastKnownPositions = {
            ...useGameStore.getState().serverLastKnownPositions,
            [id]: { ...pos }
          };
          
          // Enhanced debug logging, especially for controlled player
          if (id === myPlayerId) {
            if (Math.random() < 0.05) {
                const latestSample = buffer.sample(performance.now() - 100);
              console.log(`MyPlayer Position Update:`, {
                playerId: id,
                pos: pos,
                vel: velocity,
                bufferLength: buffer.getBufferLength(),
                latestSample: latestSample,
                serverSnapTs: new Date(serverSnapTs).toISOString(),
                clientReceiveTs: new Date(clientReceiveTs).toISOString(),
                timeDiff: clientReceiveTs - serverSnapTs
              });
            }
          }
          
          // Update last position and velocity maps
          lastPosMap.current[id] = pos;
          lastVelMap.current[id] = velocity;
        }
      }
    } catch (err) {
      console.error("Error processing position snapshot:", err);
    }
  }, []);
  
  // Handle delta-compressed position updates
  const handlePosDelta = useCallback((data: PosDelta) => {
    try {
      const { id, dx, dz, vdx, vdz, serverTs } = data;
      
      // Get last known position or default to origin
      const lastPos = lastPosMap.current[id] ?? { x: 0, z: 0 };
      
      // Calculate new absolute position from deltas (cm → m)
      const newPos = { 
        x: lastPos.x + dx / CM_PER_UNIT, 
        z: lastPos.z + dz / CM_PER_UNIT 
      };
      
      const state = useGameStore.getState();
      const myPlayerId = state.myPlayerId;
      const player = state.players[id];
      
      if (player) {
        // Get current velocity or use last known
        let vel = lastVelMap.current[id] || { x: 0, z: 0 };
        
        // Apply velocity delta if provided
        if (vdx !== undefined && vdz !== undefined) {
          vel = {
            x: vel.x + vdx / CM_PER_UNIT,
            z: vel.z + vdz / CM_PER_UNIT
          };
          lastVelMap.current[id] = vel;
        }
        
        // Get module-global buffer reference for this player
        const buffer = getBuffer(id);
        const clientReceiveTs = performance.now();
        
        // Create the snap object
        const snapObject = {
          pos: newPos,
          vel: vel,
          rot: player.rotation?.y || 0,
          snapTs: clientReceiveTs
        };
        
        // Check for duplicates before pushing
        const existingSnap = buffer.getBufferLength() > 0 ? 
          buffer.sample(snapObject.snapTs) : null;
          
        if (existingSnap && 
            Math.abs(existingSnap.x - newPos.x) < 0.001 && 
            Math.abs(existingSnap.z - newPos.z) < 0.001) {
          // Skip duplicate position to prevent animation repeating
          // Just update the maps and don't push to buffer
          lastPosMap.current[id] = newPos;
          return;
        }
        
        // Push to buffer
        buffer.push(snapObject);
        
        // Special debug for my player's snapBuffer to diagnose camera issues
        if (id === myPlayerId && Math.random() < 0.05) { // Only log 5% of updates to avoid spam
          console.log(`MyPlayer (${id}) SnapBuffer delta update:`, {
            bufferExists: !!buffer,
            hasSampleMethod: buffer && typeof buffer.sample === 'function',
            pos: newPos,
            serverTs
          });
        }
        
        // Update last position map
        lastPosMap.current[id] = newPos;
      }
    } catch (err) {
      console.error("Error processing position delta:", err);
    }
  }, []);

  // Handle skill cast failure
  const handleCastFail = useCallback((data: { clientSeq: number, reason?: string }) => {
    const state = useGameStore.getState();
    const myPlayerId = state.myPlayerId;
    const players = state.players;
    const player = myPlayerId ? players[myPlayerId] : null;
    
    if (player) {
      // Get the skill that failed (if we can identify it from clientSeq)
      // For now we just reset the skill state in case it was locally set
      
      // Revert any local mana or cooldown changes
      if (data.reason === 'nomana') {
        // Flash mana bar red briefly
        useGameStore.setState({ manaBarFlash: true });
        setTimeout(() => useGameStore.setState({ manaBarFlash: false }), 300);
      }
      
      // Flash the skill icon red
      const skillId = state.lastCastSkillId || null;
      if (skillId) {
        useGameStore.setState({ flashingSkill: skillId });
        setTimeout(() => useGameStore.setState({ flashingSkill: null }), 300);
      }
      
      // Log the failure reason with improved error handling
      const reasons: Record<string, string> = {
        cooldown: 'Skill is on cooldown',
        nomana: 'Not enough mana',
        invalid: 'Invalid target or skill',
        outofrange: 'Target is out of range'
      };
      
      // Default to 'invalid' if no reason provided or if reason doesn't match known reasons
      const reason = (data.reason && reasons[data.reason]) ? data.reason : 'invalid';
      console.log(`Cast failed: ${reasons[reason] || 'Invalid target or skill'} (${data.reason || 'unknown'})`);
    }
  }, []);

  const handleEnemyUpdated = useCallback((enemyData: any) => {
    updateEnemy(enemyData);
  }, [updateEnemy]);
  
  // Handle cast snapshot updates
  const handleCastSnapshot = useCallback((data: CastSnapshotMsg) => {
    const castData = data.data;
    const { add: addProjectileToStore, hit: markProjectileHit } = useProjectileStore.getState();
    
    console.log(`[SocketManager] Handling CastSnapshot: castId=${castData.castId}, skillId=${castData.skillId}, state=${castData.state}, pos=${JSON.stringify(castData.pos)}, target=${JSON.stringify(castData.target)}`);
    
    // Special logging for fireball
    if (castData.skillId === 'fireball') {
      console.log(`[SocketManager] Received Fireball CastSnapshot: castId=${castData.castId}, state=${castData.state}, pos=${JSON.stringify(castData.pos)}, target=${JSON.stringify(castData.target)}`);
    }
    
    // Update player's casting UI state (e.g., for CastingBar)
    if (castData.state === CastState.Casting) {
      // Skill is being cast (equivalent to old CastStart)
      console.log(`[SocketManager] Setting player ${castData.casterId} casting state: skillId=${castData.skillId}, castTimeMs=${castData.castTimeMs || 1000}`);
      updatePlayer({
        id: castData.casterId,
        castingSkill: castData.skillId as string,
        castingProgressMs: castData.castTimeMs || 1000 // Use cast time from snapshot or default to 1000ms
      });
    } else if (castData.state === CastState.Traveling || castData.state === CastState.Impact) {
      // If skill is no longer casting (i.e., it's traveling or has impacted),
      // clear the castingSkill for this player
      const playerToUpdate = useGameStore.getState().players[castData.casterId];
      if (playerToUpdate && playerToUpdate.castingSkill === castData.skillId) {
        console.log(`[SocketManager] Clearing player ${castData.casterId} casting state for skill ${castData.skillId}`);
        useGameStore.getState().updatePlayer({
          id: castData.casterId,
          castingSkill: null,
          castingProgressMs: 0
        });
      }
    }
    
    if (castData.state === CastState.Impact) {
      // Projectile impacted or instant skill resolved
      console.log(`[SocketManager] Marking projectile as hit: castId=${castData.castId}`);
      markProjectileHit({ type: 'ProjHit2', castId: castData.castId, hitIds: [], dmg: [] }); // Minimal hit message for store
    }
    
    const skillDef = SKILLS[castData.skillId as SkillId];
    if (skillDef && skillDef.projectile && castData.state === CastState.Traveling) {
      // This is a projectile that has just started traveling
      console.log(`[SocketManager] Processing traveling projectile: castId=${castData.castId}, skillId=${castData.skillId}`);
      
      if (castData.pos && castData.origin && castData.dir) {
        // Use the direction vector provided by server
        const projectileDataForStore = {
          type: 'ProjSpawn2', // This is an internal type hint for the store's data structure
          castId: castData.castId,
          skillId: castData.skillId as SkillId,
          // Use origin from server, with default y value
          origin: { x: castData.origin.x, y: 1.5, z: castData.origin.z },
          dir: castData.dir, // Use direction vector from server
          speed: skillDef.projectile.speed,
          launchTs: castData.startedAt, // Use server's cast start time for more accurate timing
          casterId: castData.casterId,
          hitRadius: skillDef.projectile.hitRadius || 0.5,
        };
        
        // Special logging for fireball
        if (castData.skillId === 'fireball') {
          console.log('[SocketManager] Adding Fireball to projectile store. Data:', JSON.stringify(projectileDataForStore));
        }
        
        // Debug the current projectileStore state
        const currentStore = useProjectileStore.getState();
        console.log(`[SocketManager] Current projectileStore before adding - live: ${Object.keys(currentStore.live).length}, recycled: ${Object.keys(currentStore.toRecycle).length}`);
        
        addProjectileToStore(projectileDataForStore);
        
        // Verify projectile was added
        setTimeout(() => {
          const updatedStore = useProjectileStore.getState();
          console.log(`[SocketManager] ProjectileStore after adding - live: ${Object.keys(updatedStore.live).length}, recycled: ${Object.keys(updatedStore.toRecycle).length}`);
          const addedProjectile = updatedStore.live[castData.castId];
          if (addedProjectile) {
            console.log(`[SocketManager] Successfully added projectile to store: castId=${castData.castId}`);
          } else {
            console.error(`[SocketManager] Failed to add projectile to store: castId=${castData.castId}`);
          }
        }, 10);
      } else {
        console.warn('[SocketManager] CastSnapshot (Traveling) for projectile missing essential data (pos, origin, or dir):', castData);
      }
    }
    
    // Dispatch generic event for other systems (e.g., non-projectile VFX for instant skills like PetrifyFlash)
    window.dispatchEvent(new CustomEvent('castsnapshot', { detail: castData }));
  }, [updatePlayer]);

  // Handle effect snapshots from server
  const handleEffectSnapshot = useCallback((msg: EffectSnapshotMsg) => {
    console.log(`Received EffectSnapshot for target ${msg.targetId}:`, msg);
    
    const targetId = msg.targetId;
    const effects = msg.effects || [];
    
    // Add to combat log
    if (effects.length > 0) {
      effects.forEach(effect => {
        useCombatLogStore.getState().push({
          id: nextId++,
          text: `>>> ${effect.type.toUpperCase()} applied to ${targetId}`,
          ts: Date.now()
        });
      });
      
      // Trim the log after adding entries
      useCombatLogStore.getState().trim();
    }
    
    // Check if this is a player effect
    const players = useGameStore.getState().players;
    if (players[targetId]) {
      // Update player with new status effect info
      updatePlayer({
        id: targetId,
        statusEffects: effects
      });
    }
    
    // Check if this is an enemy effect
    const enemies = useGameStore.getState().enemies;
    if (enemies[targetId]) {
      // Update enemy with new status effect info
      updateEnemy({
        id: targetId,
        statusEffects: effects
      });
      
      // Trigger visual effects for each effect
      effects.forEach(effect => {
        const enemy = enemies[targetId];
        const position = enemy ? { x: enemy.position.x, y: enemy.position.y, z: enemy.position.z } : undefined;
        
        if (position) {
          // For burn effects
          if (effect.type === 'burn') {
            window.dispatchEvent(new CustomEvent('spawnSplash', {
              detail: { position, radius: 1.2, effectType: 'fire' }
            }));
          }
          // For bleed effects
          else if (effect.type === 'bleed') {
            window.dispatchEvent(new CustomEvent('spawnSplash', {
              detail: { position, radius: 0.8, effectType: 'blood' }
            }));
          }
        }
      });
    }
  }, [updatePlayer, updateEnemy]);

  // Handle combat log messages from server
  const handleCombatLog = useCallback((msg: CombatLogMsg) => {
    console.log(`Received CombatLog for castId ${msg.castId}:`, msg);
    
    const player = useGameStore.getState().getMyPlayer();
    const playerId = player?.id || '';
    
    // Check if there's damage information
    if (msg.damages && msg.damages.length > 0 && msg.targets && msg.targets.length > 0) {
      // For each hit target
      msg.targets.forEach((targetId, index) => {
        const damage = msg.damages[index];
        const total = damage;
        const crit = damage > 200; // crude threshold for critical hits
        
        useCombatLogStore.getState().push({
          id: nextId++,
          text: `${msg.casterId === playerId ? 'You' : 'Enemy'} hit ${
            targetId === playerId ? 'YOU' : 'enemy'
          } for ${total}${crit ? ' (CRIT!)' : ''}`,
          ts: Date.now()
        });
      });
      
      // Trim the log after adding entries
      useCombatLogStore.getState().trim();
    }
  }, []);

  // Memoize the socket connection handler
  const handleConnect = useCallback(() => {
    // Connect to WebSocket server with improved configuration
    const socket = io('http://localhost:3001', {
      path: '/socket.io',
      transports: ['websocket'],
      perMessageDeflate: { threshold: 1024 },   // Enable compression with threshold
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      reconnectionAttempts: 5
    });

    socket.on('connect', () => {
      console.log('Connected to game server, setting socket in game store');
      setConnectionStatus(true);
      setSocket(socket);  // Make sure we set the socket in the game store
      
      // Hook up VFX event system
      hookVfx(socket);
      
      // Initialize projectile manager listeners
      initProjectileListeners();

      // Removed automatic joinGame emission to prevent duplicate player IDs

      // Set up skill-related event handlers - will be deprecated after migration
      socket.on('skillEffect', (data: { skillId: string, sourceId: string, targetId: string }) => {
        // Update game state based on skill effects
        console.log('Legacy skillEffect received from server:', data);
        
        // This handler will be removed after the new projectile system is confirmed working
        const gameState = useGameStore.getState();
        const sourcePlayer = gameState.players[data.sourceId];
        const targetEnemy = gameState.enemies[data.targetId];
        
        if (sourcePlayer && targetEnemy) {
          // Dispatch a custom event that ActiveSkills can listen for
          window.dispatchEvent(new CustomEvent('skillTriggered', { 
            detail: {
              id: `effect-${Math.random().toString(36).substring(2, 9)}`,
              skillId: data.skillId as string,
              sourceId: data.sourceId,
              targetId: data.targetId,
              startPosition: sourcePlayer.position,
              targetPosition: targetEnemy.position,
              createdAtTs: Date.now()
            }
          }));
        } else {
          console.warn('Could not find source player or target enemy for skill effect:', {
            skillId: data.skillId,
            sourceId: data.sourceId,
            targetId: data.targetId,
            sourceMissing: !sourcePlayer,
            targetMissing: !targetEnemy,
            playerCount: Object.keys(gameState.players).length,
            enemyCount: Object.keys(gameState.enemies).length
          });
        }
      });

      socket.on('skillCooldownUpdate', (data: { skillId: string, cooldownEndTime: number }) => {
        // Update skill cooldowns in game state
        console.log('Cooldown update received:', data);
      });

      // Handle existing events...
      socket.on('gameState', (gameState: any) => {
        const myPlayerId = useGameStore.getState().myPlayerId;
        console.log('Received game state:', {
          enemyCount: Object.keys(gameState.enemies || {}).length,
          playerCount: Object.keys(gameState.players || {}).length,
          playerSkills: myPlayerId ? gameState.players[myPlayerId]?.skills : []
        });
        setGameState(gameState);
      });

      socket.on('joinGame', (data: { playerId: string }) => {
        console.log('Joined game with player ID:', data.playerId);
        setMyPlayerId(data.playerId);
        // Request full game state after setting ID
        socket.emit('requestGameState');
      });

      // Handle new players joining
      socket.on('playerJoined', (player: any) => {
        console.log('New player joined:', player);
        addPlayer(player);
      });
      
      // Handle when other players update their state
      socket.on('playerUpdated', (playerData: any) => {
        console.log('Player updated:', playerData);
        updatePlayer(playerData);
      });

      socket.on('newPlayer', (player: any) => {
        addPlayer(player);
      });

      socket.on('msg', (msg: any) => {
        // Add validation to prevent "Unknown message type: undefined" errors
        if (!msg) {
          console.error('Received null or undefined message');
          return;
        }

        // Handle case where we receive an array of messages instead of a single message
        if (Array.isArray(msg)) {
          console.log('Received array of messages, processing each one:', JSON.stringify(msg));
          msg.forEach((item, index) => {
            if (item && typeof item === 'object' && item.type) {
              // Process each valid message in the array
              console.log(`Processing array item ${index} with type: ${item.type}`);
              processMessage(item);
            } else {
              console.warn(`Skipping invalid message in array at index ${index}:`, item);
            }
          });
          return;
        }
        
        // Handle single message object
        if (typeof msg !== 'object') {
          console.error('Received invalid message format:', msg);
          return;
        }
        
        if (!msg.type) {
          console.error('Received message without type property:', msg);
          return;
        }
        
        // Process the single message
        processMessage(msg);
      });
      
      // Helper function to process a single message
      const processMessage = (msg: any) => {
        switch (msg.type) {
          case 'BatchUpdate': {
            // Handle batch updates from server
            if (Array.isArray(msg.updates)) {
              // Process each update in the batch
              msg.updates.forEach(update => {
                if (update && typeof update === 'object' && update.type) {
                  // Process each valid message in the batch
                  processMessage(update);
                }
              });
            }
            break;
          }
          case 'PosSnap': {
            handlePosSnap(msg);
            break;
          }
          case 'PosDelta': {
            handlePosDelta(msg);
            break;
          }
          case 'CastFail': {
            handleCastFail(msg);
            break;
          }
          case 'SkillShortcutUpdated': {
            // Update local shortcuts to match server state
            console.log('Skill shortcut updated:', msg);
            try {
              if (typeof msg.slotIndex !== 'number' || msg.slotIndex < 0 || msg.slotIndex > 8) {
                console.error('Invalid slot index in SkillShortcutUpdated message:', msg.slotIndex);
                break;
              }
              
              const player = useGameStore.getState().getMyPlayer();
              if (!player) {
                console.error('Cannot update skill shortcuts: No player data available');
                break;
              }
              
              if (!player.skillShortcuts) {
                console.error('Cannot update skill shortcuts: Player has no skillShortcuts array');
                break;
              }
              
              // Create a new array from existing shortcuts to avoid reference issues
              const updatedShortcuts = [...player.skillShortcuts];
              updatedShortcuts[msg.slotIndex] = msg.skillId;
              
              // Update player in store
              useGameStore.getState().updatePlayer({
                id: player.id,
                skillShortcuts: updatedShortcuts
              });
              
              console.log(`Successfully updated skill shortcut at slot ${msg.slotIndex+1} to ${msg.skillId}`);
            } catch (error) {
              console.error('Error processing SkillShortcutUpdated message:', error);
            }
            break;
          }
          case 'SkillLearned': {
            // Handle skill learned confirmation from server
            console.log('Skill learned:', msg);
            if (useGameStore.getState().myPlayerId) {
              const player = useGameStore.getState().getMyPlayer();
              if (player) {
                // Create a new array of unlocked skills with the new skill
                const updatedUnlockedSkills = [...player.unlockedSkills, msg.skillId];
                // Update the player with the new skill and remaining points
                useGameStore.getState().updatePlayer({
                  id: player.id,
                  unlockedSkills: updatedUnlockedSkills,
                  availableSkillPoints: msg.remainingPoints
                });
              }
            }
            break;
          }
          case 'ProjSpawn2': {
            console.log(`[SocketManager] Received ProjSpawn2 message - using new CastSnapshot system instead`);
            break;
          }
          case 'ProjHit2': {
            console.log(`[SocketManager] Received ProjHit2 message - using new CastSnapshot system instead`);
            break;
          }
          case 'CastSnapshot': {
            handleCastSnapshot(msg as CastSnapshotMsg);
            break;
          }
          case 'EffectSnapshot': {
            handleEffectSnapshot(msg as EffectSnapshotMsg);
            break;
          }
          case 'CombatLog': {
            handleCombatLog(msg as CombatLogMsg);
            break;
          }
          default: {
            console.log('Unknown message type:', msg.type);
            break;
          }
        }
      };

      // Keep old handlers for compatibility during transition
      socket.on('playerLeft', handlePlayerLeft);
      socket.on('playerUpdated', handlePlayerUpdated);
      socket.on('enemyUpdated', handleEnemyUpdated);
      socket.on('playerMoved', handlePlayerMoved);
    });

    return socket;
  }, [
    setSocket, 
    setMyPlayerId, 
    setGameState, 
    addPlayer, 
    handlePlayerLeft, 
    handlePlayerUpdated, 
    handlePlayerMoved, 
    handleEnemyUpdated,
    handlePosSnap,
    handlePosDelta,
    handleCastFail,
    handleCastSnapshot,
    handleEffectSnapshot,
    handleCombatLog,
    setConnectionStatus
  ]);

  useEffect(() => {
    const socket = handleConnect();
    
    // Cleanup on unmount
    return () => {
      if (socket) {
        socket.disconnect();
      }
    };
  }, [handleConnect]);

  // Add debugging to socket updates
  useEffect(() => {
    // Get the current socket from the game store
    const socket = useGameStore.getState().socket;
    if (!socket) return;
    
    const debugSocketEvents = (eventName: string) => {
      const originalOn = socket.on.bind(socket);
      socket.on = function(event: string, callback: (...args: any[]) => any) {
        if (event === eventName) {
          const wrappedCallback = function(this: any, ...args: any[]) {
            console.log(`[Socket] ${event} received:`, ...args);
            return callback.apply(this, args);
          };
          return originalOn(event, wrappedCallback);
        }
        return originalOn(event, callback);
      };
    };
    
    // Debug specific events
    debugSocketEvents('playerJoined');
    debugSocketEvents('playerUpdated');
    debugSocketEvents('gameState');
    debugSocketEvents('msg');
    
    // Log outgoing messages
    const originalEmit = socket.emit.bind(socket);
    socket.emit = function(event: string, ...args: any[]) {
      if (event === 'msg' || event === 'joinGame' || event === 'requestGameState') {
        console.log(`[Socket] Emitting ${event}:`, args);
      }
      return originalEmit(event, ...args);
    };
    
  }, []);

  // The only movement message function we now need is sendMoveIntent
  const sendMoveIntent = useCallback((targetPos: VecXZ) => {
    const socket = useGameStore.getState().socket;
    const myPlayerId = useGameStore.getState().myPlayerId;
    
    if (!socket || !myPlayerId) return;
    
    // Log the outgoing message for debugging
    console.log('Sending MoveIntent to server:', { targetPos });
    
    socket.emit('msg', {
      type: 'MoveIntent',
      id: myPlayerId,
      targetPos,
      clientTs: Date.now()
    });
    
    // Don't update player locally - let server updates control movement
    // Store the target in UI state only - not as a position/movement update
    useGameStore.getState().setTargetWorldPos(new THREE.Vector3(targetPos.x, GROUND_Y, targetPos.z));
  }, []);
  
  // Function to send CastReq message
  const sendCastReq = useCallback((skillId: string, targetId?: string, targetPos?: VecXZ) => {
    const socket = useGameStore.getState().socket;
    const myPlayerId = useGameStore.getState().myPlayerId;
    
    if (!socket || !myPlayerId) return;
    
    const castReq: CastReq = {
      type: 'CastReq',
      id: myPlayerId,
      skillId: skillId as SkillId,
      targetId,
      targetPos,
      clientTs: Date.now()
    };
    
    socket.emit('msg', castReq);
  }, []);
  
  // Add these functions to the game store for components to use
  useEffect(() => {
    useGameStore.setState({
      sendCastReq,
      sendMoveIntent
    });
  }, [sendCastReq, sendMoveIntent]);

  return null;
}


// ==============================================================================
// FILE: app/game/systems/castController.ts
// ==============================================================================

'use client';

import { useGameStore } from './gameStore';
import { SkillId } from '../../../shared/skillsDefinition';
import { VecXZ } from '../../../shared/messages';

/**
 * Tries to start casting a skill. This is a unified entry point for skill casting
 * that delegates to the server for validation and execution.
 * 
 * This function is completely server-authoritative and does not perform any client-side
 * validation or state changes. The server will determine:
 * - If the player has enough mana
 * - If the skill is off cooldown
 * - If the target is valid and in range
 * - Apply all costs, cooldowns and effects
 * 
 * The client will receive updates via CastSnapshot, EffectSnapshot, and CombatLog messages
 * 
 * @param skillId The ID of the skill to cast
 * @param targetId Optional ID of the target entity
 * @param targetPos Optional position to target the skill at
 */
export function tryStartCast(skillId: SkillId, targetId?: string, targetPos?: VecXZ) {
  // Get the selected target from the game store if not explicitly provided
  const selectedTargetId = targetId || useGameStore.getState().selectedTargetId;
  
  console.log(`Attempting to cast skill: ${skillId}`, {
    targetId: selectedTargetId,
    targetPos
  });
  
  // Send the cast request to the server via socket
  useGameStore.getState().sendCastReq(skillId, selectedTargetId || undefined, targetPos);
  
  // Set this as the selected skill for UI state
  useGameStore.getState().setSelectedSkill(skillId);
}


// ==============================================================================
// FILE: app/game/systems/gameStore.ts
// ==============================================================================

'use client';

import { create } from 'zustand';
import { produce } from 'immer';
import { Character } from '../models/Character';
import { Enemy } from '../models/Enemy';
import { VecXZ, PlayerMovementState } from '../../../shared/types';

// StatusEffect interface for tracking active effects
export interface StatusEffect {
  id: string;
  type: string;
  value: number;
  durationMs: number;
  startTimeTs: number;
  sourceSkill: string;
  stacks?: number;  // Optional stacks field for stackable effects
}

// Define the structure for player state received from the server
interface PlayerState extends Character {
  socketId?: string;
  experience: number;
  experienceToNextLevel: number;
  statusEffects: StatusEffect[];
  skillCooldownEndTs: Record<string, number>;
  castingSkill: string | null;
  castingProgressMs: number;
  isAlive: boolean;
  movement?: PlayerMovementState;
}

// Define the structure for the overall game state received from the server
interface ServerGameState {
  players: Record<string, PlayerState>;
  enemies: Record<string, Enemy>;
}

interface GameState {
  // --- State ---
  myPlayerId: string | null;
  players: Record<string, PlayerState>;
  enemies: Record<string, Enemy>;
  selectedTargetId: string | null;
  lastCastSkillId: string | null;
  flashingSkill: string | null;  // Skill ID that should flash red (for failures)
  manaBarFlash: boolean;         // Whether mana bar should flash red
  currentZoneId: string | null;
  donationXpBoost: number;
  donationBoostEndTimeTs: number | null;
  bonusXpEventActive: boolean;
  serverLastKnownPositions: Record<string, { x: number, z: number }>;  // Last known positions from server
  player: PlayerState | null;
  experience: number;
  experienceToNextLevel: number;
  skillCooldownEndTs: Record<string, number>;
  castingSkill: string | null;
  castingProgressMs: number;
  isConnected: boolean;
  lastConnectionChangeTs: number;
  socket: any | null;
  hasJoinedGame: boolean;
  selectedSkill: string | null;
  targetWorldPos: { x: number, y: number, z: number } | null;
  lastMoveSentTimeMs: number | null; // Track the last time we sent a movement update

  // --- Methods ---
  setSocket: (socketInstance: any) => void;
  setGameState: (newState: ServerGameState) => void;
  setMyPlayerId: (id: string) => void;
  addPlayer: (player: PlayerState) => void;
  removePlayer: (playerId: string) => void;
  updatePlayer: (playerData: Partial<PlayerState> & { id: string }) => void;
  updateEnemy: (enemyData: Partial<Enemy> & { id: string }) => void;
  // Movement - server authoritative
  sendMoveIntent: (targetPos: VecXZ) => void;
  sendCastReq: (skillId: string, targetId?: string, targetPos?: VecXZ) => void;
  // Legacy methods for backward compatibility
  sendPlayerMove: (position: { x: number; y: number; z: number }, rotationY: number) => void;
  // Other methods
  sendSelectTarget: (targetId: string | null) => void;
  selectTarget: (targetId: string | null) => void;
  setSelectedSkill: (skillId: string | null) => void;
  setTargetWorldPos: (pos: { x: number, y: number, z: number } | null) => void;
  getMyPlayer: () => PlayerState | null;
  getSelectedTarget: () => Enemy | null;
  getStatusEffects: (targetId: string | 'player') => StatusEffect[];
  getXpMultiplierInfo: () => { base: number; donation: number; event: number; total: number };
  applyDonationBoost: (amount: number, durationMinutes: number) => void;
  clearDonationBoost: () => void;
  toggleXpEvent: () => void;
  updatePlayerZone: () => void;
  applySkillEffect: (targetId: string, effects: any[]) => void;
  setHasJoinedGame: (joined: boolean) => void;
  handleSkillHotkey: (key: string) => void;
  setActiveSkill: (skillId: string | null) => void;
  
  // --- New explicitly defined action functions ---
  setLocalPlayerPos: (pos: { x: number, y: number, z: number }) => void;
  setLocalPlayerVel: (vel: { x: number, z: number }) => void;
  setStatusEffects: (targetId: string, effects: StatusEffect[]) => void;
  addXp: (amount: number) => void;
}

// --- Memoized selectors ---
// We ensure selectors are stable by declaring them outside the store
const selectPlayers = (state: GameState) => state.players;
const selectPlayerIds = (state: GameState) => {
  const players = selectPlayers(state);
  
  // Only recompute if players object has changed
  if (players !== previousPlayers) {
    playerIdsCache = Object.keys(players);
    previousPlayers = players;
  }
  
  return playerIdsCache;
};

// Ensure stable reference by caching the array instance
let playerIdsCache: string[] = [];
let previousPlayers: Record<string, PlayerState> | null = null;

// Create a stable memoized selector for status effects
const selectStatusEffects = (targetId: string | 'player') => {
  const selector = (state: GameState) => {
    if (targetId === 'player') {
      const player = state.myPlayerId ? state.players[state.myPlayerId] : null;
      return player?.statusEffects || [];
    }
    const enemy = state.enemies[targetId];
    return enemy?.statusEffects || [];
  };
  // Add metadata for stable referencing
  selector.store = { targetId };
  return selector;
};

const selectMyPlayerId = (state: GameState) => state.myPlayerId;
const selectEnemies = (state: GameState) => state.enemies;
const selectEnemyCount = (state: GameState) => Object.keys(state.enemies).length;
const selectSelectedTargetId = (state: GameState) => state.selectedTargetId;

// Memoized player selector using a stable function
const selectPlayer = (id: string) => {
  const selector = (state: GameState) => selectPlayers(state)[id];
  // Using Object.is for referential equality check
  selector.store = { id };
  return selector;
};

const selectSendPlayerMove = (state: GameState) => state.sendPlayerMove;
const selectGetPlayer = (state: GameState) => state.getMyPlayer;

export {
  selectPlayers,
  selectPlayerIds,
  selectMyPlayerId,
  selectEnemies,
  selectEnemyCount,
  selectSelectedTargetId,
  selectPlayer,
  selectSendPlayerMove,
  selectGetPlayer,
  selectStatusEffects,
};

export const useGameStore = create<GameState>((set, get) => ({
  // --- Initial State ---
  myPlayerId: null,
  players: {},
  enemies: {},
  selectedTargetId: null,
  lastCastSkillId: null,
  flashingSkill: null,
  manaBarFlash: false,
  currentZoneId: null,
  donationXpBoost: 0,
  donationBoostEndTimeTs: null,
  bonusXpEventActive: false,
  serverLastKnownPositions: {},
  player: null,
  experience: 0,
  experienceToNextLevel: 100,
  skillCooldownEndTs: {},
  castingSkill: null,
  castingProgressMs: 0,
  isConnected: false,
  lastConnectionChangeTs: Date.now(),
  socket: null,
  hasJoinedGame: false,
  selectedSkill: null,
  targetWorldPos: null,
  lastMoveSentTimeMs: null,

  // --- New explicitly defined action functions ---
  setLocalPlayerPos: (pos: { x: number, y: number, z: number }) => {
    set(produce(state => {
      const player = state.myPlayerId ? state.players[state.myPlayerId] : null;
      if (player) {
        player.position.x = pos.x;
        player.position.y = pos.y;
        player.position.z = pos.z;
      }
    }));
  },

  setLocalPlayerVel: (vel: { x: number, z: number }) => {
    set(produce(state => {
      const player = state.myPlayerId ? state.players[state.myPlayerId] : null;
      if (player) {
        if (!player.velocity) {
          player.velocity = { x: 0, y: 0, z: 0 };
        }
        player.velocity.x = vel.x;
        player.velocity.z = vel.z;
      }
    }));
  },

  setStatusEffects: (targetId: string, effects: StatusEffect[]) => {
    set(produce(state => {
      if (targetId === 'player' || targetId === state.myPlayerId) {
        const player = state.myPlayerId ? state.players[state.myPlayerId] : null;
        if (player) {
          // Create a new array to ensure proper reference change
          player.statusEffects = [...effects];
        }
      } else {
        const enemy = state.enemies[targetId];
        if (enemy) {
          // Create a new array to ensure proper reference change
          enemy.statusEffects = [...effects];
        }
      }
    }));
  },

  addXp: (amount: number) => {
    set(produce(state => {
      const player = state.myPlayerId ? state.players[state.myPlayerId] : null;
      if (player) {
        player.experience += amount;
        
        // Optional: Check if player has leveled up and adjust experienceToNextLevel
        if (player.experience >= player.experienceToNextLevel) {
          // This may need to be handled by server, but we can simulate it locally too
          player.experience -= player.experienceToNextLevel;
          player.experienceToNextLevel = Math.floor(player.experienceToNextLevel * 1.5);
        }
      }
    }));
  },

  // --- Methods ---
  setSocket: (socketInstance: any) => {
    set(produce(state => {
      state.socket = socketInstance;
    }));
  },
  
  // New method to handle keyboard shortcuts for skills
  handleSkillHotkey: (key: string) => {
    const player = get().getMyPlayer();
    const selectedTarget = get().selectedTargetId;
    
    if (!player || !player.skillShortcuts) return;
    
    // Convert key to index (keys 1-9 map to array indices 0-8)
    const keyNum = parseInt(key);
    if (isNaN(keyNum) || keyNum < 1 || keyNum > 9) return;
    
    const shortcutIndex = keyNum - 1;
    const skillId = player.skillShortcuts[shortcutIndex];
    
    if (skillId) {
      console.log(`Using skill hotkey ${keyNum} to cast ${skillId}`);
      get().setSelectedSkill(skillId);
      
      // If there's a selected target, cast immediately
      if (selectedTarget) {
        get().sendCastReq(skillId, selectedTarget);
      }
    }
  },

  setGameState: (newState: ServerGameState) => {
    set(produce(state => {
      state.players = newState.players;
      state.enemies = newState.enemies;
      state.selectedTargetId = newState.enemies[state.selectedTargetId ?? ''] ? state.selectedTargetId : null;
    }));
  },

  setMyPlayerId: (id: string) => {
    set(produce(state => {
      state.myPlayerId = id;
    }));
  },

  addPlayer: (player: PlayerState) => {
    set(produce(state => {
      state.players[player.id] = player;
    }));
  },

  removePlayer: (playerId: string) => {
    set(produce(state => {
      delete state.players[playerId];
    }));
  },

  updatePlayer: (playerData: Partial<PlayerState> & { id: string }) => {
    set(produce(state => {
      const currentPlayer = state.players[playerData.id];
      if (!currentPlayer) return;
      
      // Handle statusEffects immutably
      if ('statusEffects' in playerData && Array.isArray(playerData.statusEffects)) {
        currentPlayer.statusEffects = [...playerData.statusEffects];
        
        // Create a copy without statusEffects
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { statusEffects: _ignored, ...otherProps } = playerData;
        
        // Check if any values are actually different before updating
        const hasChanges = Object.keys(otherProps).some(key => 
          otherProps[key as keyof typeof otherProps] !== currentPlayer[key as keyof typeof currentPlayer]
        );
        
        if (hasChanges) {
          Object.assign(currentPlayer, otherProps);
        }
      } else {
        // No statusEffects property, so we can update everything directly
        const hasChanges = Object.keys(playerData).some(key => 
          playerData[key as keyof typeof playerData] !== currentPlayer[key as keyof typeof currentPlayer]
        );
        
        if (hasChanges) {
          Object.assign(currentPlayer, playerData);
        }
      }
    }));
  },

  updateEnemy: (enemyData: Partial<Enemy> & { id: string }) => {
    set(produce(state => {
      const enemy = state.enemies[enemyData.id];
      if (enemy) {
        // Handle statusEffects immutably if present
        if ('statusEffects' in enemyData && Array.isArray(enemyData.statusEffects)) {
          enemy.statusEffects = [...enemyData.statusEffects];
          // Create a copy without statusEffects to avoid double-applying
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          const { statusEffects: _ignored, ...otherProps } = enemyData;
          // Update other properties
          Object.assign(enemy, otherProps);
        } else {
          // No statusEffects to handle, update normally
          Object.assign(enemy, enemyData);
        }
      }
    }));
  },

  // Legacy movement method - keep for compatibility but mark as deprecated
  sendPlayerMove: (position: { x: number; y: number; z: number }, rotationY: number) => {
    console.warn('sendPlayerMove is deprecated. Use intent-based movement instead.');
    const socket = get().socket;
    if (!socket) {
      console.warn('Cannot send player move: Socket not connected');
      return;
    }
    
    // Throttle outbound messages to reduce network traffic
    const now = performance.now();
    const lastSent = get().lastMoveSentTimeMs || 0;
    
    // Limit to 13Hz (roughly 75ms between updates)
    if (now - lastSent < 75) {
      return;
    }
    
    // Update the last sent timestamp
    set(produce(state => {
      state.lastMoveSentTimeMs = now;
    }));
    
    socket.emit('playerMove', { position, rotationY });
  },

  // New intent-based movement method with the server-authoritative protocol
  sendMoveIntent: (targetPos: VecXZ) => {
    const socket = get().socket;
    const myPlayerId = get().myPlayerId;
    
    if (!socket || !myPlayerId) {
      console.warn('Cannot send move intent: Socket not connected or player ID unknown');
      return;
    }
    
    socket.emit('msg', {
      type: 'MoveIntent',
      id: myPlayerId,
      targetPos: targetPos,
      clientTs: Date.now()
    });
    
  },
  
  sendCastReq: (skillId: string, targetId?: string, targetPos?: VecXZ) => {
    const socket = get().socket;
    const myPlayerId = get().myPlayerId;
    
    if (!socket || !myPlayerId) {
      console.warn('Cannot send cast request: Socket not connected or player ID unknown');
      return;
    }
    
    // Store the skill ID for reconciliation with CastFail responses
    set(produce(state => {
      state.lastCastSkillId = skillId;
    }));
    
    console.log(`Sending CastReq: skill=${skillId}, target=${targetId || 'none'}, player=${myPlayerId}`);
    
    socket.emit('msg', {
      type: 'CastReq',
      id: myPlayerId,
      skillId,
      targetId,
      targetPos,
      clientTs: Date.now()
    });
  },

  sendSelectTarget: (targetId: string | null) => {
    const socket = get().socket;
    if (!socket) {
      console.warn('Cannot select target: Socket not connected');
      return;
    }
    socket.emit('selectTargetRequest', targetId);
    get().selectTarget(targetId);
  },

  // --- Actions ---
  castSkill: (skillId: string) => {
    const state = get();
    if (!state.myPlayerId || !state.selectedTargetId) return;
    
    // Use the new CastReq protocol
    get().sendCastReq(skillId, state.selectedTargetId);
  },

  setActiveSkill: (skillId: string | null) => {
    set(produce(state => {
      state.selectedSkill = skillId;
    }));
  },

  selectTarget: (targetId: string | null) => {
    set(produce(state => {
      if (targetId === null || state.enemies[targetId]) {
        state.selectedTargetId = targetId;
      } else {
        state.selectedTargetId = null;
      }
    }));
  },

  setSelectedSkill: (skillId: string | null) => {
    set(produce(state => {
      state.selectedSkill = skillId;
    }));
  },

  setTargetWorldPos: (pos: { x: number, y: number, z: number } | null) => {
    set(produce(state => {
      state.targetWorldPos = pos;
    }));
  },

  getMyPlayer: () => {
    const state = get();
    return state.myPlayerId ? state.players[state.myPlayerId] : null;
  },

  getSelectedTarget: () => {
    const state = get();
    return state.selectedTargetId ? state.enemies[state.selectedTargetId] : null;
  },

  getStatusEffects: (targetId: string | 'player') => {
    const state = get();
    if (targetId === 'player') {
      const player = state.myPlayerId ? state.players[state.myPlayerId] : null;
      return player?.statusEffects || [];
    }
    const enemy = state.enemies[targetId];
    return enemy?.statusEffects || [];
  },

  getXpMultiplierInfo: () => {
    const state = get();
    const base = 1.0;
    const donation = state.donationXpBoost > 0 && state.donationBoostEndTimeTs !== null && state.donationBoostEndTimeTs > Date.now() ? state.donationXpBoost : 0;
    const event = state.bonusXpEventActive ? 0.5 : 0;
    return { base, donation, event, total: base + donation + event };
  },

  applyDonationBoost: (amount: number, durationMinutes: number) => {
    set(produce(state => {
      state.donationXpBoost = amount;
      state.donationBoostEndTimeTs = Date.now() + (durationMinutes * 60 * 1000);
    }));
  },

  clearDonationBoost: () => {
    set(produce(state => {
      state.donationXpBoost = 0;
      state.donationBoostEndTimeTs = null;
    }));
  },

  toggleXpEvent: () => {
    set(produce(state => {
      state.bonusXpEventActive = !state.bonusXpEventActive;
    }));
  },

  updatePlayerZone: () => {
    // Placeholder to be implemented when zones are added
  },
  
  applySkillEffect: (targetId: string, effects: any[]) => {
    // Get the socket to communicate with the server
    const socket = get().socket;
    if (!socket) return;
    
    // Send the effects to be applied on the server
    socket.emit('applyEffects', { targetId, effects });
    
    console.log('Applying skill effects to target:', targetId, effects);
    
    // For client-side feedback, we could also update the local state
    // This is optional as the server will broadcast the updated state anyway
    const enemy = get().enemies[targetId];
    if (enemy) {
      // For visual feedback only - the server will handle the actual logic
      set(produce(state => {
        const enemy = state.enemies[targetId];
        if (enemy) {
          // You might add a temporary visual effect here
          // This is just for immediate feedback while waiting for the server update
        }
      }));
    }
  },

  setHasJoinedGame: (joined: boolean) => {
    set(produce(state => {
      state.hasJoinedGame = joined;
    }));
  },

}));


// ==============================================================================
// FILE: app/game/systems/interpolation.ts
// ==============================================================================

export interface Snap { pos:{x:number,z:number}; rot:number; vel:{x:number,z:number}; snapTs:number }

// Game runs at 60 fps (~16.7ms per tick)
const MAX_REWIND_MS = 200; // Prevent >200 ms rewinds that cause visible teleports

// Export the ground level for consistent positioning
export const GROUND_Y = 0.5;

import { useRef } from 'react';
import { useFrame } from '@react-three/fiber';

// Module-global SnapBuffer map - one buffer per entity, lives for app lifetime
const bufMap: Record<string, SnapBuffer> = {};
export const getBuffer = (id: string) => bufMap[id] || (bufMap[id] = new SnapBuffer());

/**
 * Hook to continuously sample a player's SnapBuffer in the game loop
 * Returns the latest interpolated position/rotation
 */
export const useInterpolatedPosition = (id: string, interpolationLag = 120) => {
  const bufferRef = useRef<SnapBuffer | null>(null);
  const sampleRef = useRef<{x: number, z: number, rot: number} | null>(null);
  
  // Keep local reference to the buffer from the module-global map
  const buffer = getBuffer(id);
  if (buffer !== bufferRef.current) {
    bufferRef.current = buffer;
  }
  
  // Sample the buffer on every frame
  useFrame(() => {
    if (!bufferRef.current) return;
    
    const renderTs = performance.now() - interpolationLag;
    
    const sample = bufferRef.current.sample(renderTs);
    if (sample) {
      sampleRef.current = sample;
    }
  });
  
  return sampleRef.current;
};

export class SnapBuffer {
  private buf: Snap[] = [];
  private lastSample: {x: number, z: number, rot: number} | null = null;
  
  private clampDepthNow() {
    const now = performance.now();
    while (this.buf.length >= 2 &&
           (now - this.buf[1].snapTs) > MAX_REWIND_MS) {
      this.buf.shift();
    }
  }

  getBufferLength() {
    return this.buf.length;
  }

  debugDump() {
    return [...this.buf];
  }

  clearBuffer() {
    this.buf = [];
    this.lastSample = null;
    console.log("Buffer cleared");
  }

  push(s:Snap){
console.log(`Pushing snap: id=${(s as any).id}, snapTs(clientReceive)=${s.snapTs.toFixed(0)}, serverOriginTs=${(s as any).serverSnapTs || 'N/A'}, pos=...`);
      if (this.buf.length > 0) {
          console.log(`  Current buffer oldestTs=${this.buf[0].snapTs.toFixed(0)}, newestTs=${this.buf[this.buf.length-1].snapTs.toFixed(0)}`);
      }
    try {
      if (s === null || s === undefined || isNaN(s.snapTs)) {
        console.warn("Skipping invalid snap entry:", s);
        return;
      }
      if (isNaN(s.pos.x) || isNaN(s.pos.z) || !isFinite(s.pos.x) || !isFinite(s.pos.z)) {
        console.warn("Invalid position values in snap, skipping:", s);
        return;
      }
      if (s.pos.x === 0 && s.pos.z === 0 && Math.random() < 0.1) {
        console.warn("Received (0,0) position in snap - this may cause movement issues", s);
      }
      if (this.buf.some(existing =>
        existing.snapTs === s.snapTs &&
        existing.pos.x === s.pos.x &&
        existing.pos.z === s.pos.z)) {
        return;
      }

      let insertIndex = this.buf.length;
      for (let i = 0; i < this.buf.length; i++) {
        if (s.snapTs < this.buf[i].snapTs) {
          insertIndex = i;
          break;
        }
      }
      this.buf.splice(insertIndex, 0, s);

      // ... (existing debug logging for large jumps and buffer info can remain)

    } catch (err) {
      console.error("Error in buffer push:", err);
    }

    while (this.buf.length > 60) this.buf.shift();
    this.clampDepthNow();
  }

      sample(renderTs: number) {
        try {
          const bufferLength = this.buf.length;

          if (bufferLength === 0) {
            return this.lastSample || { x: 0, z: 0, rot: 0 };
          }

          const firstSnap = this.buf[0];
          const lastSnap = this.buf[bufferLength - 1];

          // Case 1: renderTs is before or at the oldest snapshot in the buffer
          if (renderTs <= firstSnap.snapTs) {
            this.lastSample = { x: firstSnap.pos.x, z: firstSnap.pos.z, rot: firstSnap.rot };
            return this.lastSample;
          }

          // Case 2: renderTs is after or at the newest snapshot in the buffer (extrapolation)
          if (renderTs >= lastSnap.snapTs) {
            const dt = (renderTs - lastSnap.snapTs) / 1000; // Time delta for extrapolation
            const safeDt = Math.min(Math.max(0, dt), 0.12); // Clamp extrapolation time, ensure non-negative

            const dx = lastSnap.vel.x * safeDt;
            const dz = lastSnap.vel.z * safeDt;
            this.lastSample = {
              x: lastSnap.pos.x + dx,
              z: lastSnap.pos.z + dz,
              rot: lastSnap.rot
            };
            return this.lastSample;
          }

          // Case 3: renderTs is between two snapshots (interpolation)
          let a: Snap = firstSnap;
          let b: Snap = lastSnap;

          // Find a and b: a.snapTs <= renderTs < b.snapTs
          for (let i = 0; i < bufferLength - 1; i++) {
            if (this.buf[i].snapTs <= renderTs && renderTs < this.buf[i + 1].snapTs) {
              a = this.buf[i];
              b = this.buf[i + 1];
              break;
            }
          }
          // If the loop completes and a,b are still first/last, it means renderTs didn't fall
          // strictly between two points but was covered by Case 1 or 2.
          // This explicit search is for clarity. If a == b after this, it implies renderTs matches a snap time.
          // Given Case 1 and 2, this loop should always find a valid a and b if bufferLength > 1.

          const duration = b.snapTs - a.snapTs;
          if (duration <= 0) {
            // This should ideally not happen if snaps are distinct and sorted.
            // If it does, snap to 'a' (the earlier or equal one).
            this.lastSample = { x: a.pos.x, z: a.pos.z, rot: a.rot };
            return this.lastSample;
          }

          const t = (renderTs - a.snapTs) / duration;
          const clampedT = Math.max(0, Math.min(1, t));

          // Optional: Teleport detection logic (currently commented out)
          // const distanceBetweenSnaps = Math.sqrt(Math.pow(b.pos.x - a.pos.x, 2) + Math.pow(b.pos.z - a.pos.z, 2));
          // if (distanceBetweenSnaps > 15 && duration < 500) {
          //   this.lastSample = (clampedT > 0.5) ? { x: b.pos.x, z: b.pos.z, rot: b.rot } : { x: a.pos.x, z: a.pos.z, rot: a.rot };
          //   return this.lastSample;
          // }

          this.lastSample = {
            x: a.pos.x + (b.pos.x - a.pos.x) * clampedT,
            z: a.pos.z + (b.pos.z - a.pos.z) * clampedT,
            rot: lerpAngle(a.rot, b.rot, clampedT)
          };
          return this.lastSample;

        } catch (err) {
          console.error("Error in buffer sample:", err);
          return this.lastSample || { x: 0, z: 0, rot: 0 };
        }
      }
}

/**
 * Lerps between two angles with wrapping around 2PI
 */
function lerpAngle(a:number, b:number, t:number){
  let d = b-a;
  if(d > Math.PI) d -= 2*Math.PI;
  if(d < -Math.PI) d += 2*Math.PI;
  return a + d*t;
}


// ==============================================================================
// FILE: app/game/systems/projectileManager.ts
// ==============================================================================

import { create } from 'zustand';
import { ProjSpawn2, ProjHit2 } from '../../../shared/messages';

// Enhanced projectile live state
export interface ProjectileLive {
  projId: string;
  startPos: {x: number; y: number; z: number};
  dirXZ: {x: number; z: number};
  speed: number;
  launchTs: number;
  hitRadius?: number;
  casterId?: string;
  skillId: string;
  state: 'active' | 'hit';
  fadeOutStartTs?: number;
  opacity: number;
  travelMs?: number; // Travel time in milliseconds for accurate client-side animation
}

interface ProjectileStore {
  enhanced: Record<string, ProjectileLive>; // Map for projectiles
  updateOpacity: () => void;
  
  // Methods for the projectile system
  addEnhancedProjectile: (data: ProjSpawn2) => void;
  handleEnhancedHit: (data: ProjHit2) => void;
}

// Duration of fade-out effect in milliseconds
const FADE_OUT_DURATION_MS = 500; // 500ms for smooth fade-out

export const useProjectileStoreLegacy = create<ProjectileStore>((set) => ({
  enhanced: {}, // Initialize the projectiles map
  
  updateOpacity: () => {
    const now = Date.now();
    
    set(state => {
      const updatedEnhanced: Record<string, ProjectileLive> = {};
      let enhancedChanges = false;
      
      // Process each projectile
      Object.values(state.enhanced).forEach(proj => {
        if (proj.fadeOutStartTs) {
          const elapsedFadeTime = now - proj.fadeOutStartTs;
          
          // If fade complete, don't include in updated list (remove it)
          if (elapsedFadeTime >= FADE_OUT_DURATION_MS) {
            enhancedChanges = true;
            return;
          }
          
          // Calculate new opacity
          const newOpacity = Math.max(0, 1 - (elapsedFadeTime / FADE_OUT_DURATION_MS));
          
          // Only update if opacity changed significantly
          if (Math.abs(newOpacity - proj.opacity) > 0.01) {
            enhancedChanges = true;
            updatedEnhanced[proj.projId] = {
              ...proj,
              opacity: newOpacity
            };
          } else {
            updatedEnhanced[proj.projId] = proj;
          }
        } else {
          // Keep active projectiles
          updatedEnhanced[proj.projId] = proj;
        }
      });
      
      // Only update state if changes occurred
      return enhancedChanges ? { enhanced: updatedEnhanced } : state;
    });
  },
  
  addEnhancedProjectile: (data: ProjSpawn2) => {
    set(state => {
      console.log(`[ProjectileStoreLegacy] Adding enhanced projectile with castId: ${data.castId}, skillId: ${data.skillId}`);
      
      // Check if this castId already exists in the enhanced projectiles
      if (state.enhanced[data.castId]) {
        console.warn(`[ProjectileStoreLegacy] ProjectileID ${data.castId} already exists in enhanced projectiles. Not creating duplicate.`);
        return state; // Return unchanged state to prevent duplicate
      }
      
      return {
        enhanced: {
          ...state.enhanced,
          [data.castId]: {
            projId: data.castId,
            startPos: data.origin,
            dirXZ: data.dir,
            speed: data.speed,
            launchTs: data.launchTs,
            hitRadius: data.hitRadius,
            casterId: data.casterId || 'unknown', // Handle potential undefined casterId
            skillId: data.skillId || 'unknown',  // Handle potential undefined skillId
            state: 'active',
            opacity: 1.0,
            travelMs: data.travelMs // Store the server-provided travel time
          }
        }
      };
    });
  },
  
  handleEnhancedHit: (data: ProjHit2) => {
    // Mark the projectile as hit and start fade-out
    set(state => {
      const projectile = state.enhanced[data.castId];
      if (!projectile) {
        console.warn(`[ProjectileStoreLegacy] No projectile found with castId: ${data.castId} for hit event`);
        return state;
      }
      
      console.log(`[ProjectileStoreLegacy] Marking projectile ${data.castId} as hit`);
      
      return {
        enhanced: {
          ...state.enhanced,
          [data.castId]: {
            ...projectile,
            state: 'hit',
            fadeOutStartTs: Date.now(),
          }
        }
      };
    });
  },
}));

export function initProjectileListeners() {
  // Set up opacity updates using requestAnimationFrame for smoother animations
  let animationFrameId: number;
  
  function updateLoop() {
    useProjectileStoreLegacy.getState().updateOpacity();
    animationFrameId = requestAnimationFrame(updateLoop);
  }
  
  // Start the animation loop
  animationFrameId = requestAnimationFrame(updateLoop);
  
  // Return a cleanup function that can be used if needed
  return () => {
    cancelAnimationFrame(animationFrameId);
  };
}

// Re-export the new projectile store to transition callers
export { useProjectileStore } from './projectileStore';


// ==============================================================================
// FILE: app/game/systems/projectileStore.ts
// ==============================================================================

import { create } from 'zustand';
import { ProjSpawn2, ProjHit2 } from '../../../shared/messages';

// Extended projectile type with hit timestamp
export interface ProjectileData extends ProjSpawn2 {
  hitTs?: number;
  expired?: boolean;
}

type State = { 
  live: Record<string, ProjectileData>;
  // Keep hit projectiles around briefly for VFX cleanup
  toRecycle: Record<string, ProjectileData>;
};

type Actions = {
  add: (p: ProjSpawn2) => void;
  hit: (msg: ProjHit2) => void;
  markExpired: (castId: string) => void;
  clearRecycled: (castId: string) => void;
};

export const useProjectileStore = create<State & Actions>((set) => ({
  live: {},
  toRecycle: {},
  
  add: (p) => set((s) => { 
    console.log(`[ProjectileStore.add] Adding projectile with castId: ${p.castId}, skillId: ${p.skillId}`);
    
    // Special logging for fireball
    if (p.skillId === 'fireball') {
      console.log(`[ProjectileStore.add] Attempting to add Fireball: castId=${p.castId}. Current live count: ${Object.keys(s.live).length}`);
    }
    
    // Check if this castId already exists in live projectiles
    if (s.live[p.castId]) {
      console.warn(`[ProjectileStore.add] Projectile with castId: ${p.castId} already exists in live projectiles. This might cause duplicate visuals.`);
      
      // Special logging for fireball
      if (p.skillId === 'fireball') {
        console.warn(`[ProjectileStore.add] Fireball with castId: ${p.castId} already exists. Not re-adding.`);
      }
      
      // Keep using the same object reference to avoid creating a duplicate visual
      return s;
    }
    
    // Special logging for fireball
    if (p.skillId === 'fireball') {
      console.log(`[ProjectileStore.add] Successfully added Fireball: castId=${p.castId}. New live count: ${Object.keys(s.live).length + 1}`);
    }
    
    return { 
      live: { ...s.live, [p.castId]: p } 
    };
  }),
  
  hit: (h) => set((s) => { 
    console.log(`[ProjectileStore.hit] Received ProjHit2 for castId: ${h.castId}`, h);
    console.log('[ProjectileStore.hit] s.live before:', JSON.stringify(Object.keys(s.live)));
    
    // Get the projectile that was hit
    const projectile = s.live[h.castId];
    
    if (!projectile) {
      console.warn(`[ProjectileStore.hit] Projectile not found in s.live for castId: ${h.castId}`);
      // If projectile is not in live but is in toRecycle, this might be a duplicate hit message
      if (s.toRecycle[h.castId]) {
        console.warn(`[ProjectileStore.hit] Projectile found in s.toRecycle. Possible duplicate hit message.`);
      }
      return s; // No-op if projectile not found
    }
    
    console.log(`[ProjectileStore.hit] Found projectile for castId: ${h.castId}`, projectile);
    
    // Mark with hit timestamp and move to toRecycle
    const hitProjectile = { 
      ...projectile, 
      hitTs: performance.now() 
    };
    
    // Remove from live and add to toRecycle
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { [h.castId]: _, ...restLive } = s.live;
    
    const newState = { 
      live: restLive,
      toRecycle: { ...s.toRecycle, [h.castId]: hitProjectile }
    };
    
    console.log('[ProjectileStore.hit] s.live after:', JSON.stringify(Object.keys(newState.live)));
    console.log('[ProjectileStore.hit] s.toRecycle after:', JSON.stringify(Object.keys(newState.toRecycle)));
    
    return newState; 
  }),
  
  markExpired: (castId) => set((s) => {
    const projectile = s.live[castId];
    if (!projectile) return s;
    
    // Mark as expired and move to toRecycle
    const expiredProjectile = {
      ...projectile,
      expired: true
    };
    
    // Remove from live and add to toRecycle
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { [castId]: _, ...restLive } = s.live;
    
    return {
      live: restLive,
      toRecycle: { ...s.toRecycle, [castId]: expiredProjectile }
    };
  }),
  
  clearRecycled: (castId) => set((s) => {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { [castId]: _, ...restRecycle } = s.toRecycle;
    return { toRecycle: restRecycle };
  })
}));


// ==============================================================================
// FILE: app/game/systems/skillEffects.ts
// ==============================================================================

'use client';

// This is a utility file to help handle skill effects
// It provides a simple implementation of the missing applySkillEffect function

// Function to apply a skill effect to a target
export function applySkillEffect(targetId: string, effects: any[]) {
  // Get the socket from localStorage or another source that doesn't depend on the store
  // This is a workaround to avoid dependencies on the store which could cause cyclic issues
  try {
    // Log the request for debugging
    console.log(`Applying effects to target ${targetId}:`, effects);
    
    // Here we would normally send this to the server
    // For now, just log it and let the server handle the actual effect application
    // through its normal update cycle
    
    // If we had access to the socket, we'd do something like:
    // socket.emit('applyEffect', { targetId, effects });
    
    // Since this is just a utility function, we'll return true to indicate success
    return true;
  } catch (error) {
    console.error('Error applying skill effect:', error);
    return false;
  }
}

const skillEffectsExports = {
  applySkillEffect
};

export default skillEffectsExports;;


// ==============================================================================
// FILE: app/game/systems/skillUtils.ts
// ==============================================================================

'use client';

import { SKILLS, SkillId } from '../models/Skill';

/**
 * Utility functions for skill management that can be used across components
 */

/**
 * Helper function to validate and normalize a skill ID
 * @param skillId - A potential skill ID that needs validation
 * @returns A valid SkillId or null if invalid
 */
export function validateSkillId(skillId: any): SkillId | null {
  if (!skillId) return null;
  
  // If it's already a valid skill ID
  if (typeof skillId === 'string' && SKILLS[skillId as SkillId]) {
    return skillId as SkillId;
  }
  
  // Try to extract from a string that might contain a skill ID
  if (typeof skillId === 'string') {
    // Check if any known skill ID is part of this string
    const possibleMatch = Object.keys(SKILLS).find(id => 
      skillId.includes(id) || id.includes(skillId)
    );
    
    if (possibleMatch) {
      console.log(`Found matching skill: ${possibleMatch} from ${skillId}`);
      return possibleMatch as SkillId;
    }
  }
  
  return null;
}

/**
 * Get the proper skill icon path based on skill ID
 * @param skillId - The ID of the skill
 * @returns Path to the skill icon
 */
function getSkillIconPath(skillId: string) {
  // Special cases
  if (skillId === 'iceBolt') return '/game/skills/skill_icebolt.png';
  if (skillId === 'waterSplash') return '/game/skills/skill_water.png';
  
  // Default case - convert from skill ID to image path
  return `/game/skills/skill_${skillId}.png`;
}

const skillUtils = {
  validateSkillId,
  getSkillIconPath
};

export default skillUtils;


// ==============================================================================
// FILE: app/game/systems/vfxDispatcher.ts
// ==============================================================================

import { Socket } from 'socket.io-client';
import { InstantHit } from '../../../shared/messages';

type Msg = InstantHit;

export function hookVfx(socket:Socket){
  const emit = (name:string, detail:any) =>
    window.dispatchEvent(new CustomEvent(name.toLowerCase(), {detail}));

  socket.on('msg',(m:Msg)=>{
    switch(m.type){
      case 'InstantHit': emit('instanthit', m); break;
    }
  });
}


// ==============================================================================
// FILE: app/game/systems/vfxPool.ts
// ==============================================================================

import { Group } from 'three';
type Pool = { idle: Group[]; factory: () => Group };

const pools: Record<string, Pool> = {};

export function registerPool(
  type: string,
  factory: () => Group,
  warm = 20
) {
  const idle = Array.from({ length: warm }, factory);
  pools[type] = { idle, factory };
}

export function get(type: string): Group {
  const p = pools[type] || (() => { throw new Error(`Pool type '${type}' is not registered`); })();
  
  // Try to find a pooled group that's explicitly marked as invisible
  let pooledGroup: Group | undefined;
  for (let i = 0; i < p.idle.length; i++) {
    if (!p.idle[i].visible) {
      pooledGroup = p.idle.splice(i, 1)[0];
      break;
    }
  }
  
  // If no invisible groups found, create a new one
  const group = pooledGroup || p.idle.pop() || p.factory();
  
  // Ensure the group is visible and properly initialized
  group.visible = true;
  group.position.set(0, 0, 0);
  group.rotation.set(0, 0, 0);
  group.scale.set(1, 1, 1);
  
  console.log(`[vfxPool] Getting ${type} from pool`);
  return group;
}

export function recycle(type: string, inst: Group) {
  console.log(`[vfxPool] Recycling ${type} into pool`);
  
  // Make the group invisible
  inst.visible = false;
  
  // Reset all transformations
  inst.position.set(0, 0, 0);
  inst.rotation.set(0, 0, 0);
  inst.scale.set(1, 1, 1);
  
  // Clear any animations or states
  inst.userData = {};
  
  // Return to pool
  pools[type]?.idle.push(inst);
}


// ==============================================================================
// FILE: app/game/systems/zoneSystem.ts
// ==============================================================================

interface ZoneConfig {
  id: string;
  name: string;
  description: string;
  position: { x: number; y: number; z: number };
  radius: number;
  minLevel: number;
  maxLevel: number;
  mobs: {
    type: string;
    weight: number; // Spawn weight/probability
    minCount: number; // Minimum number of mobs
    maxCount: number; // Maximum number of mobs
  }[];
}

// Define different zones in the game world
export const GAME_ZONES: ZoneConfig[] = [
  {
    id: 'starter_meadow',
    name: 'Peaceful Meadows',
    description: 'A tranquil starting area with gentle slopes and scattered trees',
    position: { x: 0, y: 0, z: 0 },
    radius: 100,
    minLevel: 1,
    maxLevel: 3,
    mobs: [
      { type: 'goblin', weight: 70, minCount: 5, maxCount: 8 },
      { type: 'wolf', weight: 30, minCount: 2, maxCount: 4 }
    ]
  },
  {
    id: 'dark_forest',
    name: 'Dark Forest',
    description: 'A dense forest with challenging enemies',
    position: { x: 200, y: 0, z: 200 },
    radius: 150,
    minLevel: 3,
    maxLevel: 5,
    mobs: [
      { type: 'wolf', weight: 40, minCount: 4, maxCount: 8 },
      { type: 'skeleton', weight: 40, minCount: 4, maxCount: 6 },
      { type: 'orc', weight: 20, minCount: 2, maxCount: 4 }
    ]
  },
  {
    id: 'rocky_highlands',
    name: 'Rocky Highlands',
    description: 'Elevated rocky terrain with strong enemies',
    position: { x: -200, y: 0, z: -200 },
    radius: 120,
    minLevel: 4,
    maxLevel: 7,
    mobs: [
      { type: 'troll', weight: 40, minCount: 3, maxCount: 6 },
      { type: 'orc', weight: 60, minCount: 5, maxCount: 8 }
    ]
  },
  {
    id: 'misty_lake',
    name: 'Misty Lake',
    description: 'A mysterious lake area with unique creatures',
    position: { x: -150, y: 0, z: 250 },
    radius: 100,
    minLevel: 2,
    maxLevel: 4,
    mobs: [
      { type: 'goblin', weight: 50, minCount: 4, maxCount: 7 },
      { type: 'skeleton', weight: 50, minCount: 3, maxCount: 6 }
    ]
  },
  // New high-level zones
  {
    id: 'cursed_ruins',
    name: 'Cursed Ruins',
    description: 'Ancient ruins teeming with undead creatures',
    position: { x: 400, y: 0, z: -100 },
    radius: 130,
    minLevel: 6,
    maxLevel: 9,
    mobs: [
      { type: 'skeleton', weight: 50, minCount: 6, maxCount: 10 },
      { type: 'wraith', weight: 30, minCount: 3, maxCount: 5 },
      { type: 'necromancer', weight: 20, minCount: 1, maxCount: 3 }
    ]
  },
  {
    id: 'dragon_peaks',
    name: 'Dragon Peaks',
    description: 'Treacherous mountain peaks where dragons roam',
    position: { x: -400, y: 0, z: 300 },
    radius: 160,
    minLevel: 8,
    maxLevel: 11,
    mobs: [
      { type: 'wyvern', weight: 40, minCount: 3, maxCount: 5 },
      { type: 'drake', weight: 40, minCount: 4, maxCount: 6 },
      { type: 'dragon', weight: 20, minCount: 1, maxCount: 2 }
    ]
  },
  {
    id: 'shadow_valley',
    name: 'Shadow Valley',
    description: 'A dark valley filled with dangerous shadow creatures',
    position: { x: 300, y: 0, z: 400 },
    radius: 140,
    minLevel: 10,
    maxLevel: 12,
    mobs: [
      { type: 'shadowbeast', weight: 50, minCount: 5, maxCount: 8 },
      { type: 'darkstalker', weight: 30, minCount: 3, maxCount: 5 },
      { type: 'voidwalker', weight: 20, minCount: 2, maxCount: 4 }
    ]
  },
  {
    id: 'crystal_caverns',
    name: 'Crystal Caverns',
    description: 'Mysterious caverns filled with powerful crystal entities',
    position: { x: -300, y: 0, z: -400 },
    radius: 130,
    minLevel: 11,
    maxLevel: 14,
    mobs: [
      { type: 'crystal_golem', weight: 40, minCount: 4, maxCount: 7 },
      { type: 'crystal_elemental', weight: 40, minCount: 3, maxCount: 6 },
      { type: 'crystal_guardian', weight: 20, minCount: 1, maxCount: 3 }
    ]
  }
];

export class ZoneManager {
  private zones: Map<string, {
    config: ZoneConfig;
    currentMobs: {
      id: string;
      type: string;
      level: number;
      position: { x: number; y: number; z: number };
    }[];
  }> = new Map();

  constructor() {
    // Initialize zones
    GAME_ZONES.forEach(zoneConfig => {
      this.zones.set(zoneConfig.id, {
        config: zoneConfig,
        currentMobs: []
      });
    });
  }

  // Get zone by position
  getZoneAtPosition(position: { x: number; y: number; z: number }): ZoneConfig | null {
    for (const zone of GAME_ZONES) {
      const dx = zone.position.x - position.x;
      const dz = zone.position.z - position.z;
      const distanceSquared = dx * dx + dz * dz;
      if (distanceSquared <= zone.radius * zone.radius) {
        return zone;
      }
    }
    return null;
  }

  // Get random position within a zone
  getRandomPositionInZone(zoneId: string): { x: number; y: number; z: number } | null {
    const zone = this.zones.get(zoneId)?.config;
    if (!zone) return null;

    const angle = Math.random() * Math.PI * 2;
    const distance = Math.random() * zone.radius;
    return {
      x: zone.position.x + Math.cos(angle) * distance,
      y: 0,
      z: zone.position.z + Math.sin(angle) * distance
    };
  }

  // Get mobs needed to spawn in a zone
  getMobsToSpawn(zoneId: string): { type: string; count: number }[] {
    const zone = this.zones.get(zoneId);
    if (!zone) return [];

    const currentCounts = new Map<string, number>();
    zone.currentMobs.forEach(mob => {
      currentCounts.set(mob.type, (currentCounts.get(mob.type) || 0) + 1);
    });

    return zone.config.mobs.map(mobConfig => {
      const current = currentCounts.get(mobConfig.type) || 0;
      const needed = Math.max(0, mobConfig.minCount - current);
      return { type: mobConfig.type, count: needed };
    });
  }

  // Update mob counts for a zone
  updateZoneMobs(zoneId: string, mobs: { id: string; type: string; level: number; position: { x: number; y: number; z: number } }[]) {
    const zone = this.zones.get(zoneId);
    if (zone) {
      zone.currentMobs = mobs;
    }
  }

  // Get appropriate level for a mob in a zone
  getMobLevel(zoneId: string): number {
    const zone = this.zones.get(zoneId)?.config;
    if (!zone) return 1;

    return Math.floor(zone.minLevel + Math.random() * (zone.maxLevel - zone.minLevel + 1));
  }

  // Get all zones
  getAllZones(): ZoneConfig[] {
    return GAME_ZONES;
  }
}

export const zoneManager = new ZoneManager();

// ==============================================================================
// FILE: app/game/vfx/FireballProjectile.tsx
// ==============================================================================

import { useRef, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { Vector3, Mesh, Color, Group, MeshBasicMaterial } from 'three';
import useProjectileMovement from './useProjectileMovement';
import useParticleSystem, { Particle } from './useParticleSystem';

interface FireballProjectileProps {
  id?: string;
  origin: {x: number; y: number; z: number};
  dir: {x: number; y: number; z: number};
  speed: number;
  launchTs?: number;
  pooled?: Group;  // Add pooled group prop
  onDone?: () => void; // Add callback for when projectile is done
}

export default function FireballProjectile({ 
  id = `fireball-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`, 
  origin, 
  dir, 
  speed, 
  launchTs = performance.now(),
  pooled, // Use the pooled group passed from VfxManager
  onDone
}: FireballProjectileProps) {
  const coreRef = useRef<Mesh>(null);
  const groupRef = useRef<Group>(null);
  const timeOffset = useRef(Math.random() * Math.PI * 2);
  
  // Use the projectile movement hook for consistent positioning
  const { position } = useProjectileMovement({
    origin,
    dir,
    speed,
    launchTs,
    shouldAutoDestroy: false, // Explicitly false - let VfxManager control lifecycle
  });
  
  // Initialize pooled group on first mount if provided
  useEffect(() => {
    console.log(`[FireballProjectile] Mounted: ${id}`);
    console.log(`[FireballProjectile ${id}] Mounted. Pooled: ${!!pooled}. Origin: ${JSON.stringify(origin)}, Dir: ${JSON.stringify(dir)}, Speed: ${speed}`);
    
    if (!pooled) {
      console.error(`[FireballProjectile ${id}] Pooled group is UNDEFINED!`);
      return;
    }
    
    // Clear any existing children if this is a reused group
    while (pooled.children.length > 0) {
      pooled.remove(pooled.children[0]);
    }
    
    // Create core mesh
    const coreMesh = new Mesh(
      new SphereGeometry(0.25, 16, 16),
      new MeshBasicMaterial({ 
        color: 0xff5500,
        transparent: true,
        opacity: 0.9
      })
    );
    
    // Create outer glow mesh
    const glowMesh = new Mesh(
      new SphereGeometry(0.4, 16, 16),
      new MeshBasicMaterial({
        color: 0xff8800,
        transparent: true,
        opacity: 0.6
      })
    );
    
    // Add meshes to the pooled group
    pooled.add(coreMesh);
    pooled.add(glowMesh);
    
    // Ensure the group is visible
    pooled.visible = true;
    
    // Store references
    coreRef.current = coreMesh;
    
    console.log(`[FireballProjectile ${id}] Pooled group setup complete. Group ID: ${pooled.uuid}, Visible: ${pooled.visible}, Children: ${pooled.children.length}`);
    if (coreRef.current) {
      console.log(`[FireballProjectile ${id}] Core mesh material:`, coreRef.current.material);
    }
    
    return () => {
      console.log(`[FireballProjectile ${id}] Unmounting pooled: ${id}`);
      console.log(`[FireballProjectile ${id}] Unmounting. Pooled group ID: ${pooled?.uuid}`);
      
      if (onDone) {
        // Ensure the group is invisible when unmounted
        pooled.visible = false;
        onDone();
      }
    };
  }, [pooled, onDone, id, origin, dir, speed]); // Added origin, dir, speed for logging initial state
  
  // Setup particle system for fire effects
  const fireParticles = useParticleSystem({
    emitterPosition: () => position,
    emitterShape: 'sphere',
    emitterRadius: 0.2,
    particleLifetime: { min: 0.1, max: 0.5 },
    particleSpeed: { min: 0.5, max: 2 },
    particleSize: { min: 0.05, max: 0.2 },
    particleOpacity: { min: 0.6, max: 1.0 },
    emissionRate: 40,
    maxParticles: 50,
    generateParticle: () => {
      return {
        id: `flame-${id}-${Math.random().toString(36).substring(2, 9)}`,
        position: new Vector3(
          position.x + (Math.random() - 0.5) * 0.3,
          position.y + (Math.random() - 0.5) * 0.3,
          position.z + (Math.random() - 0.5) * 0.3
        ),
        velocity: new Vector3(
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2
        ),
        scale: 0.05 + Math.random() * 0.15,
        opacity: 0.6 + Math.random() * 0.4,
        lifetime: 0,
        maxLifetime: 0.1 + Math.random() * 0.4,
        color: new Color().setHSL(
          0.05 + Math.random() * 0.06, // orange-red hue
          0.7 + Math.random() * 0.3,   // saturation
          0.5 + Math.random() * 0.5    // lightness
        ),
      };
    },
    updateParticle: (particle: Particle, deltaTime: number) => {
      if (particle.lifetime + deltaTime > particle.maxLifetime) {
        return null; // Remove particle
      }
      
      // Update particle
      return {
        ...particle,
        position: new Vector3(
          particle.position.x + particle.velocity.x * deltaTime,
          particle.position.y + particle.velocity.y * deltaTime,
          particle.position.z + particle.velocity.z * deltaTime
        ),
        opacity: particle.opacity * (1 - (particle.lifetime / particle.maxLifetime)),
        lifetime: particle.lifetime + deltaTime
      };
    }
  });
  
  // Add wobble effect to core
  useFrame((state) => {
    if (!coreRef.current) return;
    
    // Log occasionally for fireballs
    if (id.includes('fireball') && Math.random() < 0.1) {
      console.log(`[FireballProjectile ${id}] useFrame. Position: (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)}). Pooled visible: ${pooled?.visible}`);
    }
    
    // Update pooled group position
    if (pooled) {
      pooled.position.set(position.x, position.y, position.z);
      pooled.visible = true; // Explicitly ensure visibility
    }
    
    // Fire core pulsing
    const time = state.clock.elapsedTime;
    const pulseFactor = Math.sin(time * 15 + timeOffset.current) * 0.15 + 1;
    coreRef.current.scale.set(pulseFactor, pulseFactor, pulseFactor);
    
    // Random fire flickering through material opacity
    if (coreRef.current.material instanceof MeshBasicMaterial) {
      const flickerOpacity = 0.8 + Math.sin(time * 20) * 0.2;
      coreRef.current.material.opacity = flickerOpacity;
    }
  });
  
  // If we're using pooled objects, return the primitive
  if (pooled) {
    return <primitive object={pooled} />;
  }
  
  // Legacy rendering path for non-pooled usage
  return (
    <group 
      ref={groupRef} 
      position={[position.x, position.y, position.z]} 
    >
      {/* Main fire core */}
      <mesh key={`core-${id}`} ref={coreRef}>
        <sphereGeometry key={`core-geo-${id}`} args={[0.25, 16, 16]} />
        <meshBasicMaterial 
          key={`core-mat-${id}`}
          color={0xff5500}
          transparent={true}
          opacity={0.9}
        />
      </mesh>
      
      {/* Outer glow */}
      <mesh key={`glow-${id}`}>
        <sphereGeometry key={`glow-geo-${id}`} args={[0.4, 16, 16]} />
        <meshBasicMaterial 
          key={`glow-mat-${id}`}
          color={0xff8800}
          transparent={true}
          opacity={0.6}
        />
      </mesh>
      
      {/* Render fire particles */}
      {fireParticles.particles.map((particle) => (
        <mesh
          key={particle.id}
          position={[particle.position.x, particle.position.y, particle.position.z]}
          scale={[particle.scale, particle.scale, particle.scale]}
        >
          <sphereGeometry args={[1, 8, 8]} />
          <meshBasicMaterial
            color={0xff7700}
            transparent={true}
            opacity={particle.opacity}
          />
        </mesh>
      ))}
    </group>
  );
}

// Import needed THREE types
import { SphereGeometry } from 'three';


// ==============================================================================
// FILE: app/game/vfx/IceBoltProjectile.tsx
// ==============================================================================

import { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import { Vector3, Mesh, Group } from 'three';
import useProjectileMovement from './useProjectileMovement';
import useParticleSystem, { Particle } from './useParticleSystem';

interface IceBoltProjectileProps {
  id: string;
  origin: {x: number; y: number; z: number};
  dir: {x: number; y: number; z: number};
  speed: number;
  launchTs?: number;
}

export function IceBoltProjectile({ 
  id = `icebolt-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`, 
  origin, 
  dir, 
  speed,
  launchTs = performance.now()
}: IceBoltProjectileProps) {
  const coreRef = useRef<Mesh>(null);
  const groupRef = useRef<Group>(null);
  const timeOffset = useRef(Math.random() * Math.PI * 2);
  
  // Use the projectile movement hook for consistent positioning
  const { position } = useProjectileMovement({
    origin,
    dir,
    speed,
    launchTs
  });
  
  // Setup particle system for ice crystal trail
  const iceParticles = useParticleSystem({
    emitterPosition: () => position,
    emitterShape: 'sphere',
    emitterRadius: 0.2,
    particleLifetime: { min: 0.4, max: 0.7 },
    particleSpeed: { min: 0.1, max: 0.5 },
    particleSize: { min: 0.03, max: 0.08 },
    particleOpacity: { min: 0.7, max: 1.0 },
    emissionRate: 15,
    maxParticles: 40,
    generateParticle: () => {
      return {
        id: `ice-${id}-${Math.random().toString(36).substring(2, 9)}`,
        position: new Vector3(
          position.x + (Math.random() - 0.5) * 0.2,
          position.y + (Math.random() - 0.5) * 0.2,
          position.z + (Math.random() - 0.5) * 0.2
        ),
        velocity: new Vector3(
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5
        ),
        scale: 0.03 + Math.random() * 0.08,
        opacity: 0.7 + Math.random() * 0.3,
        lifetime: 0,
        maxLifetime: 0.4 + Math.random() * 0.3,
        rotation: new Vector3(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        ),
        rotationSpeed: new Vector3(
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2
        )
      };
    },
    updateParticle: (particle: Particle, deltaTime: number) => {
      if (particle.lifetime + deltaTime > particle.maxLifetime) {
        return null; // Remove particle
      }
      
      // Update rotation if available
      const rotParticle = particle as Particle & { rotation?: Vector3, rotationSpeed?: Vector3 };
      const newRotation = rotParticle.rotation && rotParticle.rotationSpeed ? new Vector3(
        rotParticle.rotation.x + rotParticle.rotationSpeed.x * deltaTime,
        rotParticle.rotation.y + rotParticle.rotationSpeed.y * deltaTime,
        rotParticle.rotation.z + rotParticle.rotationSpeed.z * deltaTime
      ) : undefined;
      
      // Update particle with fading
      return {
        ...particle,
        rotation: newRotation || rotParticle.rotation,
        opacity: Math.max(0, (particle.maxLifetime - particle.lifetime) / particle.maxLifetime),
        lifetime: particle.lifetime + deltaTime
      };
    }
  });
  
  // Apply animations to the ice projectile core
  useFrame((state, delta) => {
    if (coreRef.current) {
      // Rotate core
      coreRef.current.rotation.x += delta * 2;
      coreRef.current.rotation.z += delta * 3;
      
      // Subtle pulsing
      const pulseFactor = Math.sin(state.clock.elapsedTime * 8 + timeOffset.current) * 0.05 + 1;
      coreRef.current.scale.set(pulseFactor, pulseFactor, pulseFactor);
    }
  });
  
  return (
    <group ref={groupRef} position={[position.x, position.y, position.z]}>
      {/* Main ice core - using an icosahedron for crystalline look */}
      <mesh ref={coreRef}>
        <icosahedronGeometry args={[0.2, 1]} />
        <meshStandardMaterial 
          color="#aad4ff"
          transparent={true}
          opacity={0.7}
          roughness={0.1}
          metalness={0.9}
          emissive="#84b9ff"
          emissiveIntensity={0.5}
        />
      </mesh>
      
      {/* Outer glow */}
      <mesh>
        <sphereGeometry args={[0.35, 16, 16]} />
        <meshBasicMaterial 
          color="#c7e0ff"
          transparent={true}
          opacity={0.3}
        />
      </mesh>
      
      {/* Ice particles - using boxGeometry for crystal-like shards */}
      {iceParticles.particles.map(particle => {
        const rotParticle = particle as Particle & { rotation?: Vector3 };
        const rotation = rotParticle.rotation;
        
        return (
          <mesh
            key={particle.id}
            position={[particle.position.x, particle.position.y, particle.position.z]}
            rotation={rotation ? [rotation.x, rotation.y, rotation.z] : [0, 0, 0]}
            scale={[particle.scale, particle.scale, particle.scale]}
          >
            <boxGeometry args={[0.1, 0.1, 0.1]} />
            <meshStandardMaterial 
              color="#d1e6ff"
              transparent={true}
              opacity={particle.opacity}
              roughness={0.1}
              metalness={0.8}
            />
          </mesh>
        );
      })}
    </group>
  );
}

// Make sure to export both as named and default export for compatibility
export default IceBoltProjectile;


// ==============================================================================
// FILE: app/game/vfx/IceBoltVfx.tsx
// ==============================================================================

'use client';

import { useRef, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { Vector3, Mesh, Color, ConeGeometry, MeshBasicMaterial, Group } from 'three';
import useProjectileMovement from './useProjectileMovement';
import useParticleSystem, { Particle } from './useParticleSystem';

interface IceBoltVfxProps {
  id?: string;
  origin: {x: number; y: number; z: number};
  dir: {x: number; y: number; z: number};
  speed: number;
  launchTs?: number;
  pooled?: Group; // Add pooled group prop
  onDone?: () => void; // Add callback for when projectile is done
}

// Define as a named function first
export function IceBoltVfx({ 
  id = `icebolt-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`, 
  origin, 
  dir, 
  speed,
  launchTs = performance.now(),
  pooled, // Use the pooled group passed from VfxManager
  onDone
}: IceBoltVfxProps) {
  const coreRef = useRef<Mesh>(null);
  const isActive = useRef(true);
  
  // Use the projectile movement hook for consistent positioning
  const { position } = useProjectileMovement({
    origin,
    dir,
    speed,
    launchTs
  });
  
  // Initialize pooled group on first mount if provided
  useEffect(() => {
    if (!pooled) return;
    
    // Clear any existing children if this is a reused group
    while (pooled.children.length > 0) {
      pooled.remove(pooled.children[0]);
    }
    
    // Create core mesh - rotating cone for ice bolt
    const coreMesh = new Mesh(
      new ConeGeometry(0.25, 1),
      new MeshBasicMaterial({ 
        color: "skyblue",
        transparent: true,
        opacity: 0.8
      })
    );
    
    // Set initial rotation
    coreMesh.rotation.set(0, 0, Math.PI / 2);
    
    // Add meshes to the pooled group
    pooled.add(coreMesh);
    
    // Store references
    coreRef.current = coreMesh;
    
    return () => {
      if (isActive.current && onDone) {
        isActive.current = false;
        onDone();
      }
    };
  }, [pooled, onDone]);
  
  // Handle cleanup when projectile is done
  useEffect(() => {
    return () => {
      if (isActive.current && onDone) {
        isActive.current = false;
        onDone();
      }
    };
  }, [onDone]);
  
  // Setup particle system for ice mist effects
  const iceParticles = useParticleSystem({
    emitterPosition: () => position,
    emitterShape: 'sphere',
    emitterRadius: 0.2,
    particleLifetime: { min: 0.1, max: 0.3 },
    particleSpeed: { min: 0.3, max: 1 },
    particleSize: { min: 0.03, max: 0.1 },
    particleOpacity: { min: 0.5, max: 0.8 },
    emissionRate: 25,
    maxParticles: 40,
    generateParticle: () => {
      return {
        id: `icemist-${id}-${Math.random().toString(36).substring(2, 9)}`,
        position: new Vector3(
          position.x + (Math.random() - 0.5) * 0.2,
          position.y + (Math.random() - 0.5) * 0.2,
          position.z + (Math.random() - 0.5) * 0.2
        ),
        velocity: new Vector3(
          (Math.random() - 0.5) * 1,
          (Math.random() - 0.5) * 1,
          (Math.random() - 0.5) * 1
        ),
        scale: 0.03 + Math.random() * 0.07,
        opacity: 0.5 + Math.random() * 0.3,
        lifetime: 0,
        maxLifetime: 0.1 + Math.random() * 0.2,
        color: new Color().setHSL(
          0.58 + Math.random() * 0.05, // cyan-blue hue
          0.5 + Math.random() * 0.3,   // saturation
          0.7 + Math.random() * 0.3    // lightness
        ),
      };
    },
    updateParticle: (particle: Particle, deltaTime: number) => {
      if (particle.lifetime + deltaTime > particle.maxLifetime) {
        return null; // Remove particle
      }
      
      // Update particle
      return {
        ...particle,
        opacity: particle.opacity * (1 - (particle.lifetime / particle.maxLifetime)),
        lifetime: particle.lifetime + deltaTime
      };
    }
  });
  
  // Add some rotation to the ice bolt and update pooled group
  useFrame((state) => {
    if (coreRef.current) {
      coreRef.current.rotation.z = state.clock.elapsedTime * 5;
    }
    
    // Update pooled group position
    if (pooled) {
      pooled.position.set(position.x, position.y, position.z);
      pooled.visible = true;
    }
  });
  
  // If we're using pooled objects, return the primitive
  if (pooled) {
    return <primitive object={pooled} />;
  }
  
  // Legacy rendering path for non-pooled usage
  return (
    <group position={[position.x, position.y, position.z]}>
      {/* Main ice bolt */}
      <mesh ref={coreRef} rotation={[0, 0, Math.PI / 2]}>
        <coneGeometry key={`icebolt-geo-${id}`} args={[0.25, 1]} />
        <meshBasicMaterial key={`icebolt-mat-${id}`} color="skyblue" transparent opacity={0.8} />
      </mesh>
      
      {/* Render ice mist particles */}
      {iceParticles.particles.map(particle => (
        <mesh
          key={particle.id}
          position={[particle.position.x, particle.position.y, particle.position.z]}
          scale={[particle.scale, particle.scale, particle.scale]}
        >
          <sphereGeometry args={[1, 8, 8]} />
          <meshBasicMaterial
            color="aliceblue"
            transparent
            opacity={particle.opacity}
          />
        </mesh>
      ))}
    </group>
  );
}

// Also export as default
export default IceBoltVfx;


// ==============================================================================
// FILE: app/game/vfx/PetrifyFlash.tsx
// ==============================================================================

'use client';

import { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import { Vector3, Mesh } from 'three';
import useParticleSystem, { Particle } from './useParticleSystem';

interface PetrifyFlashProps {
  position: {x: number; y: number; z: number};
}

// Export as named export
export function PetrifyFlash({ position }: PetrifyFlashProps) {
  const coreRef = useRef<Mesh>(null);
  const positionVector = useRef(new Vector3(position.x, position.y + 1, position.z));
  
  // Setup particle system for petrify flash
  const glowParticles = useParticleSystem({
    emitterPosition: positionVector.current,
    emitterShape: 'sphere',
    emitterRadius: 0.3,
    particleLifetime: { min: 0.3, max: 0.5 },
    particleSpeed: { min: 0.5, max: 2 },
    particleSize: { min: 0.1, max: 0.3 },
    particleOpacity: { min: 0.6, max: 1.0 },
    emissionRate: 25,
    maxParticles: 30,
    generateParticle: () => {
      return {
        id: `petrify-${Math.random().toString(36).substring(2, 9)}`,
        position: new Vector3(
          positionVector.current.x + (Math.random() - 0.5) * 0.5,
          positionVector.current.y + (Math.random() - 0.5) * 0.5,
          positionVector.current.z + (Math.random() - 0.5) * 0.5
        ),
        velocity: new Vector3(
          (Math.random() - 0.5) * 3,
          (Math.random() - 0.5) * 3,
          (Math.random() - 0.5) * 3
        ),
        scale: 0.1 + Math.random() * 0.2,
        opacity: 0.7 + Math.random() * 0.3,
        lifetime: 0,
        maxLifetime: 0.3 + Math.random() * 0.2,
      };
    },
    updateParticle: (particle: Particle, deltaTime: number) => {
      if (particle.lifetime + deltaTime > particle.maxLifetime) {
        return null; // Remove particle
      }
      
      return {
        ...particle,
        opacity: Math.max(0, (particle.maxLifetime - particle.lifetime) / particle.maxLifetime * 0.8),
        scale: particle.scale * 0.95, // Shrink over time
        lifetime: particle.lifetime + deltaTime
      };
    }
  });
  
  // Emit particles on first render
  useFrame((_, delta) => {
    // Pulse the core flash
    if (coreRef.current) {
      const pulseScale = Math.min(2, coreRef.current.scale.x + 5 * delta);
      coreRef.current.scale.set(pulseScale, pulseScale, pulseScale);
      
      // Get material and update opacity
      const material = coreRef.current.material as any;
      if (material && material.opacity) {
        material.opacity = 1 - pulseScale / 2;
      }
      
      // Reset when fully expanded
      if (pulseScale >= 2) {
        coreRef.current.scale.set(0, 0, 0);
      }
    }
  });
  
  return (
    <group>
      {/* Core flash */}
      <mesh ref={coreRef} position={[positionVector.current.x, positionVector.current.y, positionVector.current.z]}>
        <icosahedronGeometry args={[0.5, 1]} />
        <meshBasicMaterial color="yellow" transparent opacity={1} />
      </mesh>
      
      {/* Glow particles */}
      {glowParticles.particles.map(particle => (
        <mesh
          key={particle.id}
          position={[particle.position.x, particle.position.y, particle.position.z]}
          scale={[particle.scale, particle.scale, particle.scale]}
        >
          <sphereGeometry args={[1, 8, 8]} />
          <meshBasicMaterial
            color="yellow"
            transparent
            opacity={particle.opacity}
          />
        </mesh>
      ))}
    </group>
  );
}

// Also export as default for consistency
export default PetrifyFlash;


// ==============================================================================
// FILE: app/game/vfx/ProjectileVfx.tsx
// ==============================================================================

import { useFrame } from '@react-three/fiber';
import { useRef, useState, useEffect } from 'react';
import { Vector3, Mesh, MathUtils, Color, Group, Material, SphereGeometry, MeshStandardMaterial, PointLight } from 'three';
import { useProjectileStoreLegacy } from '../systems/projectileManager';
import useProjectileMovement from './useProjectileMovement';
import useParticleSystem, { Particle } from './useParticleSystem';

interface ProjectileVfxProps {
  id?: string;
  origin: {x: number; y: number; z: number};
  dir: {x: number; y: number; z: number};
  speed: number;
  launchTs?: number;
  pooled?: Group; // Add pooled group prop
  onDone?: () => void; // Add callback for when projectile is done
}

export default function ProjectileVfx({
  id = `proj-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`, 
  origin, 
  dir, 
  speed, 
  launchTs = performance.now(),
  pooled, // Use the pooled group passed from VfxManager
  onDone
}: ProjectileVfxProps) {
  const ref = useRef<Mesh>(null);
  const groupRef = useRef<Group>(null);
  const timeOffset = useRef(Math.random() * Math.PI * 2);
  const [intensity, setIntensity] = useState(2);
  const isActive = useRef(true);
  
  // Get projectile opacity from store
  const projectileState = useProjectileStoreLegacy(state => state.enhanced[id]);
  const opacity = projectileState?.opacity ?? 1.0;
  const isFadingOut = projectileState?.fadeOutStartTs !== undefined;
  
  // Initialize pooled group on first mount if provided
  useEffect(() => {
    if (!pooled) return;
    
    // Clear any existing children if this is a reused group
    while (pooled.children.length > 0) {
      pooled.remove(pooled.children[0]);
    }
    
    // Create main projectile sphere
    const coreMesh = new Mesh(
      new SphereGeometry(0.25, 16, 16),
      new MeshStandardMaterial({ 
        color: "orange",
        emissive: "orange",
        emissiveIntensity: 2,
        transparent: true,
        opacity: 1.0
      })
    );
    
    // Add light
    const light = new PointLight("orange", 2, 3);
    
    // Add meshes to the pooled group
    pooled.add(coreMesh);
    pooled.add(light);
    
    // Store references
    ref.current = coreMesh;
    
    return () => {
      if (isActive.current && onDone) {
        isActive.current = false;
        onDone();
      }
    };
  }, [pooled, onDone]);
  
  // Handle cleanup when projectile is done
  useEffect(() => {
    return () => {
      if (isActive.current && onDone) {
        isActive.current = false;
        onDone();
      }
    };
  }, [onDone]);
  
  // Use the projectile movement hook for consistent positioning
  const { position} = useProjectileMovement({
    origin,
    dir,
    speed,
    launchTs,
    shouldAutoDestroy: false, // Let the VfxManager handle destruction
  });
  
  // Setup particle system for trail effects
  const trailParticles = useParticleSystem({
    emitterPosition: () => position,
    emitterShape: 'sphere',
    emitterRadius: 0.1,
    particleLifetime: { min: 0.4, max: 0.6 },
    particleSpeed: { min: 0.1, max: 0.5 },
    particleSize: { min: 0.1, max: 0.2 },
    particleOpacity: { min: 0.6, max: 0.8 },
    emissionRate: isFadingOut ? 5 : 15, // Reduce emission when fading out
    maxParticles: 40,
    generateParticle: () => {
      return {
        id: `trail-${id}-${Math.random().toString(36).substring(2, 9)}`,
        position: new Vector3(
          position.x + (Math.random() - 0.5) * 0.2,
          position.y + (Math.random() - 0.5) * 0.2,
          position.z + (Math.random() - 0.5) * 0.2
        ),
        velocity: new Vector3(
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5
        ),
        scale: 0.1 + Math.random() * 0.1,
        opacity: 0.6 * opacity, // Adjust for projectile opacity
        lifetime: 0,
        maxLifetime: 0.4 + Math.random() * 0.2,
        color: new Color(0xff8c00),
        rotation: new Vector3(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        ),
        rotationSpeed: new Vector3(
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2
        ),
      };
    },
    updateParticle: (particle: Particle, deltaTime: number) => {
      if (particle.lifetime + deltaTime > particle.maxLifetime) {
        return null; // Remove particle
      }
      
      // Update rotation if available
      const rotParticle = particle as Particle & { rotation?: Vector3, rotationSpeed?: Vector3 };
      const newRotation = rotParticle.rotation && rotParticle.rotationSpeed ? new Vector3(
        rotParticle.rotation.x + rotParticle.rotationSpeed.x * deltaTime,
        rotParticle.rotation.y + rotParticle.rotationSpeed.y * deltaTime,
        rotParticle.rotation.z + rotParticle.rotationSpeed.z * deltaTime
      ) : undefined;
      
      // Update particle with fading
      return {
        ...particle,
        rotation: newRotation || rotParticle.rotation,
        opacity: Math.max(0, (particle.maxLifetime - particle.lifetime) / particle.maxLifetime) * opacity,
        scale: particle.scale * 0.98, // Shrink over time
        lifetime: particle.lifetime + deltaTime
      };
    }
  });
  
  useFrame((state) => {
    if (!ref.current) return;
    
    // Update pooled group position if available
    if (pooled) {
      pooled.position.set(position.x, position.y, position.z);
      pooled.visible = true;
      
      // Update material opacity for all child meshes
      pooled.children.forEach(child => {
        if (child instanceof Mesh && child.material instanceof Material) {
          (child.material as any).opacity = opacity;
        }
        if (child instanceof PointLight) {
          child.intensity = 2 * opacity + Math.sin(state.clock.elapsedTime * 10 + timeOffset.current) * 0.5 * opacity;
        }
      });
      
      // Add wobble effect
      if (pooled.children[0] instanceof Mesh) {
        const pulseFactor = MathUtils.lerp(0.9, 1.1, Math.sin(state.clock.elapsedTime * 8 + timeOffset.current));
        pooled.children[0].scale.set(pulseFactor, pulseFactor, pulseFactor);
      }
      
      // Add random movement
      pooled.position.x += Math.sin(state.clock.elapsedTime * 15) * 0.015;
      pooled.position.y += Math.cos(state.clock.elapsedTime * 12) * 0.015;
    }
    
    // Update material opacity
    if (ref.current.material instanceof Material) {
      (ref.current.material as any).opacity = opacity;
    }
    
    // Make the projectile pulsate
    const pulseFactor = MathUtils.lerp(0.9, 1.1, Math.sin(state.clock.elapsedTime * 8 + timeOffset.current));
    ref.current.scale.set(pulseFactor, pulseFactor, pulseFactor);
    
    // Random wobble movement
    if (groupRef.current) {
      groupRef.current.position.x += Math.sin(state.clock.elapsedTime * 15) * 0.015;
      groupRef.current.position.y += Math.cos(state.clock.elapsedTime * 12) * 0.015;
    }
    
    // Varying light intensity (reduced when fading out)
    const baseIntensity = 2 * opacity;
    const newIntensity = baseIntensity + Math.sin(state.clock.elapsedTime * 10 + timeOffset.current) * 0.5 * opacity;
    setIntensity(newIntensity);
  });
  
  return (
    <>
      {/* If we're using pooled objects, return the primitive */}
      {pooled ? (
        <primitive object={pooled} />
      ) : (
        <group ref={groupRef} position={[position.x, position.y, position.z]}>
          {/* Main projectile */}
          <mesh ref={ref}>
            <sphereGeometry key={`proj-geo-${id}`} args={[0.25, 16, 16]} />
            <meshStandardMaterial 
              key={`proj-mat-${id}`}
              color="orange"
              emissive="orange"
              emissiveIntensity={intensity}
              transparent={true}
              opacity={opacity}
            />
            
            {/* Add glow effect */}
            <pointLight 
              key={`proj-light-${id}`}
              color="orange"
              intensity={intensity} 
              distance={3} 
            />
          </mesh>
          
          {/* Trail particles */}
          {trailParticles.particles.map(particle => {
            const rotParticle = particle as Particle & { rotation?: Vector3 };
            const rotation = rotParticle.rotation;
            
            return (
              <mesh
                key={particle.id}
                position={[particle.position.x, particle.position.y, particle.position.z]}
                rotation={rotation ? [rotation.x, rotation.y, rotation.z] : [0, 0, 0]}
                scale={[particle.scale, particle.scale, particle.scale]}
              >
                <sphereGeometry args={[1, 8, 8]} />
                <meshBasicMaterial 
                  color="#ff8c00"
                  transparent={true} 
                  opacity={particle.opacity} 
                />
              </mesh>
            );
          })}
        </group>
      )}
    </>
  );
}


// ==============================================================================
// FILE: app/game/vfx/SplashVfx.tsx
// ==============================================================================

import React, { useEffect, useRef, useState, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import { Color, Mesh, Material, Vector3, MathUtils } from 'three';

interface SplashVfxProps {
  position: {x: number; y: number; z: number};
  radius: number;
}

interface WaterParticle {
  position: Vector3;
  initialY: number;
  velocity: Vector3;
  scale: number;
  opacity: number;
  color: Color;
  rotation: Vector3;
  rotationSpeed: Vector3;
  stretching: number;
}

interface MistParticle {
  position: Vector3;
  scale: number;
  opacity: number;
  velocity: Vector3;
  lifetimeMs: number;
  maxLifetimeMs: number;
}

export default function SplashVfx({ position, radius }: SplashVfxProps) {
  const ringRef = useRef<Mesh>(null);
  const [lifetime, setLifetime] = useState(1.0); // 1 second lifetime

  // Generate water droplet particles
  const particles = useMemo(() => {
    const particleCount = 10 + Math.floor(radius * 5); // Scale particles with radius
    return Array.from({ length: particleCount }, () => ({
      position: new Vector3(
        position.x + (Math.random() - 0.5) * radius * 0.6,
        position.y + Math.random() * 0.5,
        position.z + (Math.random() - 0.5) * radius * 0.6
      ),
      initialY: position.y,
      velocity: new Vector3(
        (Math.random() - 0.5) * 10,
        Math.random() * 8 + 6,
        (Math.random() - 0.5) * 10
      ),
      scale: 0.1 + Math.random() * 0.25,
      opacity: 1.0,
      color: new Color().setHSL(0.58 + Math.random() * 0.05, 0.8, 0.5 + Math.random() * 0.2),
      rotation: new Vector3(),
      rotationSpeed: new Vector3(
        Math.random() * 5, 
        Math.random() * 5, 
        Math.random() * 5
      ),
      stretching: 1.0
    }));
  }, [position, radius]);
  
  // State for tracking particles
  const [waterParticles, setWaterParticles] = useState<WaterParticle[]>(particles);
  const mistParticlesRef = useRef<MistParticle[]>([]);
  
  // Create initial mist particles
  useEffect(() => {
    // Clear existing mist particles to prevent duplicates
    mistParticlesRef.current = [];
    
    // Create mist particles
    const mistCount = Math.floor(10 * (radius / 3));
    
    for (let i = 0; i < mistCount; i++) {
      const angle = Math.random() * Math.PI * 2;
      const distance = (0.3 + Math.random() * 0.7) * radius;
      const maxLifetimeMs = 500 + Math.random() * 800;
      
      mistParticlesRef.current.push({
        position: new Vector3(
          position.x + Math.cos(angle) * distance * 0.7,
          position.y + Math.random() * 0.5,
          position.z + Math.sin(angle) * distance * 0.7
        ),
        scale: 0.3 + Math.random() * 0.4,
        opacity: 0.4 + Math.random() * 0.3,
        velocity: new Vector3(
          Math.cos(angle) * (0.5 + Math.random()),
          0.7 + Math.random() * 0.5,
          Math.sin(angle) * (0.5 + Math.random())
        ),
        lifetimeMs: maxLifetimeMs,
        maxLifetimeMs
      });
    }
  }, [position, radius]);
  
  useFrame((_, delta) => {
    if (!ringRef.current) return;
    
    // Shrink lifetime
    setLifetime(prev => Math.max(0, prev - delta));
    
    // Scale up the ring
    const progress = 1 - lifetime;
    ringRef.current.scale.x = radius * progress;
    ringRef.current.scale.z = radius * progress;
    
    // Fade out
    if (ringRef.current.material instanceof Material) {
      ringRef.current.material.opacity = lifetime;
    }
    
    // Update water particles
    setWaterParticles(prevParticles => 
      prevParticles.map(particle => {
        // Apply gravity
        particle.velocity.y -= 15 * delta;
        
        // Update position
        particle.position.x += particle.velocity.x * delta;
        particle.position.y += particle.velocity.y * delta;
        particle.position.z += particle.velocity.z * delta;
        
        // Handle bouncing
        if (particle.position.y < particle.initialY && particle.velocity.y < 0) {
          particle.velocity.y = -particle.velocity.y * 0.4;
          particle.velocity.x *= 0.8;
          particle.velocity.z *= 0.8;
          particle.position.y = particle.initialY + 0.05;
          
          // Reduce opacity on bounce
          particle.opacity *= 0.7;
        }
        
        // Update rotation
        particle.rotation.x += particle.rotationSpeed.x * delta;
        particle.rotation.y += particle.rotationSpeed.y * delta;
        particle.rotation.z += particle.rotationSpeed.z * delta;
        
        // Fade out over time
        particle.opacity = Math.max(0, particle.opacity - 0.5 * delta);
        
        return particle;
      }).filter(p => p.opacity > 0.1)
    );
    
    // Update mist particles
    const mistParticles = mistParticlesRef.current;
    for (let i = mistParticles.length - 1; i >= 0; i--) {
      const particle = mistParticles[i];
      
      // Update lifetime
      particle.lifetimeMs -= delta * 1000;
      
      // Update position
      particle.position.x += particle.velocity.x * delta * 0.5;
      particle.position.y += particle.velocity.y * delta * 0.5;
      particle.position.z += particle.velocity.z * delta * 0.5;
      
      // Fade out particles
      particle.opacity = MathUtils.lerp(0, 0.7, particle.lifetimeMs / particle.maxLifetimeMs);
      
      // Remove dead particles
      if (particle.lifetimeMs <= 0) {
        mistParticles.splice(i, 1);
      }
    }
  });
  
  // Remove when lifetime is over and all particles are gone
  if (lifetime <= 0 && waterParticles.length === 0 && mistParticlesRef.current.length === 0) return null;
  
  return (
    <group>
      {/* Main ring */}
      <mesh 
        ref={ringRef} 
        position={[position.x, position.y + 0.05, position.z]} // Slightly above ground
        rotation={[Math.PI / 2, 0, 0]} // Flat on ground
      >
        <ringGeometry args={[radius * 0.8, radius, 32]} />
        <meshBasicMaterial color={new Color(0x00a0ff)} transparent={true} opacity={1} />
      </mesh>
      
      {/* Water particles */}
      {waterParticles.map((particle, index) => (
        <mesh
          key={`water-${index}`}
          position={[particle.position.x, particle.position.y, particle.position.z]}
          rotation={[particle.rotation.x, particle.rotation.y, particle.rotation.z]}
          scale={[particle.scale, particle.scale * particle.stretching, particle.scale]}
        >
          <sphereGeometry args={[0.12, 8, 8]} />
          <meshBasicMaterial 
            color={particle.color} 
            transparent={true} 
            opacity={particle.opacity}
          />
        </mesh>
      ))}
      
      {/* Mist particles */}
      {mistParticlesRef.current.map((particle, index) => (
        <mesh
          key={`mist-${index}`}
          position={[particle.position.x, particle.position.y, particle.position.z]}
        >
          <sphereGeometry args={[0.15, 8, 8]} />
          <meshBasicMaterial
            color={new Color(0x88ccff)}
            transparent={true}
            opacity={particle.opacity}
          />
        </mesh>
      ))}
    </group>
  );
}

// Helper functions for spawning visual effects
export function spawnSplashVfx(position: {x: number; y: number; z: number}, radius: number, type?: string) {
  window.dispatchEvent(
    new CustomEvent('spawnSplash', { 
      detail: { 
        position, 
        radius,
        effectType: type || 'water'
      } 
    })
  );
}

export function spawnStunFlash(position: {x: number; y: number; z: number}) {
  window.dispatchEvent(
    new CustomEvent('spawnStunFlash', { detail: { position } })
  );
}

// Create a FireSplash component for fire effects
export function FireSplash({ position, radius }: SplashVfxProps) {
  const ringRef = useRef<Mesh>(null);
  const [lifetime, setLifetime] = useState(1.0);
  
  // Generate fire particles
  const particles = useMemo(() => {
    const particleCount = 10 + Math.floor(radius * 5);
    return Array.from({ length: particleCount }, () => ({
      position: new Vector3(
        position.x + (Math.random() - 0.5) * radius * 0.6,
        position.y + Math.random() * 0.5,
        position.z + (Math.random() - 0.5) * radius * 0.6
      ),
      initialY: position.y,
      velocity: new Vector3(
        (Math.random() - 0.5) * 10,
        Math.random() * 10 + 4, // Stronger upward motion
        (Math.random() - 0.5) * 10
      ),
      scale: 0.1 + Math.random() * 0.25,
      opacity: 1.0,
      color: new Color().setHSL(
        0.05 + Math.random() * 0.06, // Orange-red hue
        0.7 + Math.random() * 0.3,   // Saturation
        0.5 + Math.random() * 0.5    // Lightness
      ),
      rotation: new Vector3(),
      rotationSpeed: new Vector3(
        Math.random() * 5, 
        Math.random() * 5, 
        Math.random() * 5
      ),
      stretching: 1.5 // More stretching for fire particles
    }));
  }, [position, radius]);
  
  const [fireParticles, setFireParticles] = useState<WaterParticle[]>(particles);
  
  useFrame((_, delta) => {
    if (!ringRef.current) return;
    
    // Shrink lifetime
    setLifetime(prev => Math.max(0, prev - delta));
    
    // Scale up the ring
    const progress = 1 - lifetime;
    ringRef.current.scale.x = radius * progress;
    ringRef.current.scale.z = radius * progress;
    
    // Fire-specific fading
    if (ringRef.current.material instanceof Material) {
      ringRef.current.material.opacity = lifetime * 0.8;
    }
    
    // Update fire particles
    setFireParticles(prevParticles => 
      prevParticles.map(particle => {
        // Apply upward force (opposite of gravity for fire)
        particle.velocity.y += 2 * delta;
        
        // Update position
        particle.position.x += particle.velocity.x * delta;
        particle.position.y += particle.velocity.y * delta;
        particle.position.z += particle.velocity.z * delta;
        
        // Update rotation
        particle.rotation.x += particle.rotationSpeed.x * delta;
        particle.rotation.y += particle.rotationSpeed.y * delta;
        particle.rotation.z += particle.rotationSpeed.z * delta;
        
        // Fade out over time (faster for fire)
        particle.opacity = Math.max(0, particle.opacity - 0.8 * delta);
        
        return particle;
      }).filter(p => p.opacity > 0.1)
    );
  });
  
  // Remove when lifetime is over and all particles are gone
  if (lifetime <= 0 && fireParticles.length === 0) return null;
  
  return (
    <group>
      {/* Fire ring */}
      <mesh 
        ref={ringRef} 
        position={[position.x, position.y + 0.05, position.z]}
        rotation={[Math.PI / 2, 0, 0]}
      >
        <ringGeometry args={[radius * 0.8, radius, 32]} />
        <meshBasicMaterial color={new Color(0xff5500)} transparent={true} opacity={1} />
      </mesh>
      
      {/* Fire particles */}
      {fireParticles.map((particle, index) => (
        <mesh
          key={`fire-${index}`}
          position={[particle.position.x, particle.position.y, particle.position.z]}
          rotation={[particle.rotation.x, particle.rotation.y, particle.rotation.z]}
          scale={[particle.scale, particle.scale * particle.stretching, particle.scale]}
        >
          <sphereGeometry args={[0.12, 8, 8]} />
          <meshBasicMaterial 
            color={particle.color} 
            transparent={true} 
            opacity={particle.opacity}
          />
        </mesh>
      ))}
    </group>
  );
}

// Create an IceSplash component for ice effects
export function IceSplash({ position, radius }: SplashVfxProps) {
  const ringRef = useRef<Mesh>(null);
  const [lifetime, setLifetime] = useState(1.0);
  
  // Generate ice shard particles
  const particles = useMemo(() => {
    const particleCount = 10 + Math.floor(radius * 4);
    return Array.from({ length: particleCount }, () => ({
      position: new Vector3(
        position.x + (Math.random() - 0.5) * radius * 0.8,
        position.y + Math.random() * 0.3,
        position.z + (Math.random() - 0.5) * radius * 0.8
      ),
      initialY: position.y,
      velocity: new Vector3(
        (Math.random() - 0.5) * 12, // More horizontal spread
        Math.random() * 6 + 2,
        (Math.random() - 0.5) * 12  // More horizontal spread
      ),
      scale: 0.1 + Math.random() * 0.2,
      opacity: 0.8,
      color: new Color(0xaad4ff), // Ice blue color
      rotation: new Vector3(),
      rotationSpeed: new Vector3(
        Math.random() * 5, 
        Math.random() * 5, 
        Math.random() * 5
      ),
      stretching: 0.7 // Less stretching for ice crystals
    }));
  }, [position, radius]);
  
  const [iceParticles, setIceParticles] = useState<WaterParticle[]>(particles);
  
  useFrame((_, delta) => {
    if (!ringRef.current) return;
    
    // Shrink lifetime
    setLifetime(prev => Math.max(0, prev - delta));
    
    // Scale up the ring
    const progress = 1 - lifetime;
    ringRef.current.scale.x = radius * progress;
    ringRef.current.scale.z = radius * progress;
    
    // Ice-specific fading
    if (ringRef.current.material instanceof Material) {
      ringRef.current.material.opacity = lifetime * 0.9;
    }
    
    // Update ice particles
    setIceParticles(prevParticles => 
      prevParticles.map(particle => {
        // Apply gravity
        particle.velocity.y -= 12 * delta;
        
        // Update position
        particle.position.x += particle.velocity.x * delta;
        particle.position.y += particle.velocity.y * delta;
        particle.position.z += particle.velocity.z * delta;
        
        // Handle bouncing
        if (particle.position.y < particle.initialY && particle.velocity.y < 0) {
          particle.velocity.y = -particle.velocity.y * 0.2; // Less bouncy
          particle.velocity.x *= 0.8;
          particle.velocity.z *= 0.8;
          particle.position.y = particle.initialY + 0.05;
          
          // Reduce opacity on bounce (shatter effect)
          particle.opacity *= 0.5;
        }
        
        // Update rotation
        particle.rotation.x += particle.rotationSpeed.x * delta;
        particle.rotation.y += particle.rotationSpeed.y * delta;
        particle.rotation.z += particle.rotationSpeed.z * delta;
        
        // Fade out over time
        particle.opacity = Math.max(0, particle.opacity - 0.6 * delta);
        
        return particle;
      }).filter(p => p.opacity > 0.1)
    );
  });
  
  // Remove when lifetime is over and all particles are gone
  if (lifetime <= 0 && iceParticles.length === 0) return null;
  
  return (
    <group>
      {/* Ice ring */}
      <mesh 
        ref={ringRef} 
        position={[position.x, position.y + 0.05, position.z]}
        rotation={[Math.PI / 2, 0, 0]}
      >
        <ringGeometry args={[radius * 0.8, radius, 32]} />
        <meshBasicMaterial color={new Color(0xb3e0ff)} transparent={true} opacity={1} />
      </mesh>
      
      {/* Ice particles */}
      {iceParticles.map((particle, index) => (
        <mesh
          key={`ice-${index}-${Math.random().toString(36).substring(2, 9)}`}
          position={[particle.position.x, particle.position.y, particle.position.z]}
          rotation={[particle.rotation.x, particle.rotation.y, particle.rotation.z]}
          scale={[particle.scale, particle.scale * particle.stretching, particle.scale]}
        >
          <boxGeometry args={[0.15, 0.15, 0.15]} /> {/* Use box for crystal-like shards */}
          <meshBasicMaterial 
            color={particle.color} 
            transparent={true} 
            opacity={particle.opacity}
          />
        </mesh>
      ))}
    </group>
  );
}


// ==============================================================================
// FILE: app/game/vfx/WaterProjectile.tsx
// ==============================================================================

import { useRef, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { Vector3, Mesh, Color, Group, SphereGeometry, MeshStandardMaterial } from 'three';
import useProjectileMovement from './useProjectileMovement';
import useParticleSystem, { Particle } from './useParticleSystem';

interface WaterProjectileProps {
  id?: string;
  origin: {x: number; y: number; z: number};
  dir: {x: number; y: number; z: number};
  speed: number;
  launchTs?: number;
  pooled?: Group; // Add pooled group prop
  onDone?: () => void; // Add callback for when projectile is done
}

export default function WaterProjectile({ 
  id = `water-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`, 
  origin, 
  dir, 
  speed, 
  launchTs = performance.now(),
  pooled, // Use the pooled group passed from VfxManager
  onDone
}: WaterProjectileProps) {
  const mainRef = useRef<Mesh>(null);
  const groupRef = useRef<Group>(null);
  const timeOffset = useRef(Math.random() * Math.PI * 2);
  const isActive = useRef(true);
  
  // Use the projectile movement hook for consistent positioning
  const { position } = useProjectileMovement({
    origin,
    dir,
    speed,
    launchTs
  });
  
  // Initialize pooled group on first mount if provided
  useEffect(() => {
    if (!pooled) return;
    
    // Clear any existing children if this is a reused group
    while (pooled.children.length > 0) {
      pooled.remove(pooled.children[0]);
    }
    
    // Create main water ball
    const mainMesh = new Mesh(
      new SphereGeometry(0.4, 16, 16),
      new MeshStandardMaterial({ 
        color: "#57c1eb",
        transparent: true,
        opacity: 0.7,
        roughness: 0.2,
        metalness: 0.7
      })
    );
    
    // Add meshes to the pooled group
    pooled.add(mainMesh);
    
    // Store references
    mainRef.current = mainMesh;
    
    return () => {
      if (isActive.current && onDone) {
        isActive.current = false;
        onDone();
      }
    };
  }, [pooled, onDone]);
  
  // Handle cleanup when projectile is done
  useEffect(() => {
    return () => {
      if (isActive.current && onDone) {
        isActive.current = false;
        onDone();
      }
    };
  }, [onDone]);
  
  // Setup particle system for water droplet effects
  const dropletParticles = useParticleSystem({
    emitterPosition: () => position,
    emitterShape: 'sphere',
    emitterRadius: 0.3,
    particleLifetime: { min: 0.3, max: 0.5 },
    particleSpeed: { min: 0.5, max: 2 },
    particleSize: { min: 0.05, max: 0.15 },
    particleOpacity: { min: 0.7, max: 1.0 },
    emissionRate: 15,
    maxParticles: 30,
    gravity: new Vector3(0, -9.8, 0),
    generateParticle: () => {
      const angle = Math.random() * Math.PI * 2;
      const distance = Math.random() * 0.3;
      
      return {
        id: `droplet-${id}-${Math.random().toString(36).substring(2, 9)}`,
        position: new Vector3(
          position.x + Math.cos(angle) * distance,
          position.y + Math.sin(angle) * distance + 0.1,
          position.z + Math.sin(angle) * distance
        ),
        velocity: new Vector3(
          (Math.random() - 0.5) * 1.5,
          Math.random() * 1.5,
          (Math.random() - 0.5) * 1.5
        ),
        scale: 0.05 + Math.random() * 0.1,
        opacity: 0.7 + Math.random() * 0.3,
        lifetime: 0,
        maxLifetime: 0.3 + Math.random() * 0.2,
        color: new Color(0x57c1eb),
        rotation: new Vector3(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        ),
        rotationSpeed: new Vector3(
          (Math.random() - 0.5) * 3,
          (Math.random() - 0.5) * 3,
          (Math.random() - 0.5) * 3
        )
      };
    },
    updateParticle: (particle: Particle, deltaTime: number) => {
      if (particle.lifetime + deltaTime > particle.maxLifetime) {
        return null; // Remove particle
      }
      
      // Update rotation if available
      const rotParticle = particle as Particle & { rotation?: Vector3, rotationSpeed?: Vector3 };
      const newRotation = rotParticle.rotation && rotParticle.rotationSpeed ? new Vector3(
        rotParticle.rotation.x + rotParticle.rotationSpeed.x * deltaTime,
        rotParticle.rotation.y + rotParticle.rotationSpeed.y * deltaTime,
        rotParticle.rotation.z + rotParticle.rotationSpeed.z * deltaTime
      ) : undefined;
      
      // Update particle
      return {
        ...particle,
        rotation: newRotation || rotParticle.rotation,
        opacity: Math.max(0, (particle.maxLifetime - particle.lifetime) / particle.maxLifetime), // fade out
        lifetime: particle.lifetime + deltaTime
      };
    }
  });
  
  // Apply water-like wobble effect and update pooled position
  useFrame((state) => {
    if (!mainRef.current) return;
    
    // Update pooled group position
    if (pooled) {
      pooled.position.set(position.x, position.y, position.z);
      pooled.visible = true;
    }
    
    // Water-like wobble effect
    const wobbleFactor = Math.sin(state.clock.elapsedTime * 12 + timeOffset.current) * 0.2 + 0.8;
    mainRef.current.scale.set(wobbleFactor, 1, wobbleFactor);
    
    // Random movement for more natural water motion
    if (groupRef.current) {
      groupRef.current.position.y = Math.sin(state.clock.elapsedTime * 10) * 0.1;
      groupRef.current.rotation.z = Math.sin(state.clock.elapsedTime * 4) * 0.05;
    }
  });

  // If we're using pooled objects, return the primitive
  if (pooled) {
    return <primitive object={pooled} />;
  }
  
  // Legacy rendering path for non-pooled usage
  return (
    <group 
      ref={groupRef} 
      position={[position.x, position.y, position.z]} 
    >
      {/* Main water ball */}
      <mesh key={`core-${id}`} ref={mainRef}>
        <sphereGeometry key={`core-geo-${id}`} args={[0.4, 16, 16]} />
        <meshStandardMaterial 
          key={`core-mat-${id}`}
          color="#57c1eb"
          transparent={true}
          opacity={0.7}
          roughness={0.2}
          metalness={0.7}
        />
      </mesh>
      
      {/* Render water droplet particles */}
      {dropletParticles.particles.map(particle => {
        const rotParticle = particle as Particle & { rotation?: Vector3 };
        const rotation = rotParticle.rotation;
        
        return (
          <mesh
            key={particle.id}
            position={[particle.position.x, particle.position.y, particle.position.z]}
            rotation={rotation ? [rotation.x, rotation.y, rotation.z] : [0, 0, 0]}
            scale={[particle.scale, particle.scale, particle.scale]}
          >
            <icosahedronGeometry args={[1, 0]} />
            <meshStandardMaterial
              color="#57c1eb"
              transparent
              opacity={particle.opacity}
              roughness={0.2}
              metalness={0.7}
            />
          </mesh>
        );
      })}
    </group>
  );
}

// Maintain compatibility with both default and named exports
export { WaterProjectile };


// ==============================================================================
// FILE: app/game/vfx/useParticleSystem.ts
// ==============================================================================

import { useState, useEffect, useRef } from 'react';
import { Vector3, Color } from 'three';
import { useFrame } from '@react-three/fiber';

export interface Particle {
  id: string;
  position: Vector3;
  velocity: Vector3;
  scale: number;
  opacity: number;
  color?: Color;
  rotation?: Vector3;
  rotationSpeed?: Vector3;
  lifetime: number;  // Current lifetime in seconds
  maxLifetime: number; // Maximum lifetime in seconds
  // Optional properties for different particle effects
  stretching?: number;
  acceleration?: Vector3;
  drag?: number;
}

export interface ParticleSystemOptions {
  initialParticles?: Particle[];
  maxParticles?: number;
  emissionRate?: number; // Particles per second
  emitterPosition?: Vector3 | (() => Vector3);
  emitterShape?: 'point' | 'sphere' | 'box' | 'cone';
  emitterRadius?: number;
  emitterSize?: Vector3;
  particleLifetime?: { min: number; max: number }; // In seconds
  particleSpeed?: { min: number; max: number };
  particleSize?: { min: number; max: number };
  particleOpacity?: { min: number; max: number };
  gravity?: Vector3;
  useCollision?: boolean;
  collisionPlaneY?: number;
  collisionDamping?: number;
  colorOverLifetime?: (progress: number) => Color;
  opacityOverLifetime?: (progress: number) => number;
  sizeOverLifetime?: (progress: number) => number;
  generateParticle?: () => Particle;
  updateParticle?: (particle: Particle, deltaTime: number) => Particle | null;
}

const defaultOptions: ParticleSystemOptions = {
  initialParticles: [],
  maxParticles: 100,
  emissionRate: 0, // Default to no continuous emission
  emitterPosition: new Vector3(0, 0, 0),
  emitterShape: 'point',
  emitterRadius: 0.5,
  emitterSize: new Vector3(1, 1, 1),
  particleLifetime: { min: 1, max: 3 },
  particleSpeed: { min: 0.5, max: 2 },
  particleSize: { min: 0.1, max: 0.3 },
  particleOpacity: { min: 0.5, max: 1 },
  gravity: new Vector3(0, -9.8, 0),
  useCollision: false,
  collisionPlaneY: 0,
  collisionDamping: 0.5,
};

const useParticleSystem = (options: ParticleSystemOptions = {}) => {
  const optionsWithDefaults = { ...defaultOptions, ...options };
  const [particles, setParticles] = useState<Particle[]>(
    optionsWithDefaults.initialParticles || []
  );
  const lastEmitTime = useRef(0);
  const isActive = useRef(true);
  
  // Generate a new particle
  const generateParticle = (): Particle => {
    if (optionsWithDefaults.generateParticle) {
      return optionsWithDefaults.generateParticle();
    }
    
    // Get emitter position (can be static or dynamic)
    const emitterPos = typeof optionsWithDefaults.emitterPosition === 'function'
      ? optionsWithDefaults.emitterPosition()
      : optionsWithDefaults.emitterPosition!;
    
    // Generate position based on emitter shape
    const position = new Vector3();
    switch (optionsWithDefaults.emitterShape) {
      case 'sphere': {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos((Math.random() * 2) - 1);
        const radius = optionsWithDefaults.emitterRadius! * Math.cbrt(Math.random());
        position.set(
          emitterPos.x + radius * Math.sin(phi) * Math.cos(theta),
          emitterPos.y + radius * Math.sin(phi) * Math.sin(theta),
          emitterPos.z + radius * Math.cos(phi)
        );
        break;
      }
        
      case 'box': {
        const size = optionsWithDefaults.emitterSize!;
        position.set(
          emitterPos.x + (Math.random() - 0.5) * size.x,
          emitterPos.y + (Math.random() - 0.5) * size.y,
          emitterPos.z + (Math.random() - 0.5) * size.z
        );
        break;
      }
        
      case 'cone': {
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * optionsWithDefaults.emitterRadius!;
        position.set(
          emitterPos.x + Math.cos(angle) * distance,
          emitterPos.y,
          emitterPos.z + Math.sin(angle) * distance
        );
        break;
      }
        
      case 'point':
      default:
        position.copy(emitterPos);
        break;
    }
    
    // Generate random velocity direction
    const velocityDir = new Vector3(
      Math.random() * 2 - 1,
      Math.random() * 2 - 1,
      Math.random() * 2 - 1
    ).normalize();
    
    // Apply random speed
    const speed = optionsWithDefaults.particleSpeed!.min + 
      Math.random() * (optionsWithDefaults.particleSpeed!.max - optionsWithDefaults.particleSpeed!.min);
    const velocity = velocityDir.multiplyScalar(speed);
    
    // Generate other random properties
    const scale = optionsWithDefaults.particleSize!.min + 
      Math.random() * (optionsWithDefaults.particleSize!.max - optionsWithDefaults.particleSize!.min);
    const opacity = optionsWithDefaults.particleOpacity!.min + 
      Math.random() * (optionsWithDefaults.particleOpacity!.max - optionsWithDefaults.particleOpacity!.min);
    const lifetime = 0; // Start at 0
    const maxLifetime = optionsWithDefaults.particleLifetime!.min + 
      Math.random() * (optionsWithDefaults.particleLifetime!.max - optionsWithDefaults.particleLifetime!.min);
    
    return {
      id: `particle-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
      position,
      velocity,
      scale,
      opacity,
      lifetime,
      maxLifetime,
      color: new Color(0xffffff),
      rotation: new Vector3(0, 0, 0),
      rotationSpeed: new Vector3(
        (Math.random() - 0.5) * 2,
        (Math.random() - 0.5) * 2,
        (Math.random() - 0.5) * 2
      ),
    };
  };
  
  // Update a particle for a time step
  const updateParticle = (particle: Particle, deltaTime: number): Particle | null => {
    if (optionsWithDefaults.updateParticle) {
      return optionsWithDefaults.updateParticle(particle, deltaTime);
    }
    
    // Update lifetime and check if particle should be removed
    const newLifetime = particle.lifetime + deltaTime;
    if (newLifetime >= particle.maxLifetime) {
      return null; // Remove particle
    }
    
    // Clone particle for updates
    const newParticle = { ...particle, lifetime: newLifetime };
    
    // Apply gravity
    if (optionsWithDefaults.gravity) {
      newParticle.velocity = new Vector3(
        particle.velocity.x + optionsWithDefaults.gravity.x * deltaTime,
        particle.velocity.y + optionsWithDefaults.gravity.y * deltaTime,
        particle.velocity.z + optionsWithDefaults.gravity.z * deltaTime
      );
    }
    
    // Apply velocity to position
    newParticle.position = new Vector3(
      particle.position.x + particle.velocity.x * deltaTime,
      particle.position.y + particle.velocity.y * deltaTime,
      particle.position.z + particle.velocity.z * deltaTime
    );
    
    // Apply rotation
    if (particle.rotation && particle.rotationSpeed) {
      newParticle.rotation = new Vector3(
        particle.rotation.x + particle.rotationSpeed.x * deltaTime,
        particle.rotation.y + particle.rotationSpeed.y * deltaTime,
        particle.rotation.z + particle.rotationSpeed.z * deltaTime
      );
    }
    
    // Check for collision with ground
    if (optionsWithDefaults.useCollision && 
        newParticle.position.y < optionsWithDefaults.collisionPlaneY!) {
      // Reflect off the ground with damping
      newParticle.position.y = optionsWithDefaults.collisionPlaneY!;
      newParticle.velocity.y = -newParticle.velocity.y * optionsWithDefaults.collisionDamping!;
      
      // Apply friction to horizontal velocity
      newParticle.velocity.x *= 0.9;
      newParticle.velocity.z *= 0.9;
      
      // If velocity is very small after bouncing, just stop it
      if (Math.abs(newParticle.velocity.y) < 0.1) {
        newParticle.velocity.y = 0;
      }
    }
    
    // Apply color over lifetime if provided
    if (optionsWithDefaults.colorOverLifetime && particle.color) {
      const lifetimeProgress = newParticle.lifetime / newParticle.maxLifetime;
      newParticle.color = optionsWithDefaults.colorOverLifetime(lifetimeProgress);
    }
    
    // Apply opacity over lifetime if provided
    if (optionsWithDefaults.opacityOverLifetime) {
      const lifetimeProgress = newParticle.lifetime / newParticle.maxLifetime;
      newParticle.opacity = optionsWithDefaults.opacityOverLifetime(lifetimeProgress);
    }
    
    // Apply size over lifetime if provided
    if (optionsWithDefaults.sizeOverLifetime) {
      const lifetimeProgress = newParticle.lifetime / newParticle.maxLifetime;
      newParticle.scale = optionsWithDefaults.sizeOverLifetime(lifetimeProgress);
    }
    
    return newParticle;
  };
  
  // Add new particles to the system
  const addParticles = (newParticles: Particle[]) => {
    setParticles(currentParticles => {
      // Enforce max particles limit if needed
      const combinedParticles = [...currentParticles, ...newParticles];
      if (optionsWithDefaults.maxParticles && 
          combinedParticles.length > optionsWithDefaults.maxParticles) {
        return combinedParticles.slice(-optionsWithDefaults.maxParticles);
      }
      return combinedParticles;
    });
  };
  
  // Emit a specific number of particles
  const emit = (count: number) => {
    const newParticles = Array.from({ length: count }, generateParticle);
    addParticles(newParticles);
  };
  
  // Clear all particles
  const clear = () => {
    setParticles([]);
  };
  
  // Pause/resume the particle system
  const setActive = (active: boolean) => {
    isActive.current = active;
  };
  
  // Setup continuous emission if enabled
  useFrame((_, delta) => {
    if (!isActive.current) return;
    
    const now = performance.now();
    const deltaSeconds = delta; // delta is already in seconds
    
    // Handle continuous emission if enabled
    if (optionsWithDefaults.emissionRate! > 0) {
      const timeSinceLastEmit = (now - lastEmitTime.current) / 1000; // convert to seconds
      const particlesToEmit = Math.floor(timeSinceLastEmit * optionsWithDefaults.emissionRate!);
      
      if (particlesToEmit > 0) {
        emit(particlesToEmit);
        lastEmitTime.current = now;
      }
    }
    
    // Update all particles
    setParticles(currentParticles => {
      return currentParticles
        .map(particle => updateParticle(particle, deltaSeconds))
        .filter((particle): particle is Particle => particle !== null);
    });
  });
  
  // Initialize with provided particles
  useEffect(() => {
    if (optionsWithDefaults.initialParticles && 
        optionsWithDefaults.initialParticles.length > 0) {
      setParticles(optionsWithDefaults.initialParticles);
    }
    
    lastEmitTime.current = performance.now();
    
    return () => {
      // Cleanup if needed
    };
  }, []);
  
  return {
    particles,
    emit,
    clear,
    setActive,
    addParticles,
  };
};

export default useParticleSystem;


// ==============================================================================
// FILE: app/game/vfx/useProjectileMovement.ts
// ==============================================================================

import { useState, useEffect, useRef } from 'react';
import { Vector3 } from 'three';
import { useFrame } from '@react-three/fiber';

/**
 * Hook for calculating projectile movement based on the server's expected trajectory.
 * Uses precise timing to ensure client-server consistency.
 */
interface Params {
  origin: { x: number; y: number; z: number };
  dir: { x: number; y: number; z: number };
  speed: number;
  launchTs: number;
}

const useProjectileMovement = ({
  origin,
  dir,
  speed,
  launchTs,
  gravity = 0,
  shouldAutoDestroy = false, // Changed default to false - projectiles should be controlled by server state
  maxDistance = 100,
  onDestroy
}: Params & {
  gravity?: number;
  shouldAutoDestroy?: boolean;
  maxDistance?: number;
  onDestroy?: () => void;
}) => {
  // Create stable references for the initial values
  const originalOrigin = useRef(new Vector3(origin.x, origin.y, origin.z));
  const originalDir = useRef(new Vector3(dir.x, dir.y, dir.z).normalize());
  const originalSpeed = useRef(speed);
  
  // Store the server epoch launchTs directly
  const originalLaunchTs = useRef(launchTs);
  
  // Use state for the current position so renders will happen when it updates
  const [currentPosition, setCurrentPosition] = useState(new Vector3(origin.x, origin.y, origin.z));
  
  // Additional refs for tracking distance, etc.
  const totalDistance = useRef(0);
  const isDestroyed = useRef(false);
  
  // Initial debug log when projectile is created
  useEffect(() => {
    console.log(`[ProjMove] New projectile created:`, {
      origin: `(${origin?.x?.toFixed(2) || 'undefined'}, ${origin?.y?.toFixed(2) || 'undefined'}, ${origin?.z?.toFixed(2) || 'undefined'})`,
      dir: `(${dir?.x?.toFixed(2) || 'undefined'}, ${dir?.y?.toFixed(2) || 'undefined'}, ${dir?.z?.toFixed(2) || 'undefined'})`,
      speed: speed,
      originalTs: launchTs,
      now: Date.now()
    });
    
    console.log(`[ProjMove Hook] Initialized for a projectile. Origin: (${origin?.x?.toFixed(2)}, ${origin?.y?.toFixed(2)}, ${origin?.z?.toFixed(2)}), Dir: (${dir?.x?.toFixed(2)}, ${dir?.y?.toFixed(2)}, ${dir?.z?.toFixed(2)}), Speed: ${speed}, LaunchTs: ${launchTs}, ServerEpochTs: ${originalLaunchTs.current}`);
  }, [origin, dir, speed, launchTs]);
  
  // Function to calculate position at a given time
  const calculatePosition = (elapsedTimeSeconds: number) => {
    // Calculate the base motion (direction * speed * time)
    const position = new Vector3().copy(originalOrigin.current);
    const movement = new Vector3()
      .copy(originalDir.current)
      .multiplyScalar(originalSpeed.current * elapsedTimeSeconds);
    
    // Apply movement
    position.add(movement);
    
    // Apply gravity if specified (gravity * time^2 / 2)
    if (gravity !== 0) {
      position.y -= 0.5 * gravity * elapsedTimeSeconds * elapsedTimeSeconds;
    }
    
    // Calculate total distance traveled
    const distanceTraveled = originalSpeed.current * elapsedTimeSeconds;
    totalDistance.current = distanceTraveled;
    
    return position;
  };
  
  // Update position each frame
  useFrame(() => {
    if (isDestroyed.current) return;
    
    // Calculate elapsed time in seconds since launch using epoch time
    const clientNowEpoch = Date.now();
    
    // Handle case where launchTs might be in the future due to clock mismatch
    // or using a server timestamp that's ahead of client clock
    let elapsedTimeSeconds = Math.max(0, (clientNowEpoch - originalLaunchTs.current) / 1000);
    
    // Sanity check: if elapsed time is too large or negative, use a small value
    // and auto-destroy the projectile if it's been alive for more than 5 seconds
    if (elapsedTimeSeconds < 0 || elapsedTimeSeconds > 5) {
      console.warn(`[ProjMove] Excessive elapsed time: ${elapsedTimeSeconds?.toFixed(3) || 'undefined'}s. Auto-destroying projectile.`);
      
      // Auto-destroy the projectile since it's been alive too long
      isDestroyed.current = true;
      if (onDestroy) onDestroy();
      
      // Use a reasonable fallback for final position calculation
      elapsedTimeSeconds = Math.min(5, Math.max(0, elapsedTimeSeconds));
    }
    
    // Calculate new position
    const newPosition = calculatePosition(elapsedTimeSeconds);
    
    // Debug logging to track position calculations (only log occasionally to reduce spam)
    if (Math.random() < 0.05) { // Log roughly 5% of frames
      console.log(`[ProjMove] Elapsed: ${elapsedTimeSeconds.toFixed(3)}, NewPos: (${newPosition?.x?.toFixed(2) || 'undefined'}, ${newPosition?.y?.toFixed(2) || 'undefined'}, ${newPosition?.z?.toFixed(2) || 'undefined'})`);
    }
    
    // Enhanced hook logging (in addition to existing logs)
    if (Math.random() < 0.02) { // Reduce log frequency
      console.log(`[ProjMove Hook] Update. Elapsed: ${elapsedTimeSeconds?.toFixed(3)}, NewPos: (${newPosition?.x?.toFixed(2)}, ${newPosition?.y?.toFixed(2)}, ${newPosition?.z?.toFixed(2)})`);
    }
    
    // Only update position if it has actually changed to prevent infinite updates
    if (!currentPosition.equals(newPosition)) {
      setCurrentPosition(newPosition);
    }
    
    // Check if projectile should be destroyed
    if (shouldAutoDestroy && totalDistance.current >= maxDistance) {
      console.log(`[ProjMove Hook] Auto-destroying projectile. Distance: ${totalDistance.current.toFixed(2)} >= ${maxDistance}`);
      isDestroyed.current = true;
      if (onDestroy) onDestroy();
    }
  });
  
  // Expose methods to manually destroy the projectile
  const destroy = () => {
    if (!isDestroyed.current) {
      isDestroyed.current = true;
      if (onDestroy) onDestroy();
    }
  };
  
  return {
    position: currentPosition,
    isDestroyed: isDestroyed.current,
    destroy,
    totalDistance: totalDistance.current
  };
};

export default useProjectileMovement;


// ==============================================================================
// FILE: app/layout.tsx
// ==============================================================================

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Vibeage",
  description: " 3D MMORPG Adventure",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" className="dark">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased bg-black text-white`}
      >
        {children}
      </body>
    </html>
  );
}


// ==============================================================================
// FILE: app/page.tsx
// ==============================================================================

import Game from './game/components/Game'

export default function Home() {
  return (
    <main className="w-full h-screen">
      <Game />
    </main>
  );
}


// ==============================================================================
// FILE: generate-project-doc.ts
// ==============================================================================

import * as fs from 'fs';
import * as path from 'path';

// Configuration
const rootDir = process.cwd();
const outputFile = path.join(rootDir, 'all_project_in_a_single_file_for_llm.txt');
const excludeDirs = [
  'node_modules',
  '.git',
  '.next',
  'dist',
  'build',
];

const includeExtensions = [
  '.ts',
  '.tsx',
];

// Skip test files unless they provide valuable documentation
const excludePatterns = [
  /\.test\./,
  /\.spec\./,
  /\.bench\./,
  /next-env\.d\.ts/,
  /tsconfig\.tsbuildinfo/,
  /package-lock\.json/,
  /pnpm-lock\.yaml/,
];

const isExcludedPath = (filePath: string): boolean => {
  const relativePath = path.relative(rootDir, filePath);
  return excludeDirs.some(dir => 
    relativePath.startsWith(dir + path.sep) || relativePath === dir
  );
};

const isExcludedFile = (filePath: string): boolean => {
  const fileName = path.basename(filePath);
  return excludePatterns.some(pattern => pattern.test(fileName));
};

const shouldIncludeFile = (filePath: string): boolean => {
  if (isExcludedPath(filePath) || isExcludedFile(filePath)) {
    return false;
  }
  
  const ext = path.extname(filePath).toLowerCase();
  return includeExtensions.includes(ext);
};

// Function to walk through directories and find all files
function walkDir(dir: string, fileList: string[] = []): string[] {
  const files = fs.readdirSync(dir);
  
  for (const file of files) {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    
    if (stat.isDirectory()) {
      if (!isExcludedPath(filePath)) {
        walkDir(filePath, fileList);
      }
    } else if (shouldIncludeFile(filePath)) {
      fileList.push(filePath);
    }
  }
  
  return fileList;
}

// Generate file content
async function generateProjectDoc() {
  console.log('Generating project documentation...');
  
  const allFiles = walkDir(rootDir);
  
  // Sort files by path for better organization
  allFiles.sort();
  
  let output = `// Project Documentation
// Generated on: ${new Date().toISOString()}
// This file contains the source code of all meaningful files in the project.

`;

  for (const filePath of allFiles) {
    // Skip the output file itself
    if (filePath === outputFile) continue;
    
    try {
      const fileContent = fs.readFileSync(filePath, 'utf8');
      const relativePath = path.relative(rootDir, filePath);
      
      output += `\n\n// ${'='.repeat(78)}\n`;
      output += `// FILE: ${relativePath}\n`;
      output += `// ${'='.repeat(78)}\n\n`;
      output += fileContent;
    } catch (error) {
      console.error(`Error reading file ${filePath}:`, error);
    }
  }
  
  fs.writeFileSync(outputFile, output);
  console.log(`Project documentation created at: ${outputFile}`);
  console.log(`Total files included: ${allFiles.length}`);
}

// Run the script
generateProjectDoc().catch(console.error);


// ==============================================================================
// FILE: next.config.ts
// ==============================================================================

import type { NextConfig } from "next";

const isProd = process.env.NODE_ENV === 'production';

const nextConfig: NextConfig = {
  webpack: (config) => {
    config.externals = [...(config.externals || []), { bufferutil: 'bufferutil', 'utf-8-validate': 'utf-8-validate' }];
    return config;
  },
  
  // Kills console.* except error/warn in prod
  compiler: {
    removeConsole: isProd ? { exclude: ['error', 'warn'] } : false,
  },
  
  // Add rewrites for Socket.IO
  rewrites: async () => {
    return [
      {
        source: '/socket.io/:path*',
        destination: 'http://localhost:3001/socket.io/:path*',
      },
    ];
  },
};

export default nextConfig;


// ==============================================================================
// FILE: script.ts
// ==============================================================================



// ==============================================================================
// FILE: server/collision.ts
// ==============================================================================

import { VecXZ } from '../shared/types.js';
import { log, LOG_CATEGORIES } from './logger';

// Constants for the game world
const WORLD_BOUNDS = {
    minX: -500,
    maxX: 500,
    minZ: -500,
    maxZ: 500
};

// Define obstacles - can be expanded with more complex shapes
const OBSTACLES: Array<{
    type: 'circle' | 'rectangle';
    center?: VecXZ;
    position?: VecXZ;
    radius?: number;
    width?: number;
    height?: number;
}> = [
    // Central lake - moved away from spawn
    //{
    //    type: 'circle',
    //    center: { x: 100, z: 100 }, // was { x: 0, z: 0 }
    //    radius: 50
    //},
    //// Mountain area - north rectangle
    //{
    //    type: 'rectangle',
    //    position: { x: -100, z: 300 },
    //    width: 200,
    //    height: 100
    //},
    // Ruins - west rectangle
    {
        type: 'rectangle',
        position: { x: -300, z: -50 },
        width: 100,
        height: 100
    }
];

/**
 * Check if a line segment intersects with a circle
 * @param start Start point of line segment
 * @param end End point of line segment
 * @param center Circle center
 * @param radius Circle radius
 * @returns True if line segment intersects with circle
 */
function lineIntersectsCircle(start: VecXZ, end: VecXZ, center: VecXZ, radius: number): boolean {
    // Vector from start to end
    const dx = end.x - start.x;
    const dz = end.z - start.z;
    
    // Vector from start to circle center
    const sx = center.x - start.x;
    const sz = center.z - start.z;
    
    // Length of line segment squared
    const lengthSquared = dx * dx + dz * dz;
    
    // Dot product of the two vectors
    const dotProduct = sx * dx + sz * dz;
    
    // Projection of center onto line segment
    const projection = dotProduct / lengthSquared;
    
    // Closest point on line segment to circle center
    let closestX, closestZ;
    
    if (projection < 0) {
        // Closest point is start
        closestX = start.x;
        closestZ = start.z;
    } else if (projection > 1) {
        // Closest point is end
        closestX = end.x;
        closestZ = end.z;
    } else {
        // Closest point is on the line segment
        closestX = start.x + projection * dx;
        closestZ = start.z + projection * dz;
    }
    
    // Distance from closest point to circle center
    const distance = Math.sqrt(
        Math.pow(closestX - center.x, 2) + 
        Math.pow(closestZ - center.z, 2)
    );
    
    // Check if distance is less than radius (intersection)
    return distance <= radius;
}

/**
 * Check if a line segment intersects with a rectangle
 * @param start Start point of line segment
 * @param end End point of line segment
 * @param rectPos Rectangle position (top-left corner)
 * @param width Rectangle width
 * @param height Rectangle height
 * @returns True if line segment intersects with rectangle
 */
function lineIntersectsRectangle(
    start: VecXZ, 
    end: VecXZ, 
    rectPos: VecXZ, 
    width: number, 
    height: number
): boolean {
    // Rectangle corners
    const topLeft = rectPos;
    const topRight = { x: rectPos.x + width, z: rectPos.z };
    const bottomLeft = { x: rectPos.x, z: rectPos.z + height };
    const bottomRight = { x: rectPos.x + width, z: rectPos.z + height };
    
    // Check if line intersects any of the rectangle edges
    return (
        lineIntersectsLine(start, end, topLeft, topRight) ||
        lineIntersectsLine(start, end, topRight, bottomRight) ||
        lineIntersectsLine(start, end, bottomRight, bottomLeft) ||
        lineIntersectsLine(start, end, bottomLeft, topLeft)
    );
}

/**
 * Check if two line segments intersect
 * @param a1 First point of first line
 * @param a2 Second point of first line
 * @param b1 First point of second line
 * @param b2 Second point of second line
 * @returns True if lines intersect
 */
function lineIntersectsLine(a1: VecXZ, a2: VecXZ, b1: VecXZ, b2: VecXZ): boolean {
    // Direction vectors
    const dxa = a2.x - a1.x;
    const dza = a2.z - a1.z;
    const dxb = b2.x - b1.x;
    const dzb = b2.z - b1.z;
    
    // Cross product of direction vectors
    const crossProduct = dxa * dzb - dza * dxb;
    
    // If cross product is zero, lines are parallel
    if (Math.abs(crossProduct) < 1e-10) return false;
    
    // Vector from a1 to b1
    const dx = b1.x - a1.x;
    const dz = b1.z - a1.z;
    
    // Parameters for line equations
    const t = (dx * dzb - dz * dxb) / crossProduct;
    const u = (dx * dza - dz * dxa) / crossProduct;
    
    // Check if intersection point is on both line segments
    return t >= 0 && t <= 1 && u >= 0 && u <= 1;
}

/**
 * Check if a movement path from start to destination is blocked by any obstacle
 * @param start Starting position
 * @param dest Destination position
 * @returns true if the path is blocked
 */
export function isPathBlocked(start: VecXZ, dest: VecXZ): boolean {
    // Check world boundaries
    if (dest.x < WORLD_BOUNDS.minX || dest.x > WORLD_BOUNDS.maxX ||
        dest.z < WORLD_BOUNDS.minZ || dest.z > WORLD_BOUNDS.maxZ) {
        console.log('[COLLISION] Blocked by world bounds', { start, dest, bounds: WORLD_BOUNDS });
        return true;
    }
    // Check obstacle collisions
    for (const obstacle of OBSTACLES) {
        if (obstacle.type === 'circle' && obstacle.center && obstacle.radius) {
            if (lineIntersectsCircle(start, dest, obstacle.center, obstacle.radius)) {
                console.log('[COLLISION] Blocked by circle', { start, dest, center: obstacle.center, radius: obstacle.radius });
                return true;
            }
        } else if (obstacle.type === 'rectangle' && obstacle.position && obstacle.width && obstacle.height) {
            if (lineIntersectsRectangle(start, dest, obstacle.position, obstacle.width, obstacle.height)) {
                console.log('[COLLISION] Blocked by rectangle', { start, dest, position: obstacle.position, width: obstacle.width, height: obstacle.height });
                return true;
            }
        }
    }
    console.log('[COLLISION] Path clear', { start, dest });
    return false;
}

/**
 * Find a valid destination point as close as possible to the requested one
 * @param start Starting position
 * @param dest Requested destination
 * @returns Valid destination point
 */
export function findValidDestination(start: VecXZ, dest: VecXZ): VecXZ {
    // If path is not blocked, return original destination
    if (!isPathBlocked(start, dest)) return dest;
    
    // Simple approach: try points along the line from start to dest
    const dx = dest.x - start.x;
    const dz = dest.z - start.z;

    // Try increments of 5% back from the destination
    for (let percent = 0.95; percent >= 0.05; percent -= 0.05) {
        const testPoint = {
            x: start.x + dx * percent,
            z: start.z + dz * percent
        };
        
        if (!isPathBlocked(start, testPoint)) {
            console.log('[COLLISION] Clamped destination', { from: dest, to: testPoint });
            return testPoint;
        }
    }
    console.log('[COLLISION] No valid destination found, returning start', { start, dest });
    return { ...start };
}

// Simple distance function between two points
function distance(a: VecXZ, b: VecXZ): number {
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.z - b.z, 2));
}

/**
 * Check if a moving point with initial position a0 and final position a1
 * collides with a stationary circle at bPos with radius bRadius
 * Implements swept AABB collision detection for projectiles
 * @param a0 Initial position of the moving point
 * @param a1 Final position of the moving point
 * @param bPos Position of the stationary circle
 * @param projectileHitRadius The radius of the projectile's hitbox
 * @returns true if collision occurs
 */
export function sweptHit(
  a0: VecXZ, // projectile previous position
  a1: VecXZ, // projectile current position
  bPos: VecXZ, // target current position
  projectileHitRadius: number // The radius of the projectile's hitbox
): boolean {
  const targetRadius = 0.5; // Assume a default radius for targets for simplicity
  const effectiveHitRadius = projectileHitRadius + targetRadius; // Sum of radii

  // Log hit check details for debugging
  log(LOG_CATEGORIES.COLLISION, `SweptHit: Proj from (${a0.x.toFixed(2)}, ${a0.z.toFixed(2)}) to (${a1.x.toFixed(2)}, ${a1.z.toFixed(2)}), target at (${bPos.x.toFixed(2)}, ${bPos.z.toFixed(2)}) with effective radius ${effectiveHitRadius}`);
  
  // Vector from projectile start to target center
  const Px = bPos.x - a0.x;
  const Pz = bPos.z - a0.z;

  // Projectile movement vector
  const Vx = a1.x - a0.x;
  const Vz = a1.z - a0.z;

  const VLengthSq = Vx * Vx + Vz * Vz;
  if (VLengthSq < 0.0001) { // Projectile hasn't moved significantly
    return distance(a0, bPos) <= effectiveHitRadius;
  }

  // Project P onto V
  // t = (P . V) / (V . V)
  const t = (Px * Vx + Pz * Vz) / VLengthSq;

  let closestPoint: VecXZ;
  if (t < 0) {
    closestPoint = a0; // Closest point is the start of the segment
  } else if (t > 1) {
    closestPoint = a1; // Closest point is the end of the segment
  } else {
    closestPoint = { x: a0.x + t * Vx, z: a0.z + t * Vz }; // Closest point is on the segment
  }

  const distToClosestPointSq = Math.pow(bPos.x - closestPoint.x, 2) + Math.pow(bPos.z - closestPoint.z, 2);

  const hit = distToClosestPointSq <= effectiveHitRadius * effectiveHitRadius;

  if (hit && Math.random() < 0.1) { // Reduce log spam
    log(LOG_CATEGORIES.COLLISION, `Swept HIT! DistSq: ${distToClosestPointSq.toFixed(2)} <= RadiusSq: ${(effectiveHitRadius * effectiveHitRadius).toFixed(2)}`);
  }
  
  return hit;
}


// ==============================================================================
// FILE: server/combat/castHandler.ts
// ==============================================================================

import { Socket, Server } from 'socket.io';
import { SKILLS, SkillId } from '../../shared/skillsDefinition.js';
import { CastReq, CastFail } from '../../shared/messages.js';
import { VecXZ } from '../../shared/messages.js';
import { PlayerState } from '../../shared/types.js';
import { handleCastRequest } from './skillSystem.js';
import { canCast } from './utils/cast.js';

/**
 * World interface for interacting with game state
 */
interface World {
  getEnemyById: (id: string) => any | null;
  getPlayerById: (id: string) => PlayerState | null;
  getEntitiesInCircle: (pos: VecXZ, radius: number) => any[];
}

/**
 * Handles a cast request from the client
 * Integration point between the world.ts and the new skillSystem.ts
 */
export function handleCastReq(
  socket: Socket,
  player: PlayerState,
  msg: CastReq,
  io: Server,
  world: World
): void {
  const playerId = msg.id;
  
  console.log(`Handling cast request: player=${playerId}, skill=${msg.skillId}, target=${msg.targetId || 'none'}`);
  
  // Verify player exists and belongs to this socket
  if (!player || player.socketId !== socket.id) {
    console.warn(`Invalid cast request: player=${playerId}, socketId mismatch`);
    return;
  }
  
  if (!player.unlockedSkills.includes(msg.skillId as SkillId)) {
    console.warn(`Player ${playerId} tried to cast not owned skill: ${msg.skillId}`);
    socket.emit('msg', {
      type: 'CastFail',
      clientSeq: msg.clientTs,
      reason: 'invalid'
    } as CastFail);
    return;
  }
  
  const skillId = msg.skillId as SkillId;
  const skill = SKILLS[skillId];
  
  // Check if the skill exists
  if (!skill) {
    socket.emit('msg', {
      type: 'CastFail',
      clientSeq: msg.clientTs,
      reason: 'invalid'
    } as CastFail);
    return;
  }
  
  // Get target if any
  const target = msg.targetId ? world.getEnemyById(msg.targetId) : null;
  const now = Date.now();
  
  // Use the canCast utility function to validate the cast
  const castCheck = canCast(player, { id: skillId, range: skill.range || 0 }, target, msg.targetPos, now);
  if (!castCheck.canCast) {
    console.log(`Cast failed for player ${playerId}, skill ${skillId}: ${castCheck.reason}`);
    socket.emit('msg', {
      type: 'CastFail',
      clientSeq: msg.clientTs,
      reason: castCheck.reason || 'invalid'
    } as CastFail);
    return;
  }
  
  // Apply mana cost and cooldown
  player.mana -= skill.manaCost;
  
  if (!player.skillCooldownEndTs) {
    player.skillCooldownEndTs = {};
  }
  player.skillCooldownEndTs[skillId] = now + skill.cooldownMs;
  
  // Create a cast using the server authoritative skill system
  const castResult = handleCastRequest(
    player,
    playerId,
    skillId,
    msg.targetPos,
    msg.targetId,
    io,
    world
  );
  
  // Valid error reasons
  const validReasons = ['cooldown', 'nomana', 'invalid', 'outofrange'];
  
  // If castResult is a string and it's one of our valid error reasons,
  // it's an error. Otherwise, it's a successful cast ID (nanoid)
  if (typeof castResult === 'string' && validReasons.includes(castResult)) {
    console.log(`Cast failed for player ${playerId}, skill ${skillId}: ${castResult}`);
    
    socket.emit('msg', {
      type: 'CastFail',
      clientSeq: msg.clientTs,
      reason: castResult as 'cooldown' | 'nomana' | 'invalid' | 'outofrange'
    } as CastFail);
    return;
  }
  
  // If we got here, the cast was successful and castResult is the cast ID
  
  // Broadcast player update (mana consumed, cooldown set)
  io.emit('playerUpdated', {
    id: player.id,
    mana: player.mana,
    skillCooldownEndTs: player.skillCooldownEndTs
  });
}


// ==============================================================================
// FILE: server/combat/effects/EffectApplicator.ts
// ==============================================================================

/**
 * This file contains helper functions to process the ticks generated by the EffectRunner
 * and apply them to entities in the game world.
 */
import { EffectTick } from '../../../shared/effectsDefinition.js';
import { log, LOG_CATEGORIES } from '../../logger.js';

// Application functions for different effect types
const effectHandlers = {
  damage: (value: number, target: any) => {
    if (!target || target.health === undefined) return false;
    
    const oldHealth = target.health;
    target.health = Math.max(0, target.health - value);
    
    log(LOG_CATEGORIES.DAMAGE, `Entity ${target.id} took ${value} damage from status effect. Health: ${oldHealth} -> ${target.health}`);
    
    // Check if target died
    if (target.health <= 0 && target.isAlive) {
      target.health = 0;
      target.isAlive = false;
      target.deathTimeTs = Date.now();
      if (target.targetId) target.targetId = null;
      
      log(LOG_CATEGORIES.DAMAGE, `Entity ${target.id} was killed by status effect`);
      return true; // Entity died
    }
    
    return false; // Entity didn't die
  },
  
  healing: (value: number, target: any) => {
    if (!target || target.health === undefined || target.maxHealth === undefined) return false;
    
    // Only apply healing if the target is alive
    if (!target.isAlive) return false;
    
    const oldHealth = target.health;
    target.health = Math.min(target.maxHealth, target.health + value);
    
    log(LOG_CATEGORIES.HEALING, `Entity ${target.id} healed for ${value} from status effect. Health: ${oldHealth} -> ${target.health}`);
    
    return false; // No entity died from healing
  },
  
  mana: (value: number, target: any) => {
    if (!target || target.mana === undefined || target.maxMana === undefined) return false;
    
    const oldMana = target.mana;
    target.mana = Math.min(target.maxMana, Math.max(0, target.mana + value));
    
    log(LOG_CATEGORIES.MANA, `Entity ${target.id} mana change by ${value} from status effect. Mana: ${oldMana} -> ${target.mana}`);
    
    return false; // No entity died from mana change
  },
  
  stat: () => {
    // Stat modifications would go here
    // For now, we don't implement actual stat modifications
    return false;
  }
};

/**
 * Apply an effect tick to an entity
 * @param tick The effect tick to apply
 * @param target The target entity
 * @returns Whether the entity died from this tick
 */
export function applyEffectTick(tick: EffectTick, target: any): boolean {
  const handler = effectHandlers[tick.type];
  if (!handler) {
    console.error(`No handler found for effect type: ${tick.type}`);
    return false;
  }
  
  return handler(tick.value, target);
}


// ==============================================================================
// FILE: server/combat/skillSystem.ts
// ==============================================================================

import { Server } from 'socket.io';
import { SKILLS, SkillId } from '../../shared/skillsDefinition.js';
import { VecXZ } from '../../shared/messages.js';
import { CastState as CastStateEnum, CastSnapshot } from '../../shared/types.js';
import { nanoid } from 'nanoid';
import { PlayerState as Player } from '../../shared/types.js';
import { getDamage } from '../../shared/combatMath.js';
import { sweptHit } from '../collision.js';

// Set of constants for skill system
export const CAST_BROADCAST_RATE = 50; // ms, how often to send cast snapshots

/**
 * Get world interface for interacting with game state
 */
interface World {
  getEnemyById: (id: string) => any | null;
  getPlayerById: (id: string) => Player | null;
  getEntitiesInCircle: (pos: VecXZ, radius: number) => any[];
}

/**
 * Server-side Cast object with complete state machine
 */
export interface Cast {
  castId: string;
  casterId: string;
  skillId: SkillId;
  state: CastStateEnum;
  origin: VecXZ;
  target?: VecXZ;
  pos?: VecXZ; // Current position for projectiles
  dir?: VecXZ; // Direction for projectiles
  startedAt: number; // When the cast started
  lastBroadcast?: number; // Last time position was broadcast
  castTimeMs: number;
  targetId?: string;
  targetPos?: VecXZ;
  speed?: number; // Projectile speed
}

// Collection of active casts
const activeCasts: Cast[] = [];

/**
 * Calculate damage for a skill based on the skill and caster stats
 */
function calculateDamage(skill: any, caster?: any, castId?: string, targetId?: string): number {
  if (!skill || !skill.dmg) return 10; // Default damage
  
  const result = getDamage({
    caster: caster?.stats || { dmgMult: 1, critChance: 0, critMult: 2 },
    skill: { base: skill.dmg, variance: 0.1 },
    seed: `${castId || nanoid()}:${targetId || nanoid()}`
  });
  
  return result.dmg;
}

/**
 * Create a CastSnapshot from a Cast object
 */
function makeSnapshot(cast: Cast): CastSnapshot {
  return {
    castId: cast.castId,
    casterId: cast.casterId,
    skillId: cast.skillId,
    state: cast.state,
    origin: cast.origin,
    target: cast.targetPos,
    pos: cast.pos, // Include current position for projectiles
    dir: cast.dir, // Include direction for traveling projectiles
    startedAt: cast.startedAt,
    castTimeMs: cast.castTimeMs
  };
}

/**
 * Resolves the impact of a skill, applying damage and effects
 */
function resolveImpact(cast: Cast, io: Server, world: World): void {
  const skill = SKILLS[cast.skillId];
  
  // Get all targets in the area of effect
  const targets = getTargetsInArea(cast, world);
  const caster = world.getPlayerById(cast.casterId);
  
  // Calculate damage for each target
  const dmgValues = targets.map((target: any) => 
    calculateDamage(skill, caster, cast.castId, target.id)
  );
  
  // Apply damage to each target
  targets.forEach((target: any, index: number) => {
    // Apply damage if target has health
    if (target.health !== undefined) {
      target.health = Math.max(0, target.health - dmgValues[index]);
      
      // Apply skill effects
      if (skill.effects && skill.effects.length > 0) {
        applySkillEffects(target, skill);
      }
      
      // Check if target died
      if (target.health <= 0 && target.isAlive) {
        target.isAlive = false;
        target.deathTimeTs = Date.now();
        
        // Trigger any on-kill effects or rewards here
      }
      
      // Broadcast effect on the target
      io.emit('msg', {
        type: 'EffectSnapshot',
        targetId: target.id,
        effects: target.statusEffects
      });
      
      // Broadcast target state update
      io.emit('enemyUpdated', target);
    }
  });
  
  // Emit combat log message with damage values
  io.emit('msg', {
    type: 'CombatLog',
    castId: cast.castId,
    skillId: cast.skillId,
    casterId: cast.casterId,
    targets: targets.map((t: any) => t.id),
    damages: dmgValues
  });
}

/**
 * Get targets in the area of effect of a skill
 */
function getTargetsInArea(cast: Cast, world: World): any[] {
  const skill = SKILLS[cast.skillId];
  const targets: any[] = [];
  
  // Default position to check (projectile position or caster position)
  const pos = cast.pos || cast.origin;
  
  // Direct targeted cast
  if (cast.targetId) {
    const target = world.getEnemyById(cast.targetId);
    if (target && target.isAlive) {
      targets.push(target);
    }
  }
  
  // Area of effect
  if (skill.area && skill.area > 0) {
    // Get all entities in the area (includes players and enemies)
    const entitiesInArea = world.getEntitiesInCircle(pos, skill.area);
    
    // Filter based on skill targeting rules (e.g., enemies only, exclude caster, etc.)
    entitiesInArea.forEach(entity => {
      if (entity.id !== cast.casterId && entity.isAlive) {
        // Skip if we already have this target
        if (!targets.find(t => t.id === entity.id)) {
          targets.push(entity);
        }
      }
    });
  }
  
  return targets;
}

/**
 * Apply skill effects to a target
 */
function applySkillEffects(target: any, skill: any): void {
  if (!skill.effects || !target) return;
  
  // Apply each effect
  for (const effect of skill.effects) {
    // Skip effects without a duration
    if (!effect.durationMs) continue;
    
    // Create status effect
    const statusEffect = {
      id: nanoid(),
      type: effect.type,
      value: effect.value,
      durationMs: effect.durationMs || 0,
      startTimeTs: Date.now(),
      sourceSkill: skill.id
    };
    
    // Add to target's status effects
    if (!target.statusEffects) {
      target.statusEffects = [];
    }
    
    // Check for existing effect of same type and replace if found
    const existingIndex = target.statusEffects.findIndex(
      (e: any) => e.type === effect.type
    );
    
    if (existingIndex >= 0) {
      target.statusEffects[existingIndex] = statusEffect;
    } else {
      target.statusEffects.push(statusEffect);
    }
  }
}

/**
 * Check if a cast has reached its target or exceeded its range
 */
function reachedTarget(cast: Cast): boolean {
  if (!cast.pos || !cast.targetPos) return false;
  
  // Calculate distance to target
  const dist = Math.sqrt(
    Math.pow(cast.pos.x - cast.targetPos.x, 2) +
    Math.pow(cast.pos.z - cast.targetPos.z, 2)
  );
  
  // Consider reached if within 0.5 units
  return dist < 0.5;
}

/**
 * Check if a cast has exceeded its maximum range
 * @deprecated Now handled directly in tickCasts with more robust hit detection
 * This is kept for backward compatibility with existing code
 */
// @ts-ignore: Marked as deprecated - used by external code
function exceededRange(cast: Cast): boolean {
  if (!cast.pos || !cast.origin) return false;
  
  const skill = SKILLS[cast.skillId];
  const maxRange = skill.range || 10;
  
  // Calculate distance from origin
  const dist = Math.sqrt(
    Math.pow(cast.pos.x - cast.origin.x, 2) +
    Math.pow(cast.pos.z - cast.origin.z, 2)
  );
  
  // Exceeded range if beyond max range
  return dist > maxRange;
}

/**
 * Handle a new cast request from a player
 */
export function handleCastRequest(
  player: Player, 
  casterId: string,
  skillId: SkillId,
  targetPos: VecXZ | undefined,
  targetId: string | undefined,
  io: Server, 
  world: World
): string | Cast['castId'] {
  const now = Date.now();
  const skill = SKILLS[skillId];
  
  if (!skill) {
    console.error(`[handleCastRequest] Invalid skill ID: ${skillId}`);
    return 'invalid';
  }
  
  console.log(`[handleCastRequest] Creating new cast: casterId=${casterId}, skillId=${skillId}, targetId=${targetId}, targetPos=${JSON.stringify(targetPos)}`);
  
  // Create a new Cast
  const newCast: Cast = {
    castId: nanoid(),
    casterId: casterId,
    skillId: skillId,
    state: CastStateEnum.Casting,
    origin: { x: player.position.x, z: player.position.z },
    startedAt: now,
    castTimeMs: skill.castMs || 0,
    targetId: targetId,
    targetPos: targetPos,
    pos: { x: player.position.x, z: player.position.z } // Start at origin
  };
  
  // Add special logging for fireball
  if (newCast.skillId === 'fireball') {
    console.log(`[SkillSystem] Created Fireball Cast: castId=${newCast.castId}, origin=(${newCast.origin.x.toFixed(2)}, ${newCast.origin.z.toFixed(2)}), targetPos=(${newCast.targetPos?.x.toFixed(2)}, ${newCast.targetPos?.z.toFixed(2)}), dir=(${newCast.dir?.x.toFixed(2)}, ${newCast.dir?.z.toFixed(2)})`);
  }
  
  // Calculate direction if projectile
  if (skill.projectile && (targetPos || targetId)) {
    let targetPosVec: VecXZ | undefined;
    
    if (targetPos) {
      targetPosVec = targetPos;
    } else if (targetId) {
      const target = world.getEnemyById(targetId);
      if (target) {
        targetPosVec = { x: target.position.x, z: target.position.z };
      }
    }
    
    if (targetPosVec) {
      // Calculate direction
      const dx = targetPosVec.x - newCast.origin.x;
      const dz = targetPosVec.z - newCast.origin.z;
      const dist = Math.sqrt(dx * dx + dz * dz);
      
      // Set direction and speed
      if (dist > 0) {
        newCast.dir = { x: dx / dist, z: dz / dist };
        newCast.speed = skill.projectile.speed;
        console.log(`[handleCastRequest] Set projectile direction: [${newCast.dir.x.toFixed(2)}, ${newCast.dir.z.toFixed(2)}], speed: ${newCast.speed}`);
      }
    }
  }
  
  // Add to active casts
  activeCasts.push(newCast);
  console.log(`[handleCastRequest] Added to activeCasts. Total active casts: ${activeCasts.length}`);
  
  // Broadcast initial cast snapshot
  const snapshot = makeSnapshot(newCast);
  console.log(`[handleCastRequest] Broadcasting initial CastSnapshot: ${JSON.stringify(snapshot)}`);
  
  // Add special logging for fireball snapshots
  if (snapshot.skillId === 'fireball') {
    console.log(`[SkillSystem] Broadcasting initial Fireball CastSnapshot (Casting): ${JSON.stringify(snapshot)}`);
  }
  
  io.emit('msg', {
    type: 'CastSnapshot',
    data: snapshot
  });
  
  // Set player UI info
  if (player) {
    player.castingSkill = skillId;
    player.castingProgressMs = 0;
    
    // Also broadcast the player's updated casting state
    console.log(`[handleCastRequest] Broadcasting playerUpdated with castingSkill=${skillId}, castingProgressMs=0`);
    io.emit('playerUpdated', {
      id: player.id,
      mana: player.mana,
      skillCooldownEndTs: player.skillCooldownEndTs,
      castingSkill: player.castingSkill,
      castingProgressMs: player.castingProgressMs
    });
  }
  
  return newCast.castId;
}

/**
 * Get an existing cast by ID
 */
export function getCastById(castId: string): Cast | undefined {
  return activeCasts.find(cast => cast.castId === castId);
}

/**
 * Updates and progresses active casts, transitions them between states
 * Fully implemented server-authoritative state machine
 */
export function tickCasts(dt: number, io: Server, world: World): void {
  const now = Date.now();
  const lastTickMs = now - dt;
  
  // Log active casts periodically (once every 10 seconds) to avoid flooding
  if (Math.random() < 0.01) { // roughly 1% chance on each tick
    console.log(`[tickCasts] Active casts: ${activeCasts.length}`);
    activeCasts.forEach(cast => {
      console.log(`[tickCasts] Cast state: castId=${cast.castId}, casterId=${cast.casterId}, skillId=${cast.skillId}, state=${cast.state}, elapsed=${now - cast.startedAt}ms`);
    });
  }
  
  for (let i = activeCasts.length - 1; i >= 0; i--) {
    const cast = activeCasts[i];
    
    // Skip casts that are already in their final state and remove after delay
    if (cast.state === CastStateEnum.Impact) {
      // Remove completed casts after a delay
      if (now - cast.startedAt > 5000) { // 5 seconds after cast started
        console.log(`[tickCasts] Removing completed cast: castId=${cast.castId}, skillId=${cast.skillId}`);
        activeCasts.splice(i, 1);
      }
      continue;
    }
    
    // Check if cast time is complete for casts in Casting state
    if (cast.state === CastStateEnum.Casting && now - cast.startedAt >= cast.castTimeMs) {
      const skill = SKILLS[cast.skillId];
      const newState = skill.projectile ? CastStateEnum.Traveling : CastStateEnum.Impact;
      console.log(`[tickCasts] Cast complete, transitioning from Casting to ${newState}: castId=${cast.castId}, skillId=${cast.skillId}, casterId=${cast.casterId}`);
      
      // Special logging for fireball transitions
      if (cast.skillId === 'fireball') {
        console.log(`[SkillSystem] Fireball Cast ${cast.castId} transitioning to ${newState}. Snapshot: ${JSON.stringify(makeSnapshot(cast))}`);
      }
      
      cast.state = newState;
      
      // Clear the player's casting state when casting is complete
      const player = world.getPlayerById(cast.casterId);
      if (player) {
        player.castingSkill = null;
        player.castingProgressMs = 0;
        
        // Broadcast that casting has finished for this player
        console.log(`[tickCasts] Broadcasting playerUpdated with null castingSkill for player: ${cast.casterId}`);
        io.emit('playerUpdated', {
          id: player.id,
          castingSkill: player.castingSkill,
          castingProgressMs: player.castingProgressMs
        });
      }
      
      // Broadcast state change
      const snapshot = makeSnapshot(cast);
      console.log(`[tickCasts] Broadcasting CastSnapshot for state change: ${JSON.stringify(snapshot)}`);
      io.emit('msg', {
        type: 'CastSnapshot',
        data: snapshot
      });
      
      // If instant skill, resolve impact immediately
      if (cast.state === CastStateEnum.Impact) {
        console.log(`[tickCasts] Resolving impact immediately for instant skill: castId=${cast.castId}, skillId=${cast.skillId}`);
        resolveImpact(cast, io, world);
      }
      continue;
    }
    
    // Update traveling projectiles
    if (cast.state === CastStateEnum.Traveling) {
      const dtSeconds = (now - lastTickMs) / 1000; // deltaTime for this tick in seconds
      
      // Make sure we have position and direction
      if (cast.pos && cast.dir && cast.speed) {
        // Store old position for swept hit detection
        const oldPos = { ...cast.pos };
        
        // Update position based on velocity and time
        cast.pos.x += cast.dir.x * cast.speed * dtSeconds;
        cast.pos.z += cast.dir.z * cast.speed * dtSeconds;
        
        // Broadcast position updates periodically
        if (!cast.lastBroadcast || now - cast.lastBroadcast > CAST_BROADCAST_RATE) {
          const snapshot = makeSnapshot(cast);
          console.log(`[tickCasts] Broadcasting projectile position update: castId=${cast.castId}, pos=[${cast.pos.x.toFixed(2)}, ${cast.pos.z.toFixed(2)}], moved=${Math.sqrt(Math.pow(cast.pos.x - oldPos.x, 2) + Math.pow(cast.pos.z - oldPos.z, 2)).toFixed(2)}m`);
          
          // Special logging for fireball position updates
          if (cast.skillId === 'fireball') {
            console.log(`[SkillSystem] Broadcasting Fireball position update (Traveling): castId=${cast.castId}, pos=(${snapshot.pos?.x.toFixed(2)}, ${snapshot.pos?.z.toFixed(2)})`);
          }
          
          io.emit('msg', {
            type: 'CastSnapshot',
            data: snapshot
          });
          cast.lastBroadcast = now;
        }
        
        // --- ENHANCED HIT DETECTION LOGIC ---
        const skill = SKILLS[cast.skillId];
        const hitRadius = skill.projectile?.hitRadius || 0.5; // Use configured hit radius
        let hasHitSomething = false;

        // Check against all potential targets (enemies, other players if PvP)
        const potentialTargets = world.getEntitiesInCircle(cast.pos, hitRadius * 2); // Query a slightly larger area

        for (const entity of potentialTargets) {
          if (entity.id === cast.casterId || !entity.isAlive) continue; // Skip caster and dead entities

          // Check if this entity is an enemy (or valid target type)
          if (world.getEnemyById(entity.id)) { // Example: only hit enemies
            const entityPos = { x: entity.position.x, z: entity.position.z };
            
            // Use sweptHit for more reliable collision detection
            if (sweptHit(oldPos, cast.pos, entityPos, hitRadius)) {
              console.log(`[SkillSystem TickCasts] Projectile ${cast.castId} HIT entity ${entity.id} via sweptHit.`);
              cast.targetId = entity.id; // Update targetId to the actual hit entity
              cast.targetPos = entityPos; // Update targetPos to the hit location
              hasHitSomething = true;
              break; // Stop checking after first hit (unless it's a piercing projectile)
            }
          }
        }
        
        // Calculate distance from origin for range check
        const maxRange = skill.range || 50; // Default max range
        const distanceFromOrigin = Math.sqrt(
          Math.pow(cast.pos.x - cast.origin.x, 2) +
          Math.pow(cast.pos.z - cast.origin.z, 2)
        );

        // Check if projectile reached target, exceeded range, or hit something
        if (reachedTarget(cast) || distanceFromOrigin > maxRange || hasHitSomething) {
          if (distanceFromOrigin > maxRange) {
            console.log(`[SkillSystem TickCasts] Projectile ${cast.castId} exceeded max range (${distanceFromOrigin.toFixed(2)} > ${maxRange}).`);
          } else if (reachedTarget(cast)) {
            console.log(`[SkillSystem TickCasts] Projectile ${cast.castId} reached its initial target position.`);
          } else if (hasHitSomething) {
            console.log(`[SkillSystem TickCasts] Projectile ${cast.castId} hit a target.`);
          }
          
          cast.state = CastStateEnum.Impact;
          const snapshot = makeSnapshot(cast);
          io.emit('msg', {
            type: 'CastSnapshot',
            data: snapshot
          });
          resolveImpact(cast, io, world); // Resolve impact with the actual hit target(s)
        }
      } else {
        console.warn(`[tickCasts] Missing projectile data for traveling cast: castId=${cast.castId}, pos=${!!cast.pos}, dir=${!!cast.dir}, speed=${cast.speed}`);
      }
    }
  }
}

/**
 * Send snapshots of all active casts to a new client
 * @param client - Socket.IO socket or server instance to send snapshots to
 */
export function sendCastSnapshots(client: any): void {
  // Send all active casts to the client
  for (const cast of activeCasts) {
    client.emit('msg', {
      type: 'CastSnapshot',
      data: makeSnapshot(cast)
    });
  }
}

/**
 * Cancel an active cast
 */
export function cancelCast(casterId: string, skillId?: SkillId): boolean {
  const index = activeCasts.findIndex(cast => 
    cast.casterId === casterId && 
    (skillId ? cast.skillId === skillId : true) &&
    cast.state === CastStateEnum.Casting // Can only cancel during casting
  );
  
  if (index >= 0) {
    activeCasts.splice(index, 1);
    return true;
  }
  
  return false;
}

/**
 * Get all active casts
 */
export function getActiveCasts(): Cast[] {
  return [...activeCasts];
}


// ==============================================================================
// FILE: server/combat/utils/cast.ts
// ==============================================================================

import { PlayerState, Enemy } from '../../../shared/types.js';
import { VecXZ } from '../../../shared/messages.js';
import { SKILLS, SkillId } from '../../../shared/skillsDefinition.js';

/**
 * Calculate distance between two points
 */
function distance(a: VecXZ, b: VecXZ): number {
  const dx = a.x - b.x;
  const dz = a.z - b.z;
  return Math.sqrt(dx * dx + dz * dz);
}

/**
 * Check if a skill can be cast
 * Returns detailed cast validation result
 */
export function canCast(
  caster: PlayerState,
  skill: { id: SkillId, range: number },
  target?: Enemy | null,
  targetPos?: VecXZ,
  timestamp: number = Date.now()
): { canCast: boolean; reason?: 'cooldown' | 'nomana' | 'invalid' | 'outofrange' } {
  const skillId = skill.id;
  const skillDef = SKILLS[skillId];
  
  console.log(`canCast check for ${skillId}: player=${caster?.id || 'unknown'}, target=${target?.id || 'none'}, targetPos=${JSON.stringify(targetPos || 'none')}`);
  
  // Validate skill exists
  if (!skillDef) {
    console.log(`Cast failed: Skill ${skillId} not found in definitions`);
    return { canCast: false, reason: 'invalid' };
  }
  
  // Check if caster is alive
  if (!caster.isAlive) {
    console.log(`Cast failed: Caster is not alive`);
    return { canCast: false, reason: 'invalid' };
  }
  
  // Check mana cost
  if (skillDef.manaCost && caster.mana < skillDef.manaCost) {
    console.log(`Cast failed: Not enough mana (have ${caster.mana}, need ${skillDef.manaCost})`);
    return { canCast: false, reason: 'nomana' };
  }
  
  // Check if skill is on cooldown
  const cooldownEnd = caster.skillCooldownEndTs?.[skillId] || 0;
  if (timestamp < cooldownEnd) {
    console.log(`Cast failed: Skill on cooldown until ${new Date(cooldownEnd).toISOString()}`);
    return { canCast: false, reason: 'cooldown' };
  }
  
  // Validate targeting requirements
  if (skillDef.requiresTarget && !target) {
    return { canCast: false, reason: 'invalid' };
  }
  
  // Check target range if a target position is provided
  if (targetPos && skill.range) {
    const dist = distance(
      { x: caster.position.x, z: caster.position.z },
      targetPos
    );
    
    if (dist > skill.range) {
      return { canCast: false, reason: 'outofrange' };
    }
  }
  
  // Check target range if a target is provided
  if (target && skill.range) {
    const dist = distance(
      { x: caster.position.x, z: caster.position.z },
      { x: target.position.x, z: target.position.z }
    );
    
    if (dist > skill.range) {
      return { canCast: false, reason: 'outofrange' };
    }
  }
  
  // All checks passed
  console.log(`Cast check passed for skill ${skillId}`);
  return { canCast: true };
}

/**
 * Apply mana cost and cooldown for a skill cast
 * Returns the updated player object
 */
export function applyCastCost(player: PlayerState, skillId: SkillId): PlayerState {
  const skill = SKILLS[skillId];
  if (!skill) return player;
  
  const now = Date.now();
  const updatedPlayer = { ...player };
  
  // Apply mana cost
  if (skill.manaCost) {
    updatedPlayer.mana = Math.max(0, player.mana - skill.manaCost);
  }
  
  // Apply cooldown
  if (skill.cooldownMs) {
    const cooldownEndTime = now + skill.cooldownMs;
    updatedPlayer.skillCooldownEndTs = {
      ...(updatedPlayer.skillCooldownEndTs || {}),
      [skillId]: cooldownEndTime
    };
  }
  
  return updatedPlayer;
}


// ==============================================================================
// FILE: server/combat/worldLoop.ts
// ==============================================================================

import { Server } from 'socket.io';
import { tickCasts, sendCastSnapshots } from './skillSystem.js';  // New skill system
import { broadcastSnaps } from '../world.js';
import { VecXZ } from '../../shared/messages.js';

// Game state reference
let gameState: any = null;
let isRunning = false;
let loopInterval: NodeJS.Timeout | null = null;
let updateProjectilesLegacy: ((gameState: any, deltaTime: number) => void) | null = null;

// Track time
let lastTime = Date.now();
let lastSnapBroadcastTime = Date.now();
let lastCastSnapshotTime = Date.now();

// Reference to IO server
let ioServer: Server | null = null;

// World interface implementation
const world = {
  getEnemyById: (id: string) => {
    if (!gameState || !gameState.enemies) return null;
    return gameState.enemies[id] || null;
  },
  
  getPlayerById: (id: string) => {
    if (!gameState || !gameState.players) return null;
    return gameState.players[id] || null;
  },
  
  getEntitiesInCircle: (pos: VecXZ, radius: number) => {
    const result: any[] = [];
    
    // Check enemies
    if (gameState && gameState.enemies) {
      for (const enemyId in gameState.enemies) {
        const enemy = gameState.enemies[enemyId];
        if (!enemy.isAlive) continue;
        
        const dx = enemy.position.x - pos.x;
        const dz = enemy.position.z - pos.z;
        const distSq = dx * dx + dz * dz;
        
        if (distSq <= radius * radius) {
          result.push(enemy);
        }
      }
    }
    
    // Check players (for PvP if enabled)
    if (gameState && gameState.players) {
      for (const playerId in gameState.players) {
        const player = gameState.players[playerId];
        if (!player.isAlive) continue;
        
        const dx = player.position.x - pos.x;
        const dz = player.position.z - pos.z;
        const distSq = dx * dx + dz * dz;
        
        if (distSq <= radius * radius) {
          result.push(player);
        }
      }
    }
    
    return result;
  }
};

/**
 * The main game tick function that updates all game entities
 */
function gameTick() {
  const now = Date.now();
  const deltaTime = now - lastTime;
  lastTime = now;
  
  // Apply movement to players based on their velocities
  if (gameState?.players) {
    applyMovement(gameState.players, deltaTime);
  }
  
  // Process skills with the new skill system
  if (ioServer) {
    // Process the skill state machine
    tickCasts(deltaTime, ioServer, world);
    
    // Send cast snapshots to clients on a regular interval (20 Hz)
    if (now - lastCastSnapshotTime >= 50) {
      sendCastSnapshots(ioServer);
      lastCastSnapshotTime = now;
    }
  }
  
  // Run existing projectile system (legacy mode) if it exists
  // This ensures both systems run side by side during transition
  if (updateProjectilesLegacy && typeof updateProjectilesLegacy === 'function' && gameState) {
    updateProjectilesLegacy(gameState, deltaTime / 1000);
  }
  
  // Broadcast position snapshots at 10 Hz (every 100ms)
  if (ioServer && gameState && now - lastSnapBroadcastTime >= 100) {
    // Call the broadcastSnaps function from world.ts
    if (typeof broadcastSnaps === 'function') {
      broadcastSnaps(ioServer, gameState);
      lastSnapBroadcastTime = now;
    }
  }
}

/**
 * Applies movement updates to player entities based on their velocity
 */
function applyMovement(players: Record<string, any>, deltaTimeMs: number) {
  if (!players) return;
  
  const now = Date.now();
  const dt = deltaTimeMs / 1000; // Convert to seconds
  
  for (const player of Object.values(players)) {
    if (!player.movement?.isMoving) continue;
    
    // Apply velocity to position
    if (player.velocity) {
      player.position.x += player.velocity.x * dt;
      player.position.z += player.velocity.z * dt;
      
      // Check if we've reached the target position
      if (player.movement.targetPos) {
        const distance = Math.sqrt(
          Math.pow(player.position.x - player.movement.targetPos.x, 2) +
          Math.pow(player.position.z - player.movement.targetPos.z, 2)
        );
        
        // If close enough to target, stop moving
        if (distance < 0.1) {
          player.movement.isMoving = false;
          player.velocity = { x: 0, z: 0 };
        }
      }
      
      player.movement.lastUpdateTime = now;
    }
  }
}

/**
 * Start the game loop
 * @param tickRateMs How often to run the game loop in milliseconds
 */
export function startWorldLoop(
  io: Server, 
  state: any, 
  updateProjectilesFn?: ((gameState: any, deltaTime: number) => void) | null,
  tickRateMs: number = 50 // Default to 20 ticks per second
) {
  // Store references
  ioServer = io;
  gameState = state;
  updateProjectilesLegacy = updateProjectilesFn || null;
  
  // Initialize time
  lastTime = Date.now();
  lastCastSnapshotTime = Date.now();
  lastSnapBroadcastTime = Date.now();
  
  // Start the loop if not already running
  if (!isRunning) {
    isRunning = true;
    
    // Clear any existing interval
    if (loopInterval) {
      clearInterval(loopInterval);
    }
    
    // Start the new interval
    loopInterval = setInterval(gameTick, tickRateMs);
    console.log(`World loop started with new server-authoritative skill system, tick rate: ${tickRateMs}ms`);
  }
}

/**
 * Stop the game loop
 */
export function stopWorldLoop() {
  if (isRunning && loopInterval) {
    clearInterval(loopInterval);
    loopInterval = null;
    isRunning = false;
    console.log('World loop stopped');
  }
}

/**
 * Update the game state reference
 */
export function updateGameState(newState: any) {
  gameState = newState;
}

/**
 * Check if the world loop is currently running
 */
export function isWorldLoopRunning(): boolean {
  return isRunning;
}


// ==============================================================================
// FILE: server/effects/entities.ts
// ==============================================================================

import { SkillDef } from '../../shared/skillsDefinition';
import { VecXZ, InstantHit, ProjHit2 } from '../../shared/messages';
import { getDamage, hash } from '../../shared/combatMath';
import { v4 as uuid } from 'uuid';

// Define a simplified GameState interface for use in this file
interface GameState {
  enemies: Record<string, any>;
  players: Record<string, any>;
}

export interface EffectEntity {
  id: string;
  skill: SkillDef;
  done: boolean;
  update(dt: number, state: GameState): (ProjHit2 | InstantHit)[];
}

/* ---- Projectile ---------- */
export class Projectile implements EffectEntity {
  id = uuid();
  done = false;
  constructor(
     public skill: SkillDef,
     public pos: VecXZ & {y:number},
     public dir: VecXZ & {y:number},
     public casterId: string,
     public targetId?: string)
  {}
  update(dt: number, state: GameState): ProjHit2[]{
     if(this.done) return [];
     
     // Use the standardized projectile speed from the skill definition
     const speed = this.skill.projectile?.speed || this.skill.speed || 0;
     this.pos.x += this.dir.x * speed * dt;
     this.pos.y += this.dir.y * speed * dt;
     this.pos.z += this.dir.z * speed * dt;
     
     /* hit check vs targetId (later broaden) */
     const hitMsgs: ProjHit2[] = [];
     if(this.targetId) {
        const t = state.enemies[this.targetId] || state.players[this.targetId];
        // Use the hitRadius from the projectile definition if available
        const hitRadius = this.skill.projectile?.hitRadius || 0.5;
        if(t && distanceXZ(this.pos, t.position) <= hitRadius) {
            this.done = true;
            
            // Add casterId to skill for XP calculation
            const skillWithCaster = {...this.skill, casterId: this.casterId};
            
            // Calculate damage using the shared function
            const { dmg } = getDamage({
              caster: state.players[this.casterId]?.stats || { dmgMult: 1 },
              skill: { base: this.skill.dmg || 10, variance: 0.1 },
              seed: `${this.id}:${t.id}`
            });
            
            // Apply the damage using our pre-calculated value
            applySkillDamage(skillWithCaster, t, state, dmg);
            
            hitMsgs.push({
              type: 'ProjHit2', 
              castId: this.id, 
              hitIds: [t.id], 
              dmg: [dmg],
              impactPos: { x: this.pos.x, z: this.pos.z }
            });
        }
     }
     return hitMsgs;
  }
}

/* ---- Instant ---------- */
export class Instant implements EffectEntity {
  id = uuid();
  done = false;
  constructor(public skill: SkillDef,
              public casterId: string,
              public targetIds: string[],
              public origin: {x: number; y: number; z: number}) {}
  
  update(dt: number, state: GameState): InstantHit[] {
     if(this.done) return [];
     this.done = true;
     
     /* immediately apply damage and effects to targets */
     const damageResults: number[] = [];
     
     for (const targetId of this.targetIds) {
       const target = state.enemies[targetId] || state.players[targetId];
       if (target) {
         // Add casterId to skill for XP calculation
         const skillWithCaster = {...this.skill, casterId: this.casterId};
         
         // Calculate damage using the shared function
         const { dmg } = getDamage({
           caster: state.players[this.casterId]?.stats || { dmgMult: 1 },
           skill: { base: this.skill.dmg || 10, variance: 0.1 },
           seed: `${this.id}:${targetId}`
         });
         
         damageResults.push(dmg);
         
         // Pass the pre-calculated damage to applySkillDamage
         applySkillDamage(skillWithCaster, target, state, dmg);
       } else {
         damageResults.push(0); // No damage for non-existent targets
       }
     }
     
     return [{
       type: 'InstantHit',
       skillId: this.skill.id,
       origin: this.origin,
       targetPos: this.origin,
       hitIds: this.targetIds,
       dmg: damageResults
     }];
  }
}

/* Helper functions */
export function distanceXZ(a: VecXZ, b: VecXZ): number {
  const dx = a.x - b.x;
  const dz = a.z - b.z;
  return Math.sqrt(dx * dx + dz * dz);
}

export function applySkillDamage(skill: any, target: any, state: GameState, precalculatedDmg?: number) {
  // Apply all effects from the skill
  const now = Date.now();
  
  // Use precalculated damage if provided, otherwise calculate it
  let dmgToApply: number;
  if (precalculatedDmg !== undefined) {
    dmgToApply = precalculatedDmg;
  } else {
    // Get damage using the shared damage calculation
    const { dmg } = getDamage({
      caster: state.players[skill.casterId]?.stats || { dmgMult: 1 },
      skill: { base: skill.effects?.find(e => e.type === 'damage')?.value || skill.dmg || 10, variance: 0.1 },
      seed: `${skill.id || ''}:${target.id || ''}`
    });
    dmgToApply = dmg;
  }
  
  // Process all skill effects
  for (const effect of skill.effects) {
    if (effect.type === 'damage') {
      // Apply damage from our calculation instead of the literal value
      target.health -= dmgToApply;
      if (target.health <= 0) {
        target.health = 0;
        target.isAlive = false;
        target.deathTimeTs = now;
        
        // Clear target if this is an enemy
        if (target.targetId !== undefined) {
          target.targetId = null;
        }
        
        // If this is an enemy, grant XP to the player who killed it
        if (state.players && skill.casterId) {
          const killer = state.players[skill.casterId];
          if (killer && target.experienceValue) {
            killer.experience += target.experienceValue;
            
            // Check for level up
            while (killer.experience >= killer.experienceToNextLevel) {
              killer.level++;
              killer.experience -= killer.experienceToNextLevel;
              killer.experienceToNextLevel = Math.floor(killer.experienceToNextLevel * 1.5);
              killer.maxHealth += 20;
              killer.health = killer.maxHealth;
              killer.maxMana += 10;
              killer.mana = killer.maxMana;
            }
          }
        }
      }
    } else {
      // Apply status effect
      const effectId = `effect-${hash(`${effect.type}-${now}`)}`;
      const statusEffect = {
        id: effectId,
        type: effect.type,
        value: effect.value,
        durationMs: effect.durationMs || 0,
        startTimeTs: now,
        sourceSkill: skill.id
      };
      
      const existingEffectIndex = target.statusEffects.findIndex((e: any) => e.type === effect.type);
      if (existingEffectIndex >= 0) {
        target.statusEffects[existingEffectIndex] = statusEffect;
      } else {
        target.statusEffects.push(statusEffect);
      }
    }
  }
}


// ==============================================================================
// FILE: server/effects/manager.ts
// ==============================================================================

import { EffectEntity, Projectile, Instant } from './entities';
import { SKILLS, SkillId } from '../../shared/skillsDefinition';
import { ProjSpawn2} from '../../shared/messages';

import { Server } from 'socket.io';

// Define a simplified GameState interface to match our usage
interface GameState {
  enemies: Record<string, any>;
  players: Record<string, any>;
  [key: string]: any;
}

export class EffectManager {
  private effects: Record<string, EffectEntity> = {};
  
  constructor(
    private io: Server,
    private state: GameState
  ) {}
  
  spawnProjectile(skillId: SkillId, caster, dir, targetId?) {
      const skill = SKILLS[skillId];
      if (!skill) return null;
      
      const origin = {...caster.position, y: 1.5};
      const p = new Projectile(skill, origin, dir, caster.id, targetId);
      this.effects[p.id] = p;
      
      // Calculate travel time for the projectile if we have a target
      let travelMs;
      if (targetId) {
          const target = this.state.enemies[targetId] || this.state.players[targetId];
          if (target) {
              const dist = Math.sqrt(
                  Math.pow(target.position.x - origin.x, 2) +
                  Math.pow(target.position.z - origin.z, 2)
              );
              const speedMPS = skill.projectile?.speed || skill.speed || 0;
              const speedMPMS = speedMPS / 1000;
              travelMs = Math.ceil(dist / speedMPMS);
          }
      }
      
      // Emit enhanced projectile spawn event
      this.io.emit('msg', {
        type: 'ProjSpawn2',
        castId: p.id, 
        skillId: skillId, 
        origin: { x: origin.x, z: origin.z }, 
        dir: { x: dir.x, z: dir.z }, 
        speed: skill.projectile?.speed || skill.speed || 0, 
        launchTs: Date.now(),
        casterId: caster.id,
        hitRadius: skill.projectile?.hitRadius || 0.5,
        travelMs: travelMs
      } as ProjSpawn2);
      
      return p.id;
  }
  
  spawnInstant(skillId: SkillId, caster, targetIds) {
      const skill = SKILLS[skillId];
      if (!skill) return null;
      
      const inst = new Instant(skill, caster.id, targetIds, {...caster.position, y: 1.5});
      this.effects[inst.id] = inst;
      return inst.id;
  }
  
  updateAll(dt) {
      const updatedEnemies = new Set<string>();
      const updatedPlayers = new Set<string>();
      
      for(const id in this.effects) {
          const e = this.effects[id];
          const msgs = e.update(dt, this.state);
          
          // Collect IDs of targets that got hit
          msgs.forEach(m => {
              this.io.emit('msg', m);
              
              // Track which entities need updates
              if (m.type === 'ProjHit2' || m.type === 'InstantHit') {
                  (m.hitIds || []).forEach(hitId => {
                      if (this.state.enemies[hitId]) {
                          updatedEnemies.add(hitId);
                      } else if (this.state.players[hitId]) {
                          updatedPlayers.add(hitId);
                      }
                  });
              }
          });
          
          if(e.done) {
              delete this.effects[id];
              // No need to emit ProjEnd - the new protocol handles this through state transitions
          }
      }
      
      // Send updates for all affected entities
      updatedEnemies.forEach(enemyId => {
          this.io.emit('enemyUpdated', this.state.enemies[enemyId]);
      });
      
      updatedPlayers.forEach(playerId => {
          this.io.emit('playerUpdated', this.state.players[playerId]);
      });
  }
}


// ==============================================================================
// FILE: server/logger.ts
// ==============================================================================

// filepath: /home/s/develop/projects/vibe/1/server/logger.ts
// Simple logger module to replace console.log with more controlled debugging

// Set to true to enable debug logs, false to disable them
export const DEBUG = process.env.NODE_ENV !== 'production';

// Define different log categories
export const LOG_CATEGORIES = {
  COLLISION: 'collision',
  PROJECTILE: 'projectile',
  MOVEMENT: 'movement',
  DAMAGE: 'damage',
  MANA: 'mana',
  HEALING: 'healing',
  ENEMY: 'enemy',
  PLAYER: 'player',
  SKILL: 'skill',
  NETWORK: 'network',
  SYSTEM: 'system'
};

// Set which categories to enable when DEBUG is true
const ENABLED_CATEGORIES = [
  //LOG_CATEGORIES.COLLISION,
  // LOG_CATEGORIES.PROJECTILE, // Disabled to reduce log spam
  LOG_CATEGORIES.DAMAGE,
  LOG_CATEGORIES.ENEMY,
  LOG_CATEGORIES.PLAYER,
  LOG_CATEGORIES.SKILL,
  LOG_CATEGORIES.NETWORK,
  LOG_CATEGORIES.SYSTEM
];

/**
 * Logs a message if debugging is enabled and the category is enabled
 * @param category The log category
 * @param message The message to log
 * @param args Optional additional args to log
 */
export function log(category: string, message: string, ...args: any[]) {
  if (DEBUG && ENABLED_CATEGORIES.includes(category)) {
    console.log(`[${category.toUpperCase()}] ${message}`, ...args);
  }
}

/**
 * Logs a warning message
 * @param category The log category
 * @param message The message to log
 * @param args Optional additional args to log
 */
export function warn(category: string, message: string, ...args: any[]) {
  console.warn(`[${category.toUpperCase()}] WARNING: ${message}`, ...args);
}

/**
 * Logs an error message
 * @param category The log category
 * @param message The message to log
 * @param args Optional additional args to log
 */
export function error(category: string, message: string, ...args: any[]) {
  console.error(`[${category.toUpperCase()}] ERROR: ${message}`, ...args);
}


// ==============================================================================
// FILE: server/onMoveIntent.ts
// ==============================================================================

/**
 * Handles MoveIntent messages from clients requesting to move to a target position
 * This replaces the old MoveStart handler in the server-authoritative movement system
 */
function onMoveIntent(socket: Socket, state: GameState, msg: MoveIntent): void {
  const playerId = msg.id;
  const player = state.players[playerId];
  
  // Verify player exists and belongs to this socket
  if (!player || player.socketId !== socket.id) {
    console.warn(`Invalid player ID or wrong socket for MoveIntent: ${playerId}`);
    return;
  }
  
  // Implement a cast-lock window to prevent "micro-teleport" exploits
  const now = Date.now();
  if (player.lastUpdateTime && now - player.lastUpdateTime < 33) { // 33ms = ~1 tick at 30 FPS
    console.warn(`Movement request from player ${playerId} received too quickly, enforcing cast-lock window`);
    // Still process the request but apply a slight delay (server-side)
  }
  
  // Validate the target position is within reasonable bounds
  if (!isValidPosition(msg.targetPos)) {
    console.warn(`Invalid target position in MoveIntent from player ${playerId}: ${JSON.stringify(msg.targetPos)}`);
    return;
  }

  // Get current position
  const currentPos = { x: player.position.x, z: player.position.z };
  
  // Calculate distance to target
  const distance = Math.sqrt(
    Math.pow(currentPos.x - msg.targetPos.x, 2) +
    Math.pow(currentPos.z - msg.targetPos.z, 2)
  );
  
  // Check if this is a stop command (targetPos same as current position)
  if (distance < 0.05) {
    // This is a stop command - immediately halt the player
    player.movement = { 
      isMoving: false, 
      lastUpdateTime: now 
    };
    player.velocity = { x: 0, z: 0 };
    
    // Create a position snapshot for the stop command
    const stopSnapMsg = {
      type: 'PosSnap',
      snaps: [{
        id: playerId,
        pos: currentPos,
        vel: { x: 0, z: 0 },
        snapTs: now
      }]
    };
    
    // Send to the requesting client
    socket.emit('msg', stopSnapMsg);
    
    // Also broadcast to other players
    socket.broadcast.emit('msg', stopSnapMsg);
    
    return;
  }
  
  // Limit maximum teleport distance - if move request is too far, cap it
  const MAX_MOVE_DISTANCE = 30; // Maximum allowed movement distance in units
  let finalTargetPos = { ...msg.targetPos };
  
  if (distance > MAX_MOVE_DISTANCE) {
    console.warn(`Movement request from player ${playerId} exceeds maximum allowed distance: ${distance.toFixed(2)} units`);
    
    // Cap the distance while maintaining the direction
    const dirToTarget = calculateDir(currentPos, msg.targetPos);
    finalTargetPos = {
      x: currentPos.x + dirToTarget.x * MAX_MOVE_DISTANCE,
      z: currentPos.z + dirToTarget.z * MAX_MOVE_DISTANCE
    };
    
    console.log(`Capped movement at distance ${MAX_MOVE_DISTANCE} units in direction (${dirToTarget.x.toFixed(2)}, ${dirToTarget.z.toFixed(2)})`);
  }
  
  // Calculate direction and determine speed (now server-controlled)
  const dir = calculateDir(currentPos, finalTargetPos);
  
  // Determine server-authorized speed (can vary based on player stats, buffs, etc.)
  const speed = getPlayerSpeed(player); // Server decides the speed
  
  // Update player's movement state
  player.movement = {
    ...player.movement,
    isMoving: true,
    targetPos: finalTargetPos,
    lastUpdateTime: now,
    speed: speed
  };
  
  // Set velocity for movement simulation
  player.velocity = {
    x: dir.x * speed,
    z: dir.z * speed
  };
  
  // Update last processed time
  player.lastUpdateTime = now;
  
  // Create a position snapshot message
  const posSnapMsg = {
    type: 'PosSnap',
    snaps: [{
      id: playerId, 
      pos: currentPos,
      vel: player.velocity,
      snapTs: now
    }]
  };
  
  // Debug logging for position snapshots
  console.log(`Sending MoveIntent response PosSnap: ${JSON.stringify(posSnapMsg)}`);
  
  // Send position update back to the requesting client
  socket.emit('msg', posSnapMsg);
  
  // Also broadcast to other players
  socket.broadcast.emit('msg', posSnapMsg);
  
  // Log movement (debug level)
  log(LOG_CATEGORIES.MOVEMENT, 'debug', `Player ${playerId} moving to ${JSON.stringify(finalTargetPos)} at speed ${speed}`);
}


// ==============================================================================
// FILE: server/server.ts
// ==============================================================================

import { createServer } from 'node:http';
import { Server } from 'socket.io';
import { ZoneManager } from '../shared/zoneSystem.js';
import { initWorld } from './world.js';
import { startWorldLoop } from './combat/worldLoop.js';
import { sendCastSnapshots } from './combat/skillSystem.js';

// Create HTTP server
const httpServer = createServer();

// WebSocket compression config
const COMPRESSION = process.env.WS_COMPRESSION !== "0";

// Configure Socket.IO with improved settings
const io = new Server(httpServer, {
  cors: {
    origin: ["http://localhost:3000", "http://127.0.0.1:3000"],
    methods: ["GET", "POST"],
    credentials: true
  },
  transports: ['websocket'], // Prefer WebSocket only for better performance
  pingTimeout: 60000,
  pingInterval: 30000, // Increased to avoid conflict with our 30Hz update rate
  connectTimeout: 45000,
  allowEIO3: true,
  maxHttpBufferSize: 1e8,
  path: '/socket.io/',
  perMessageDeflate: COMPRESSION
    ? { threshold: 0 }          // Compress everything
    : false,                    // Easy kill-switch
  httpCompression: COMPRESSION
    ? { threshold: 0 }
    : false,
});

// Initialize zone manager
const zoneManager = new ZoneManager();

// Initialize game world with the IO instance and zone manager
const world = initWorld(io, zoneManager);

// Handle socket connections
io.on('connection', (socket) => {
  console.log('Client connected:', socket.id);

  // Handle player joining
  socket.on('joinGame', (playerName: string) => {
    console.log('Player joining:', playerName);
    
    // Add the player to the world
    const player = world.addPlayer(socket.id, playerName);
    
    // Send player ID to the client
    socket.emit('joinGame', { playerId: player.id });
    
    // Send full game state to the new player
    socket.emit('gameState', world.getGameState());
    
    // Send all active casts and projectiles to the new player
    sendCastSnapshots(socket);
    
    // Broadcast new player to others
    socket.broadcast.emit('playerJoined', player);
  });

  // Handle game state requests
  socket.on('requestGameState', () => {
    const gameState = world.getGameState();
    console.log('Client requested game state. Enemy count:', Object.keys(gameState.enemies).length);
    socket.emit('gameState', gameState);
  });

  // Handle new message format
  socket.on('msg', (message) => {
    world.handleMessage(socket, message);
  });

  // Legacy handlers - keep for backwards compatibility
  socket.on('moveStart', (message) => {
    console.log('Legacy moveStart received - should use msg type instead');
    // Convert to new format and pass to world
    const m = {
      type: 'MoveStart',
      id: message.id,
      path: [message.to],
      speed: message.speed,
      clientTs: message.ts
    };
    world.handleMessage(socket, m);
  });

  socket.on('moveStop', (message) => {
    console.log('Legacy moveStop received - should use MoveSync instead');
    // Convert to new format and pass to world
    const m = {
      type: 'MoveSync',
      id: message.id,
      pos: message.pos,
      clientTs: message.ts
    };
    world.handleMessage(socket, m);
  });

  socket.on('castSkillRequest', (data) => {
    console.log('Legacy castSkillRequest received - should use CastReq instead');
    // Convert to new format and pass to world
    const m = {
      type: 'CastReq',
      id: Object.keys(world.getGameState().players).find(
        id => world.getGameState().players[id].socketId === socket.id
      ) || '',
      skillId: data.skillId,
      targetId: data.targetId,
      clientTs: Date.now()
    };
    world.handleMessage(socket, m);
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('Client disconnected:', socket.id);
    
    // Remove the player from the world
    const playerId = world.removePlayerBySocketId(socket.id);
    
    if (playerId) {
      // Broadcast player removal to all clients
      io.emit('playerLeft', playerId);
    }
  });
});

// Error handling
process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
});

process.on('unhandledRejection', (error) => {
  console.error('Unhandled Rejection:', error);
});

// Start the server
const PORT = process.env.PORT || 3001;

console.log('Attempting to start game server...');

try {
  httpServer.listen(PORT, () => {
    console.log(`Game server running on port ${PORT}`);
    console.log(`Enemy count at startup: ${Object.keys(world.getGameState().enemies).length}`);
    console.log('Game zones:', zoneManager.getZones().map(zone => zone.name).join(', '));
    
    // Start the enhanced world loop with the game state
    console.log('Starting server-authoritative combat system...');
    startWorldLoop(io, world.getGameState(), undefined, 33); // ~30 ticks per second for better responsiveness
  });
} catch (error) {
  console.error('Failed to start server:', error);
  process.exit(1);
}


// ==============================================================================
// FILE: server/skillHandler.ts
// ==============================================================================

import { Socket } from 'socket.io';
import { LearnSkill, SetSkillShortcut } from '../shared/messages.js';
import { SkillId } from '../shared/skillsDefinition.js';

import { canPlayerLearnSkill, learnNewSkill, setSkillShortcut } from './skillManager.js';

// Define simplified types for what we need from the game state
interface Player {
  id: string;
  socketId: string;
  level: number;
  className: string;
  unlockedSkills: SkillId[];
  skillShortcuts: (SkillId | null)[];
  availableSkillPoints: number;
}

interface GameState {
  players: Record<string, Player>;
}

/**
 * Handle the LearnSkill message 
 */
export function onLearnSkill(socket: Socket, state: GameState, msg: LearnSkill): void {
  console.log(`[SKILL] Received LearnSkill request for skill: ${msg.skillId}`);
  
  // Get player by socket ID
  const playerId = Object.keys(state.players).find(
    id => state.players[id].socketId === socket.id
  );
  
  if (!playerId) {
    console.warn(`[SKILL] Learn skill request from unknown socket: ${socket.id}`);
    return;
  }
  
  const player = state.players[playerId];
  console.log(`[SKILL] Player ${playerId} info:`, {
    className: player.className,
    level: player.level,
    unlockedSkills: player.unlockedSkills,
    availableSkillPoints: player.availableSkillPoints
  });
  
  // Skip if player already has this skill
  if (player.unlockedSkills.includes(msg.skillId)) {
    console.log(`[SKILL] Player ${playerId} already has skill: ${msg.skillId}`);
    socket.emit('msg', {
      type: 'SkillLearned',
      skillId: msg.skillId,
      remainingPoints: player.availableSkillPoints
    });
    return;
  }
  
  // Validate player has skill points to spend
  if (player.availableSkillPoints <= 0) {
    console.warn(`[SKILL] Player ${playerId} has no skill points to learn ${msg.skillId}`);
    return;
  }
  
  // Check if player can learn this skill based on class and level requirements
  if (canPlayerLearnSkill(player, msg.skillId)) {
    // Learn the skill using skillManager function
    if (learnNewSkill(player, msg.skillId)) {
      console.log(`[SKILL] Player ${playerId} learned skill: ${msg.skillId}`);
      
      // Send notification to client
      socket.emit('msg', {
        type: 'SkillLearned',
        skillId: msg.skillId,
        remainingPoints: player.availableSkillPoints
      });
      
      // Broadcast player update to all clients
      socket.broadcast.emit('playerUpdated', {
        id: player.id,
        unlockedSkills: player.unlockedSkills,
        skillShortcuts: player.skillShortcuts,
        availableSkillPoints: player.availableSkillPoints
      });
    } else {
      console.warn(`[SKILL] Failed to learn skill ${msg.skillId} for player ${playerId}`);
    }
  } else {
    console.warn(`[SKILL] Player ${playerId} cannot learn skill: ${msg.skillId}`);
  }
}

/**
 * Handle the SetSkillShortcut message
 */
export function onSetSkillShortcut(socket: Socket, state: GameState, msg: SetSkillShortcut): void {
  console.log(`[SKILL] Received SetSkillShortcut request for slot ${msg.slotIndex}: ${msg.skillId}`);
  
  // Get player by socket ID
  const playerId = Object.keys(state.players).find(
    id => state.players[id].socketId === socket.id
  );
  
  if (!playerId) {
    console.warn(`[SKILL] Set skill shortcut request from unknown socket: ${socket.id}`);
    return;
  }
  
  const player = state.players[playerId];
  
  // Validate slot index is valid (0-8 for keys 1-9)
  if (msg.slotIndex < 0 || msg.slotIndex > 8) {
    console.warn(`[SKILL] Invalid shortcut slot index: ${msg.slotIndex}`);
    return;
  }
  
  // If clearing the slot, allow it
  if (msg.skillId === null) {
    if (setSkillShortcut(player, msg.slotIndex, null)) {
      console.log(`[SKILL] Player ${playerId} cleared shortcut slot ${msg.slotIndex}`);
      
      // Send confirmation to client
      socket.emit('msg', {
        type: 'SkillShortcutUpdated',
        slotIndex: msg.slotIndex,
        skillId: null
      });
      
      // Broadcast player update to all clients
      socket.broadcast.emit('playerUpdated', {
        id: player.id,
        skillShortcuts: player.skillShortcuts
      });
    }
    return;
  }
  
  // Validate skill is unlocked
  if (!player.unlockedSkills.includes(msg.skillId)) {
    console.warn(`[SKILL] Player ${playerId} tried to shortcut skill they don't have: ${msg.skillId}`);
    return;
  }
  
  // Update skill shortcut
  if (setSkillShortcut(player, msg.slotIndex, msg.skillId)) {
    console.log(`[SKILL] Player ${playerId} set shortcut slot ${msg.slotIndex} to skill: ${msg.skillId}`);
    
    // Send confirmation to client
    socket.emit('msg', {
      type: 'SkillShortcutUpdated',
      slotIndex: msg.slotIndex,
      skillId: msg.skillId
    });
    
    // Broadcast player update to all clients
    socket.broadcast.emit('playerUpdated', {
      id: player.id,
      skillShortcuts: player.skillShortcuts
    });
  } else {
    console.warn(`[SKILL] Failed to set shortcut for player ${playerId}`);
  }
}


// ==============================================================================
// FILE: server/skillManager.ts
// ==============================================================================

// filepath: /home/s/develop/projects/vibe/1/server/skillManager.ts

import { SkillId} from '../shared/skillsDefinition.js';
import { canLearnSkill, CharacterClass, CLASS_SKILL_TREES } from '../shared/classSystem.js';

// Define simplified types for what we need from the game state
interface Player {
  id: string;
  socketId: string;
  level: number;
  className: string;
  unlockedSkills: SkillId[];
  skillShortcuts: (SkillId | null)[];
  availableSkillPoints: number;
  // Other player properties omitted
}

/**
 * Check if a player can learn a specific skill
 */
export function canPlayerLearnSkill(player: Player, skillId: SkillId): boolean {
  // Check that player has skill points
  if (player.availableSkillPoints <= 0) {
    return false;
  }
  
  // Check if player already has this skill
  if (player.unlockedSkills.includes(skillId)) {
    return false;
  }
  
  // Use the shared check from classSystem
  return canLearnSkill(
    skillId,
    player.className as CharacterClass,
    player.level,
    player.unlockedSkills as SkillId[]
  );
}

/**
 * Learn a new skill for the player
 */
export function learnNewSkill(player: Player, skillId: SkillId): boolean {
  try {
    // Skip if player already has the skill
    if (player.unlockedSkills.includes(skillId)) {
      return true; // Not an error, just already learned
    }
    
    // Check if player can learn this skill
    if (!canPlayerLearnSkill(player, skillId)) {
      console.log(`[LEARN_SKILL] Player ${player.id} failed to learn ${skillId} - requirements not met`);
      return false;
    }

    // Add skill to unlocked skills
    const oldSkillPoints = player.availableSkillPoints;
    player.unlockedSkills.push(skillId);
    
    // Deduct a skill point
    player.availableSkillPoints -= 1;
    
    console.log(`[LEARN_SKILL] Player ${player.id} learned ${skillId}. Skill points: ${oldSkillPoints} -> ${player.availableSkillPoints}`);
    
    // Automatically assign to the first empty shortcut slot if available
    const emptySlotIndex = player.skillShortcuts.findIndex(slot => slot === null);
    if (emptySlotIndex !== -1) {
      player.skillShortcuts[emptySlotIndex] = skillId;
    }
    
    return true;
  } catch (error) {
    console.error(`Error learning skill ${skillId}:`, error);
    return false;
  }
}

/**
 * Set a skill shortcut
 */
export function setSkillShortcut(player: Player, slotIndex: number, skillId: SkillId | null): boolean {
  try {
    // Validate slot index is within range (0-8 for keys 1-9)
    if (slotIndex < 0 || slotIndex > 8) {
      return false;
    }
    
    // If skillId is provided, validate it's unlocked
    if (skillId !== null && !player.unlockedSkills.includes(skillId)) {
      return false;
    }
    
    // If we're trying to set a skill (not clearing a slot)
    if (skillId !== null) {
      // Check if this skill is already assigned to a different shortcut slot
      const existingIndex = player.skillShortcuts.findIndex(id => id === skillId);
      if (existingIndex !== -1 && existingIndex !== slotIndex) {
        // Remove it from the existing slot to prevent duplicates
        console.log(`Skill ${skillId} already exists in slot ${existingIndex + 1}, removing from that slot`);
        player.skillShortcuts[existingIndex] = null;
      }
    }
    
    // Update the shortcut slot
    player.skillShortcuts[slotIndex] = skillId;
    
    return true;
  } catch (error) {
    console.error('Error setting skill shortcut:', error);
    return false;
  }
}

/**
 * Get available skills to learn for a player
 */
export function getAvailableSkillsToLearn(player: Player): SkillId[] {
  try {
    const availableSkills: SkillId[] = [];
    const classTree = CLASS_SKILL_TREES[player.className as CharacterClass];
    
    if (!classTree) {
      return [];
    }
    
    // Check all skills in class progression
    for (const [skillId, requirement] of Object.entries(classTree.skillProgression)) {
      // Skip skills player already has
      if (player.unlockedSkills.includes(skillId as SkillId)) {
        continue;
      }
      
      // Check if player can learn this skill
      if (canLearnSkill(
        skillId as SkillId,
        player.className as CharacterClass,
        player.level,
        player.unlockedSkills as SkillId[]
      )) {
        availableSkills.push(skillId as SkillId);
      }
    }
    
    return availableSkills;
  } catch (error) {
    console.error('Error getting available skills:', error);
    return [];
  }
}

/**
 * Award a skill point to a player (e.g., on level up)
 */
export function awardSkillPoint(player: Player): void {
  player.availableSkillPoints += 1;
}


// ==============================================================================
// FILE: server/skills.ts
// ==============================================================================

import { Server } from 'socket.io';
import { Enemy, StatusEffect } from '../shared/types.js';
import { SkillType } from './types.js';
import { SKILLS, SkillId } from '../shared/skillsDefinition.js';
import { VecXZ } from '../shared/messages.js';
import { predictPosition, awardPlayerXP } from './world.js';
import { hash } from '../shared/combatMath.js';
import { PlayerState } from '../shared/types.js';

/**
 * Calculate distance between two points
 */
function distance(a: VecXZ, b: VecXZ): number {
  const dx = a.x - b.x;
  const dz = a.z - b.z;
  return Math.sqrt(dx * dx + dz * dz);
}

/**
 * Check if a skill can be cast
 * Uses prediction to ensure accurate position for range checks
 */
export function canCast(
  caster: PlayerState,
  skill: { id: string, range: number },
  target: Enemy | null,
  targetPos: VecXZ | null,
  now: number
): boolean {
  // Check if caster is alive
  if (!caster.isAlive) {
    return false;
  }
  
  // Check if skill is on cooldown
  const cooldownEnd = caster.skillCooldownEndTs[skill.id] || 0;
  if (now < cooldownEnd) {
    return false;
  }
  
  // Get skill definition
  const skillDef = SKILLS[skill.id as SkillType];
  if (!skillDef) {
    return false;
  }
  
  // Check mana cost
  if (caster.mana < skillDef.manaCost) {
    return false;
  }
  
  // If target-based skill, check target is valid
  if (target) {
    if (!target.isAlive) {
      return false;
    }
    
    // Predict caster position at current time
    const casterPos = predictPosition(caster, now);
    
    // Get target position
    const targetPos = { x: target.position.x, z: target.position.z };
    
    // Check range
    if (distance(casterPos, targetPos) > skill.range) {
      return false;
    }
  } 
  // If position-based skill, check position is within range
  else if (targetPos) {
    const casterPos = predictPosition(caster, now);
    
    // Check range
    if (distance(casterPos, targetPos) > skill.range) {
      return false;
    }
  } else {
    // No target or position specified
    return false;
  }
  
  return true;
}

/**
 * Execute a skill with all its effects
 */
export function executeSkill(
  caster: PlayerState,
  target: Enemy,
  skillId: SkillType,
  server: Server
): void {
  const now = Date.now();
  const skill = SKILLS[skillId];
  
  if (!skill) return;
  
  // Apply skill cost
  caster.mana -= skill.manaCost;
  caster.skillCooldownEndTs[skillId] = now + skill.cooldownMs;
  
  // Apply damage
  if (skill.dmg && target) {

    target.health = Math.max(0, target.health - skill.dmg);
    
    if (target.health === 0) {
      target.isAlive = false;
      target.deathTimeTs = now;
      target.targetId = null;
      
      // Grant experience to the player using the centralized function
      awardPlayerXP(caster, target.experienceValue, `killing enemy ${target.id} with ${skillId}`, server);
    }
  }
  
  // Apply status effect
  if (skill.effects && target) {
    for (const effect of skill.effects) {
      const existingEffect = target.statusEffects.find(e => e.type === effect.type);
      if (existingEffect) {
        existingEffect.value = effect.value;
        existingEffect.durationMs = effect.durationMs;
        existingEffect.startTimeTs = now;
      } else {
        // Generate a deterministic effect ID
        const effectId = `effect-${hash(`${effect.type}-${now}-${skillId}`)}`;
        target.statusEffects.push({
          id: effectId,
          type: effect.type,
          value: effect.value,
          durationMs: effect.durationMs,
          startTimeTs: now,
          sourceSkill: skillId,
        });
      }
    }
  }
  
  // Broadcast updates
  server.emit('enemyUpdated', target);
  server.emit('playerUpdated', caster);
}

/**
 * Spawn a projectile from a skill cast
 */
export function spawnProjectileFromSkill(
  world: any,  // World interface will be defined later
  caster: PlayerState,
  skillId: SkillId,
  targetPos?: VecXZ,
  targetId?: string
): void {
  const skill = SKILLS[skillId];
  
  // Check if skill exists and is a projectile type
  if (!skill || skill.cat !== 'projectile' || !skill.speed) {
    return;
  }
  
  // Get caster position
  const casterPos: VecXZ = { x: caster.position.x, z: caster.position.z };
  
  // Determine target position
  let finalTargetPos: VecXZ;
  
  if (targetPos) {
    // If target position provided, use it
    finalTargetPos = targetPos;
  } else if (targetId) {
    // If target ID provided, get entity position
    const targetEntity = world.getGameState().enemies[targetId] || world.getGameState().players[targetId];
    if (!targetEntity) return;
    
    finalTargetPos = { x: targetEntity.position.x, z: targetEntity.position.z };
  } else {
    // No valid target, use caster's forward direction
    const forwardDir = { x: 0, z: 1 }; // Assuming +Z is forward
    finalTargetPos = {
      x: casterPos.x + forwardDir.x * 10, // 10 units forward
      z: casterPos.z + forwardDir.z * 10
    };
  }
  
  // Calculate direction from caster to target
  const dx = finalTargetPos.x - casterPos.x;
  const dz = finalTargetPos.z - casterPos.z;
  const dist = Math.sqrt(dx * dx + dz * dz);
  
  // Normalize direction
  const dir: VecXZ = dist > 0 
    ? { x: dx / dist, z: dz / dist } 
    : { x: 0, z: 1 };  // Default forward
  
  // Spawn the projectile in the world
  world.spawnProjectile({
    casterId: caster.id,
    skillId,
    pos: casterPos,
    dir,
    speed: skill.speed,
    targetId
  });
}


// ==============================================================================
// FILE: server/spatial/SpatialHashGrid.ts
// ==============================================================================

import { VecXZ } from '../../shared/messages';

// Define EntityId type locally to avoid dependency issues
type EntityId = string;

/**
 * A spatial hash grid for efficient spatial queries
 */
export class SpatialHashGrid {
  private cells: Map<string, Set<EntityId>>;
  private cellSize: number;
  private invCellSize: number;
  private _scratchSet: Set<string>;
  private _scratchArr: string[];

  /**
   * Creates a new spatial hash grid with customizable cell size
   * @param cellSize The size of each grid cell (default: 6)
   */
  constructor(cellSize: number = 6) {
    this.cells = new Map<string, Set<EntityId>>();
    this.cellSize = cellSize;
    this.invCellSize = 1 / cellSize;
    this._scratchSet = new Set<string>();
    this._scratchArr = [] as string[];
  }

  /**
   * Creates a cell key from world coordinates using specified cell size
   * Static helper for external use without instantiating a grid
   */
  static key(x: number, z: number, cellSize: number = 6): string {
    const ix = Math.floor(x / cellSize);
    const iz = Math.floor(z / cellSize);
    return `${ix},${iz}`;
  }

  /**
   * Generates a hash key from world coordinates
   */
  private hash(x: number, z: number): string {
    const ix = Math.floor(x * this.invCellSize);
    const iz = Math.floor(z * this.invCellSize);
    return `${ix},${iz}`;
  }

  /**
   * Inserts an entity into the grid at the specified position
   */
  public insert(id: EntityId, pos: VecXZ): void {
    const key = this.hash(pos.x, pos.z);
    
    if (!this.cells.has(key)) {
      this.cells.set(key, new Set<EntityId>());
    }
    
    this.cells.get(key)!.add(id);
  }
  
  /**
   * Moves an entity from its old position to a new position in the grid
   */
  public move(id: EntityId, oldPos: VecXZ, newPos: VecXZ): void {
    const oldKey = this.hash(oldPos.x, oldPos.z);
    const newKey = this.hash(newPos.x, newPos.z);
    
    // If the entity hasn't changed cells, no need to update the grid
    if (oldKey === newKey) {
      return;
    }
    
    // Remove from old cell
    const oldCell = this.cells.get(oldKey);
    if (oldCell) {
      oldCell.delete(id);
      // Clean up empty cells to prevent memory leaks
      if (oldCell.size === 0) {
        this.cells.delete(oldKey);
      }
    }
    
    // Add to new cell
    if (!this.cells.has(newKey)) {
      this.cells.set(newKey, new Set<EntityId>());
    }
    
    this.cells.get(newKey)!.add(id);
  }
  
  /**
   * Removes an entity from the grid
   */
  public remove(id: EntityId, pos: VecXZ): void {
    const key = this.hash(pos.x, pos.z);
    
    const cell = this.cells.get(key);
    if (cell) {
      cell.delete(id);
      // Clean up empty cells to prevent memory leaks
      if (cell.size === 0) {
        this.cells.delete(key);
      }
    }
  }
  
  /**
   * Queries the grid for entities within a circle centered at pos with radius r
   * Returns deduplicated list of entity IDs
   */
  public queryCircle(pos: VecXZ, r: number): EntityId[] {
    const set = this._scratchSet;
    set.clear();
    
    const cellRadius = Math.ceil(r * this.invCellSize);
    const centerIx = Math.floor(pos.x * this.invCellSize);
    const centerIz = Math.floor(pos.z * this.invCellSize);
    
    // Generate keys for all cells that might intersect with the circle
    for (let ix = centerIx - cellRadius; ix <= centerIx + cellRadius; ix++) {
      for (let iz = centerIz - cellRadius; iz <= centerIz + cellRadius; iz++) {
        const key = `${ix},${iz}`;
        const cell = this.cells.get(key);
        
        if (cell) {
          // Add all entities from this cell to the result set
          for (const id of cell) {
            set.add(id);
          }
        }
      }
    }
    
    // Convert set to array using scratch array to avoid allocation
    this._scratchArr.length = 0;
    for (const id of set) {
      this._scratchArr.push(id);
    }
    
    return this._scratchArr;
  }
}

/**
 * Checks if an entity has moved to a different grid cell
 * Uses static key method to avoid unnecessary object instantiation
 */
export function gridCellChanged(oldPos: VecXZ, newPos: VecXZ): boolean {
  const oldKey = SpatialHashGrid.key(oldPos.x, oldPos.z);
  const newKey = SpatialHashGrid.key(newPos.x, newPos.z);
  return oldKey !== newKey;
}


// ==============================================================================
// FILE: server/types.ts
// ==============================================================================

import { SkillId, SKILLS, SkillDef, SkillEffect as SharedSkillEffect } from '../shared/skillsDefinition.js';
import { VecXZ } from '../shared/messages.js';
import { CharacterClass } from '../shared/classSystem.js';
import { SkillType } from '../shared/skillsDefinition.js';

// Server-side representation of a skill effect
export interface SkillEffect extends SharedSkillEffect {
    id?: string;
    startTimeTs?: number;
    sourceSkill?: string;
}

// Re-export SkillDef for server
export type { SkillDef };

export interface Projectile {
    id: string;
    casterId: string;
    skillId: SkillId;
    pos: VecXZ;
    dir: VecXZ;
    speed: number;
    spawnTs: number;
    targetId?: string;  // Optional for homing projectiles
    hitTargets: string[];  // Track entities that have been hit by this projectile
    hitCount: number;  // Track number of hits for piercing projectiles
}

export type { SkillType }

// Add an alias for 'water' skill ID to match 'waterSplash'
(SKILLS as any)['water'] = SKILLS['waterSplash'];

// Player class data - stores class and unlocked skills
export interface PlayerClassData {
    className: CharacterClass;
    unlockedSkills: SkillId[];
    activeSkills: SkillId[]; // Skills currently equipped (limited by slots)
    availableSkillPoints: number;
}


// ==============================================================================
// FILE: server/world.ts
// ==============================================================================

import { Server, Socket } from 'socket.io';
import { ZoneManager } from '../shared/zoneSystem.js';
import { Enemy, PlayerState } from '../shared/types.js';
import { SkillType, Projectile } from './types.js';
import { isPathBlocked, sweptHit } from './collision.js';
import { ClientMsg, CastReq, VecXZ, PosDelta, LearnSkill, SetSkillShortcut, MoveIntent } from '../shared/messages.js';
import { log, LOG_CATEGORIES } from './logger.js';
import { EffectManager } from './effects/manager';
import { SKILLS, SkillId } from '../shared/skillsDefinition.js';
import { onLearnSkill, onSetSkillShortcut } from './skillHandler.js';
import { predictPosition as sharedPredictPosition } from '../shared/positionUtils.js';
import { SpatialHashGrid, gridCellChanged } from './spatial/SpatialHashGrid';
import { getDamage, hash, rng } from '../shared/combatMath.js';
import { CM_PER_UNIT, POS_MAX_DELTA_CM } from '../shared/netConstants.js';
import { handleCastReq } from './combat/castHandler.js';
import { tickCasts } from './combat/skillSystem.js';

/**
 * Defines the GameState interface
 */
interface GameState {
  players: Record<string, PlayerState>;
  enemies: Record<string, Enemy>;
  projectiles: Projectile[];
  lastProjectileId: number;
}

/**
 * Calculates the distance between two positions
 */
function distance(a: VecXZ, b: VecXZ): number {
  const dx = a.x - b.x;
  const dz = a.z - b.z;
  return Math.sqrt(dx * dx + dz * dz);
}

/**
 * Calculates the direction vector from source to destination
 */
function calculateDir(from: VecXZ, to: VecXZ): { x: number; y: number; z: number } {
  const dx = to.x - from.x;
  const dz = to.z - from.z;
  const dist = Math.sqrt(dx * dx + dz * dz);
  
  // Normalize direction
  if (dist === 0) return { x: 0, y: 0, z: 0 };
  return {
    x: dx / dist,
    y: 0, // Add y component with default 0
    z: dz / dist
  };
}

/**
 * Predicts the position of an entity at a specific timestamp based on its movement
 */
export function predictPosition(
  entity: { position: { x: number; y: number; z: number }, movement?: { targetPos?: VecXZ | null, speed?: number, lastUpdateTime: number } },
  timestamp: number
): VecXZ {
  const dest = entity.movement?.targetPos;
  if (!dest) {
    return { x: entity.position.x, z: entity.position.z };
  }

  const speed = entity.movement.speed ?? 20; // Default to 20 if speed is undefined
  const startTs = entity.movement.lastUpdateTime;
  const currentPos = { x: entity.position.x, y: entity.position.y, z: entity.position.z };

  // Calculate elapsed time in seconds
  const elapsedSec = (timestamp - startTs) / 1000;
  
  // Calculate direction
  const dir = calculateDir(currentPos, dest);
  
  // Calculate distance that would be covered by now
  const distanceCovered = speed * elapsedSec;
  const totalDistance = distance(currentPos, dest);
  
  // If we've reached or passed the destination, return destination
  if (distanceCovered >= totalDistance) {
    return dest;
  }
  
  // Otherwise, interpolate
  return {
    x: currentPos.x + dir.x * distanceCovered,
    z: currentPos.z + dir.z * distanceCovered
  };
}

/**
 * Advances an entity's position based on its movement state
 */
function advancePosition(entity: PlayerState, deltaTimeMs: number): void {
  if (!entity.movement?.targetPos) return;
  
  // Current position
  const currentPos = { x: entity.position.x, y: entity.position.y, z: entity.position.z };

  // Get destination and speed
  const dest = entity.movement.targetPos;
  const speed = entity.movement.speed;
  
  // Calculate direction if not already set
  if (!entity.velocity) {
    const dir = calculateDir(currentPos, dest);
    entity.velocity = {
      x: dir.x * speed,
      z: dir.z * speed
    };
  }
  
  // Calculate distance to move this step
  const deltaTimeSec = deltaTimeMs / 1000;
  const stepX = entity.velocity.x * deltaTimeSec;
  const stepY = 0;
  const stepZ = entity.velocity.z * deltaTimeSec;
  const stepDist = Math.sqrt(stepX * stepX + stepY * stepY + stepZ * stepZ);
  // Update position
  const oldPos = { x: entity.position.x, y: entity.position.y, z: entity.position.z };
  entity.position.x += stepX;
  entity.position.y += stepY;
  entity.position.z += stepZ;
  const newPos = { x: entity.position.x, y: entity.position.y, z: entity.position.z };

  // Update spatial hash grid if position changed cells
  if (gridCellChanged(oldPos, newPos)) {
    spatial.move(entity.id, oldPos, newPos);
  }
  
  // Check if we've reached the destination
  const newDist = distance(newPos, dest);
  const prevDist = distance(currentPos, dest);
  
  // If we've passed the destination or are very close, snap to it and clear movement
  if (newDist > prevDist || newDist < 0.1) {
    entity.position.x = dest.x;
    entity.position.z = dest.z;
    
    // Check again if final position changed the cell
    const finalPos = { x: dest.x, z: dest.z };
    if (gridCellChanged(newPos, finalPos)) {
      spatial.move(entity.id, newPos, finalPos);
    }

    entity.movement.targetPos = null;
    entity.velocity = { x: 0, z: 0 };

    // Add a flag to indicate velocity was zeroed so we include it in the next snapshot
    (entity as any).dirtySnap = true;
  }
  
  // Update the position history after movement
  updatePositionHistory(entity, Date.now());
}

/**
 * Updates the position history of an entity, maintaining a limited history window
 */
function updatePositionHistory(entity: PlayerState | Enemy, timestamp: number): void {
  if (!entity.posHistory) {
    entity.posHistory = [];
  }
  
  // Add current position to history
  entity.posHistory.push({
    ts: timestamp,
    x: entity.position.x,
    z: entity.position.z
  });
  
  // Trim old entries to keep history within the time window (500ms)
  const MAX_HISTORY_AGE_MS = 500;
  while (entity.posHistory.length > 0 && 
         entity.posHistory[0].ts < timestamp - MAX_HISTORY_AGE_MS) {
    entity.posHistory.shift();
  }
}

/**
 * Gets the position of an entity at a specific timestamp by interpolating position history
 */
function getPositionAtTime(entity: PlayerState | Enemy, timestamp: number): VecXZ {
  // For enemies or entities without history, just return current position
  if (!('posHistory' in entity) || !entity.posHistory || entity.posHistory.length === 0) {
    return { x: entity.position.x, z: entity.position.z };
  }
  
  const history = entity.posHistory;
  
  // If timestamp is newer than all history entries, use the latest position
  if (timestamp > history[history.length - 1].ts) {
    return { x: entity.position.x, z: entity.position.z };
  }
  
  // If timestamp is older than all history entries, use the oldest position
  if (timestamp < history[0].ts) {
    return { x: history[0].x, z: history[0].z };
  }
  
  // Find the two history entries that bracket the requested timestamp
  let beforeIndex = 0;
  for (let i = 0; i < history.length - 1; i++) {
    if (history[i].ts <= timestamp && history[i + 1].ts >= timestamp) {
      beforeIndex = i;
      break;
    }
  }
  
  const before = history[beforeIndex];
  const after = history[beforeIndex + 1];
  
  // Linear interpolation between the two positions
  if (after.ts === before.ts) {
    return { x: before.x, z: before.z }; // Avoid division by zero
  }
  
  const ratio = (timestamp - before.ts) / (after.ts - before.ts);
  return {
    x: before.x + (after.x - before.x) * ratio,
    z: before.z + (after.z - before.z) * ratio
  };
}

/**
 * Advances all entities in the game world by the given time step
 */
function advanceAll(state: GameState, deltaTimeMs: number): void {
  // Process player movements
  for (const playerId in state.players) {
    const player = state.players[playerId];
    if (player.movement?.targetPos) {
      advancePosition(player, deltaTimeMs);
    }
  }
  
  // Process enemy logic, status effects, etc.
  for (const enemyId in state.enemies) {
    const enemy = state.enemies[enemyId];
    const now = Date.now();

    // Update position history for all enemies at each tick
    updatePositionHistory(enemy, now);
    enemy.lastUpdateTime = now;
    
    // Process enemy targeting and movement here
    if (enemy.isAlive && enemy.targetId) {
      const target = state.players[enemy.targetId];
      if (target && target.isAlive) {
        // Calculate target position prediction

        // Movement logic for enemy to follow target
        // (Simplified for now)
      }
    }
    
    // Process status effects (could be moved to a separate function)
    if (enemy.statusEffects.length > 0) {
      enemy.statusEffects = enemy.statusEffects.filter(effect => {
        return (effect.startTimeTs + effect.durationMs) > now;
      });
    }
  }
}

// Maintain map of last sent positions for delta compression
const lastSentPos: Record<string, VecXZ> = {};

/**
 * Collects position deltas or individual PosSnap entries for all entities
 * Note: This returns individual delta messages and PosSnap components, NOT complete messages
 */
function collectDeltas(
    state: GameState,
    timestamp: number,
    playersToForceInclude: Set<string> // New parameter
): (PosDelta | {id: string, pos: VecXZ, vel?: {x: number, z: number}, snapTs: number})[] {
    const msgs: any[] = []; // Use 'any' for simplicity here, ensure correct type on push

    for (const playerId in state.players) {
        const player = state.players[playerId];
        if (!player.isAlive) continue;

        const pos = predictPosition(player, timestamp); // Server's current authoritative pos
        const vel = player.velocity || { x: 0, z: 0 };
        const last = lastSentPos[playerId];

        if (playersToForceInclude.has(playerId) || !last) {
            msgs.push({ id: playerId, pos: pos, vel: vel, snapTs: timestamp });
            lastSentPos[playerId] = { ...pos };
            if ((player as any).dirtySnap) (player as any).dirtySnap = false;
            continue; // Move to next player
        }

        // If not forced, proceed with delta logic
        const dx = Math.round((pos.x - last.x) * CM_PER_UNIT);
        const dz = Math.round((pos.z - last.z) * CM_PER_UNIT);

        // Calculate velocity deltas (optional, can add later if needed)
        // const lastVel = lastVelSent[playerId] || {x:0, z:0};
        // const vdx = Math.round((vel.x - lastVel.x) * CM_PER_UNIT);
        // const vdz = Math.round((vel.z - lastVel.z) * CM_PER_UNIT);

        if (dx === 0 && dz === 0 /* && vdx === 0 && vdz === 0 */) { // If also checking vel deltas
             if ((player as any).dirtySnap) { // Still send if dirty (e.g. stopped, vel changed to 0)
                msgs.push({ id: playerId, pos: pos, vel: vel, snapTs: timestamp });
                lastSentPos[playerId] = { ...pos };
                // lastVelSent[playerId] = {...vel};
                (player as any).dirtySnap = false;
             }
            continue; // No change and not dirty
        }

        if (dx < -POS_MAX_DELTA_CM || dx > POS_MAX_DELTA_CM ||
            dz < -POS_MAX_DELTA_CM || dz > POS_MAX_DELTA_CM
            /* || vdx < -POS_MAX_DELTA_CM || ... */) {
            msgs.push({ id: playerId, pos: pos, vel: vel, snapTs: timestamp });
        } else {
            // Add vel deltas if they are significant or if velocity itself changed
            const deltaMsg: PosDelta = { type: 'PosDelta', id: playerId, dx, dz, serverTs: timestamp };
            // if (vdx !== 0 || vdz !== 0) { // Example: only send vel deltas if they changed
            //    deltaMsg.vdx = vdx;
            //    deltaMsg.vdz = vdz;
            // }
            msgs.push(deltaMsg);
        }
        lastSentPos[playerId] = { ...pos };
        // lastVelSent[playerId] = {...vel};
        if ((player as any).dirtySnap) (player as any).dirtySnap = false;
    }
    return msgs;
}

/**
 * Handles CastReq message using the new server-authoritative skill system
 * @param ioServer The Socket.IO server instance
 */
function onCastReq(socket: Socket, state: GameState, msg: CastReq, ioServer: Server): void {
  const playerId = msg.id;
  const player = state.players[playerId];
  
  // Verify player exists and belongs to this socket
  if (!player || player.socketId !== socket.id) {
    return;
  }
  
  // Handle using the legacy system first for backwards compatibility
  if (!player.unlockedSkills.includes(msg.skillId as SkillType)) {
    console.warn(`Player ${playerId} tried to cast not owned skill: ${msg.skillId}`);
    socket.emit('msg', {
      type: 'CastFail',
      clientSeq: msg.clientTs,
      reason: 'invalid'
    });
    return;
  }
  
  // Create a simple world object for the skill system
  const world = {
    getEnemyById: (id: string) => state.enemies[id] || null,
    getPlayerById: (id: string) => state.players[id] || null,
    getEntitiesInCircle: (pos: VecXZ, radius: number) => getEntitiesInCircle(state, pos, radius)
  };
  
  // Delegate to the server-authoritative castHandler
  handleCastReq(socket, player, msg, ioServer, world);
}

/**
 * Helper to get entities in a circle
 */
function getEntitiesInCircle(state: GameState, pos: VecXZ, radius: number): any[] {
  const result: any[] = [];
  
  // Check enemies
  for (const enemyId in state.enemies) {
    const enemy = state.enemies[enemyId];
    if (!enemy.isAlive) continue;
    
    const dx = enemy.position.x - pos.x;
    const dz = enemy.position.z - pos.z;
    const distSq = dx * dx + dz * dz;
    
    if (distSq <= radius * radius) {
      result.push(enemy);
    }
  }
  
  // Check players (for PvP if enabled)
  for (const playerId in state.players) {
    const player = state.players[playerId];
    if (!player.isAlive) continue;
    
    const dx = player.position.x - pos.x;
    const dz = player.position.z - pos.z;
    const distSq = dx * dx + dz * dz;
    
    if (distSq <= radius * radius) {
      result.push(player);
    }
  }
  
  return result;
}

/**
 * Ensures a vector is normalized (unit vector)
 */
function ensureUnitVec(dir: { x: number, z: number }): { x: number, z: number } {
  const magnitude = Math.sqrt(dir.x * dir.x + dir.z * dir.z);
  if (magnitude === 0) return { x: 1, z: 0 }; // Default direction if zero vector
  
  // Normalize the vector
  return {
    x: dir.x / magnitude,
    z: dir.z / magnitude
  };
}

/**
 * Executes a skill's effects
 */
function executeSkillEffects(
  caster: PlayerState, 
  target: Enemy, 
  skillId: SkillType, 
  io: any,
  state: GameState
): void {
  if (!target || !target.isAlive) return;
  
  // Get skill from the shared/skills.ts file if available
  const sharedSkill = SKILLS[skillId as SkillId];
  const skill = SKILLS[skillId as SkillId];
  
  // Launch appropriate effect based on skill category from shared definition if available
  if (sharedSkill) {
    if (sharedSkill.cat === 'projectile') {
      const casterPos = { x: caster.position.x, z: caster.position.z };
      const targetPos = { x: target.position.x, z: target.position.z };
      const dir = calculateDir(casterPos, targetPos);
      
      // Spawn projectile using the effect manager
      effects.spawnProjectile(sharedSkill.id, caster, dir, target.id);
    } else if (sharedSkill.cat === 'instant') {
      // Spawn instant effect using the effect manager
      effects.spawnInstant(sharedSkill.id, caster, [target.id]);
    }
  }
  
  // Handle area of effect damage
  if (skill.area && skill.area > 0) {
    Object.values(state.enemies).forEach(enemy => {
      // Skip primary target (already damaged) and dead enemies
      if (enemy.id === target.id || !enemy.isAlive) return;
      
      // Check if enemy is within AoE radius
      const dist = distance(
        { x: target.position.x, z: target.position.z },
        { x: enemy.position.x, z: enemy.position.z }
      );
      
      if (dist <= skill.area!) {
        // Apply AoE damage
        enemy.health = Math.max(0, enemy.health - (skill.dmg || 0));
        
        // Handle death
        if (enemy.health === 0) {
          enemy.isAlive = false;
          enemy.deathTimeTs = Date.now();
          enemy.targetId = null;
          
          // Remove from spatial hash grid
          spatial.remove(enemy.id, { x: enemy.position.x, z: enemy.position.z });
          
          // Grant experience to the player
          caster.experience += enemy.experienceValue;
        }
        
        // Broadcast enemy update for AoE targets
        io.emit('enemyUpdated', enemy);
      }
    });
  }
  
  // Apply status effect
  if (skill.effects && skill.effects.length > 0) {
    for (const effect of skill.effects) {
      // Skip effects without a duration
      if (!effect.durationMs) continue;
      
      const now = Date.now();
      
      // Use the new effectRunner for direct skill effects
      effectRunner.add(
        target,           // target entity
        caster,           // source entity
        effect.type as any, // effect type as EffectId
        hash(`${skillId}:${target.id}:${now}`) // consistent seed for deterministic effect calculations
      );
    }
  }
  
  // Broadcast updates
  io.emit('enemyUpdated', target);
  io.emit('playerUpdated', caster);
  
  // Emit skillEffect event for visual effects (legacy support)
  // TODO: Remove this legacy skillEffect emission after client PR-3 is merged
  io.emit('skillEffect', {
    skillId,
    sourceId: caster.id,
    targetId: target.id
  });
}

/**
 * Initialize the game world
 */
// Create an effects variable at module scope
let effects: EffectManager;
// Create a spatial hash grid at module scope
let spatial: SpatialHashGrid;

export function initWorld(io: Server, zoneManager: ZoneManager) {
  // Initialize game state
  const state: GameState = {
    players: {},
    enemies: {},
    projectiles: [],
    lastProjectileId: 0
  };
  
  // Initialize effect manager
  effects = new EffectManager(io, state);
  
  // Initialize the spatial hash grid
  spatial = new SpatialHashGrid();
  
  // Spawn initial enemies
  spawnInitialEnemies(state, zoneManager);
  
  // Game loop settings
  const TICK = 1000 / 30; // 30 FPS / Hz world tick rate
  const SNAP_HZ = 10;     // 10 Hz position snapshots
  let snapAccumulator = 0;
  
  // Start game loop
  setInterval(() => {
    const now = Date.now();

    // Step 1: Advance all entity states
    advanceAll(state, TICK);
    
    // Step 2: Update all effects
    effects.updateAll(TICK/1000); // convert to seconds
    
    // Step 3: Process active casts using the new skill system
    const world = {
      getEnemyById: (id: string) => state.enemies[id] || null,
      getPlayerById: (id: string) => state.players[id] || null,
      getEntitiesInCircle: (pos: VecXZ, radius: number) => getEntitiesInCircle(state, pos, radius)
    };
    tickCasts(TICK, io, world);
    
    
    
    // Step 4: Update all projectiles
    if (state.projectiles.length > 0) {
      updateProjectiles(state, TICK/1000, io);
    }
    
    // Step 5: Generate and broadcast position updates at the target rate
    snapAccumulator += 1;
    if (snapAccumulator >= 30 / SNAP_HZ) {
      const msgs = collectDeltas(state, now, new Set());
      if (msgs.length > 0) {
        // Wrap the messages array in a container with its own type to prevent client errors
        io.emit('msg', {
          type: 'BatchUpdate',
          updates: msgs
        });
      }
      snapAccumulator = 0;
    }
    
    // Step 5: Process mana regeneration (less frequent)
    if (snapAccumulator === 1) {
      handleManaRegeneration(state, io);
    }
    
    // Step 6: Process enemy respawns (even less frequent)
    if (snapAccumulator === 2) {
      handleEnemyRespawns(state, io);
    }
  }, TICK);
  
  // Return public API
  return {
    handleMessage(socket: Socket, msg: ClientMsg) {
      switch (msg.type) {
        case 'MoveIntent': return onMoveIntent(socket, state, msg as MoveIntent);
        case 'CastReq': return onCastReq(socket, state, msg as CastReq, io);
        case 'LearnSkill': return onLearnSkill(socket, state, msg as LearnSkill);
        case 'SetSkillShortcut': return onSetSkillShortcut(socket, state, msg as SetSkillShortcut);
      }
    },
    
    getGameState() {
      return state;
    },
    
    getEntitiesInCircle(pos: VecXZ, radius: number) {
      // Use spatial hash grid to get entity IDs within the circle
      const entityIds = spatial.queryCircle(pos, radius);
      
      // Convert IDs back to entities
      return entityIds.map(id => {
        // Check if it's a player
        if (id in state.players && state.players[id].isAlive) {
          return state.players[id];
        }
        // Check if it's an enemy
        if (id in state.enemies && state.enemies[id].isAlive) {
          return state.enemies[id];
        }
        return null;
      }).filter(Boolean); // Remove null entries
    },
    
    // Expose the spatial grid for direct access
    spatial,
    
    addPlayer(socketId: string, name: string) {
      const playerId = `player-${hash(socketId + Date.now().toString())}`;
      
      const player: PlayerState = {
        id: playerId,
        socketId,
        name,
        position: { x: 0, y: 0.5, z: 0 },
        rotation: { x: 0, y: 0, z: 0 },
        health: 100,
        maxHealth: 100,
        mana: 100,
        maxMana: 100,
        level: 2,
        experience: 0,
        experienceToNextLevel: 100,
        statusEffects: [],
        skillCooldownEndTs: {},
        castingSkill: null,
        castingProgressMs: 0,
        isAlive: true,
        className: 'mage', // Default class
        unlockedSkills: ['fireball'], // Start with fireball
        skillShortcuts: ['fireball', null, null, null, null, null, null, null, null], // Assign fireball to shortcut 1
        availableSkillPoints: 1, // Give the player 1 skill point to start
        posHistory: [], // Initialize position history
        lastUpdateTime: Date.now()
      };
      
      state.players[playerId] = player;
      
      // Add player to spatial hash grid
      spatial.insert(playerId, { x: player.position.x, z: player.position.z });
      
      return player;
    },
    
    removePlayerBySocketId(socketId: string) {
      const playerId = Object.keys(state.players).find(
        id => state.players[id].socketId === socketId
      );
      
      if (playerId) {
        // Get player position before removing
        const player = state.players[playerId];
        const pos = { x: player.position.x, z: player.position.z };
        
        // Remove player from spatial hash grid
        spatial.remove(playerId, pos);
        
        // Remove player from state
        delete state.players[playerId];
        
        return playerId;
      }
      
      return null;
    }
  };
}

/**
 * Helper to spawn initial enemies
 */
function spawnInitialEnemies(state: GameState, zoneManager: ZoneManager) {
  const GAME_ZONES = zoneManager.getZones();
  
  GAME_ZONES.forEach((zone) => {
    const mobsToSpawn = zoneManager.getMobsToSpawn(zone.id);
    mobsToSpawn.forEach((mobConfig) => {
      const { type, count } = mobConfig;
      for (let i = 0; i < count; i++) {
        const position = zoneManager.getRandomPositionInZone(zone.id);
        if (!position) continue;

        const enemyId = `${type}-${hash(`${type}-${Date.now()}-${position.x}-${position.z}`).toString(36).substring(0, 9)}`;
        const level = zoneManager.getMobLevel(zone.id);

        state.enemies[enemyId] = {
          id: enemyId,
          type,
          name: type.charAt(0).toUpperCase() + type.slice(1),
          level,
          position,
          spawnPosition: { ...position },
          rotation: { x: 0, y: rng(hash(`rotation-${Date.now()}-${position.x}-${position.z}`))() * Math.PI * 2, z: 0 },
          health: 100 + (level * 20),
          maxHealth: 100 + (level * 20),
          isAlive: true,
          attackDamage: 10 + (level * 2),
          attackRange: 2,
          baseExperienceValue: 50 + (level * 10),
          experienceValue: 50 + (level * 10),
          statusEffects: [],
          targetId: null,
        };
        
        // Add enemy to spatial hash grid
        spatial.insert(enemyId, { x: position.x, z: position.z });
      }
    });
  });
}

/**
 * Awards XP to a player and handles level ups
 * @param player The player to award XP to
 * @param xpAmount Amount of XP to award
 * @param sourceInfo Information about the source of XP (for logging)
 * @param io Server instance for broadcasting updates
 */
export function awardPlayerXP(player: PlayerState, xpAmount: number, sourceInfo: string, io: Server): void {
  const oldExp = player.experience;
  player.experience += xpAmount;
  log(LOG_CATEGORIES.PLAYER, `Player ${player.id} gained ${xpAmount} XP from ${sourceInfo}. XP: ${oldExp} -> ${player.experience}`);
  
  // Check for level up
  if (player.experience >= player.experienceToNextLevel) {
    const oldLevel = player.level;
    const oldSkillPoints = player.availableSkillPoints;
    
    player.level += 1;
    const oldMaxExp = player.experienceToNextLevel;
    player.experience -= player.experienceToNextLevel; // Keep excess XP
    player.experienceToNextLevel = Math.floor(oldMaxExp * 1.5); // 50% more XP needed for next level
    log(LOG_CATEGORIES.PLAYER, `Player ${player.id} leveled up to level ${player.level}! Next level at ${player.experienceToNextLevel} XP`);
    
    // Increase max health and mana with level
    player.maxHealth = 100 + (player.level - 1) * 20;
    player.maxMana = 100 + (player.level - 1) * 10;
    
    // Heal player on level up
    player.health = player.maxHealth;
    player.mana = player.maxMana;
    
    // Award a skill point on level up
    player.availableSkillPoints += 1;
    log(LOG_CATEGORIES.PLAYER, `Player ${player.id} gained a skill point. Total: ${player.availableSkillPoints} (before: ${oldSkillPoints})`);
    
    console.log(`[LEVEL_UP] Player ${player.id}: Level ${oldLevel} -> ${player.level}, Skill Points: ${oldSkillPoints} -> ${player.availableSkillPoints}`);
  }
  
  // Broadcast the updated player state so clients see XP and level changes
  io.emit('playerUpdated', {
    id: player.id,
    experience: player.experience,
    experienceToNextLevel: player.experienceToNextLevel,
    level: player.level,
    maxHealth: player.maxHealth,
    health: player.health,
    maxMana: player.maxMana,
    mana: player.mana,
    availableSkillPoints: player.availableSkillPoints
  });
}

/**
 * Spawns a projectile in the world
 */
function spawnProjectile(
  state: GameState,
  casterId: string,
  skillId: SkillId,
  pos: VecXZ,
  dir: VecXZ,
  speed: number,
  targetId?: string
): Projectile {
  const projectileId = `proj_${state.lastProjectileId++}`;
  
  // Offset the initial position slightly in the direction of travel
  // This helps avoid collisions with the caster when spawning projectiles
  const offsetDistance = 0.5; // Small offset to move projectile away from caster
  const initialPos = {
    x: pos.x + dir.x * offsetDistance,
    z: pos.z + dir.z * offsetDistance
  };
  
  const projectile: Projectile = {
    id: projectileId,
    casterId,
    skillId,
    pos: { ...initialPos },
    dir: { ...dir },
    speed,
    spawnTs: Date.now(),
    targetId,
    hitTargets: [],
    hitCount: 0
  };
  
  console.log(`[PROJECTILE] Created new projectile: id=${projectileId}, skill=${skillId}, pos=(${initialPos.x.toFixed(2)}, ${initialPos.z.toFixed(2)}), dir=(${dir.x.toFixed(2)}, ${dir.z.toFixed(2)}), speed=${speed}, targetId=${targetId || 'none'}`);
  
  state.projectiles.push(projectile);
  
  return projectile;
}

/**
 * Updates all projectiles in the game
 */
function updateProjectiles(state: GameState, dt: number, io: Server): void {
  const projectilesToRemove: number[] = [];

  const now = Date.now();
  // Process each projectile
  for (let i = 0; i < state.projectiles.length; i++) {
    const p = state.projectiles[i];
    
    // Check projectile lifetime - remove if it's too old (10 seconds max lifetime)
    const projectileLifetime = now - p.spawnTs;
    if (projectileLifetime > 10000) {
      log(LOG_CATEGORIES.PROJECTILE, `Projectile ${p.id} removed due to exceeding maximum lifetime (${projectileLifetime}ms)`);
      projectilesToRemove.push(i);
      continue;
    }
    
    // Calculate the total distance traveled since spawn
    const startPos = { 
      x: p.pos.x - p.dir.x * p.speed * (projectileLifetime / 1000),
      z: p.pos.z - p.dir.z * p.speed * (projectileLifetime / 1000)
    };
    const distanceTraveled = Math.sqrt(
      Math.pow(p.pos.x - startPos.x, 2) + 
      Math.pow(p.pos.z - startPos.z, 2)
    );
    
    // Remove projectile if it has traveled too far
    const maxDistance = 100; // Reduced from 5000 to a more reasonable value
    if (distanceTraveled > maxDistance) {
      log(LOG_CATEGORIES.PROJECTILE, `Projectile ${p.id} removed due to exceeding maximum distance (${distanceTraveled.toFixed(2)} > ${maxDistance})`);
      projectilesToRemove.push(i);
      continue;
    }
    
    // Calculate new position using linear movement
    const oldPos = { ...p.pos };
    p.pos.x += p.dir.x * p.speed * dt;
    p.pos.z += p.dir.z * p.speed * dt;
    
    // Debug log for projectile movement
    log(LOG_CATEGORIES.PROJECTILE, `Projectile ${p.id} moved from (${oldPos.x.toFixed(2)}, ${oldPos.z.toFixed(2)}) to (${p.pos.x.toFixed(2)}, ${p.pos.z.toFixed(2)}) with speed ${p.speed}`);
    
    // Check for collisions with players and enemies
    let hit = false;
    const hitTargets: string[] = [];
    
    log(LOG_CATEGORIES.PROJECTILE, `Checking collisions for projectile at (${p.pos.x.toFixed(2)}, ${p.pos.z.toFixed(2)})`);
    
    // Check collision against enemies
    for (const enemyId in state.enemies) {
      const enemy = state.enemies[enemyId];
      if (!enemy.isAlive) continue;
      
      // Skip if this enemy is the caster
      if (enemyId === p.casterId) continue;
      
      // Get enemy position at the time of projectile movement for accurate hit detection
      const timeOfCheck = Date.now();
      const enemyPos = getPositionAtTime(enemy, timeOfCheck);
      
      // Add debug info for distance to enemy
      const distToEnemy = Math.sqrt(
        Math.pow(p.pos.x - enemyPos.x, 2) + 
        Math.pow(p.pos.z - enemyPos.z, 2)
      );
      
      log(LOG_CATEGORIES.PROJECTILE, `Distance to enemy ${enemyId}: ${distToEnemy.toFixed(2)}, enemy pos: (${enemyPos.x.toFixed(2)}, ${enemyPos.z.toFixed(2)})`);
      
      // Get the configured hit radius from the skill definition
      const skill = SKILLS[p.skillId];
      const configuredHitRadius = skill?.projectile?.hitRadius || 1.0;
      
      // Improved hit detection with both distance check and swept hit
      // Uses hit radius from skill config
      const isDirectHit = distToEnemy <= configuredHitRadius * 2.0; // Direct hit can be more generous
      const isSweptHit = sweptHit(oldPos, p.pos, enemyPos, configuredHitRadius);
      
      // Skip this enemy if it's already been hit by this projectile (for piercing projectiles)
      if (p.hitTargets && p.hitTargets.includes(enemyId)) {
        log(LOG_CATEGORIES.PROJECTILE, `Skipping enemy ${enemyId} - already hit by this projectile`);
        continue;
      }
      
      if (isDirectHit || isSweptHit) {
        log(LOG_CATEGORIES.PROJECTILE, `HIT enemy ${enemyId}! Distance: ${distToEnemy.toFixed(2)}, Direct hit: ${isDirectHit}, Swept hit: ${isSweptHit}`);
        hit = true;
        hitTargets.push(enemyId);
        
        // Apply skill effect
        const skill = SKILLS[p.skillId];
        if (skill) {
          // Apply damage to the enemy
          if (skill.dmg) {
            const oldHealth = enemy.health;
            enemy.health -= skill.dmg;
            log(LOG_CATEGORIES.DAMAGE, `Enemy ${enemyId} took ${skill.dmg} damage from projectile ${p.id}. Health: ${oldHealth} -> ${enemy.health}`);
            
            if (enemy.health <= 0) {
              enemy.health = 0;
              enemy.isAlive = false;
              enemy.deathTimeTs = Date.now();
              enemy.targetId = null;
              log(LOG_CATEGORIES.ENEMY, `Enemy ${enemyId} was killed by projectile ${p.id}`);
              
              // Remove enemy from spatial hash grid
              spatial.remove(enemyId, { x: enemy.position.x, z: enemy.position.z });
              
              // Give XP to the player who cast the projectile
              const caster = state.players[p.casterId];
              if (caster) {
                awardPlayerXP(caster, enemy.experienceValue || 0, `killing enemy ${enemyId}`, io);
              }
            }
          }
          
          // Apply status effects if defined
          if (skill.effects && skill.effects.length > 0) {
            for (const effect of skill.effects) {
              // Skip effects without a duration
              if (!effect.durationMs) continue;
              
              const now = Date.now();
              
              // Use the new effectRunner instead of directly pushing to status effects
              effectRunner.add(
                enemy,                  // target entity 
                state.players[p.casterId], // source entity
                effect.type as any,     // effect type as EffectId
                hash(`${p.id}:${enemyId}:${now}`)  // consistent seed for deterministic effect calculations
              );
            }
          }
          
          // Broadcast enemy update
          io.emit('enemyUpdated', enemy);
        }
        
        // Important: Break out of the enemy loop after a hit to ensure we stop checking more enemies
        break;
      }
    }
    
    // Check collision against players (if PvP is enabled)
    for (const playerId in state.players) {
      const player = state.players[playerId];
      if (!player.isAlive) continue;
      
      // Skip if this player is the caster
      if (playerId === p.casterId) continue;
      
      // Get player position at the exact time of projectile movement for more accurate hit detection
      const timeOfCheck = Date.now();
      const playerPos = player.posHistory && player.posHistory.length > 0 
                      ? getPositionAtTime(player, timeOfCheck) 
                      : { x: player.position.x, z: player.position.z };
      
      // Calculate distance to player
      const distToPlayer = Math.sqrt(
        Math.pow(p.pos.x - playerPos.x, 2) + 
        Math.pow(p.pos.z - playerPos.z, 2)
      );
      
      // Get the configured hit radius from the skill definition
      const skill = SKILLS[p.skillId];
      const configuredHitRadius = skill?.projectile?.hitRadius || 0.8; // Default slightly smaller for PvP
      
      // Skip this player if it's already been hit by this projectile (for piercing projectiles)
      if (p.hitTargets && p.hitTargets.includes(playerId)) {
        log(LOG_CATEGORIES.PROJECTILE, `Skipping player ${playerId} - already hit by this projectile`);
        continue;
      }
      
      // Improved hit detection with both distance check and swept hit
      const isDirectHit = distToPlayer <= configuredHitRadius * 1.5; // Direct hit can be more generous
      const isSweptHit = sweptHit(oldPos, p.pos, playerPos, configuredHitRadius);
      
      if (isDirectHit || isSweptHit) {
        log(LOG_CATEGORIES.PROJECTILE, `HIT player ${playerId}! Distance: ${distToPlayer.toFixed(2)}, Direct hit: ${isDirectHit}, Swept hit: ${isSweptHit}`);
        hit = true;
        hitTargets.push(playerId);
        
        // Apply skill effect to player
        // (Add PvP damage logic here if needed)
        
        // Important: Break out of the player loop after a hit
        break;
      }
    }
    
    // Handle hit effects
    if (hit && hitTargets.length > 0) {
      log(LOG_CATEGORIES.PROJECTILE, `Hit detected with ${hitTargets.length} targets, processing hit`);
      
      // Initialize hit targets array if not already present
      if (!p.hitTargets) {
        p.hitTargets = [];
      }
      
      // Track hit count
      p.hitCount = (p.hitCount || 0) + hitTargets.length;
      
      // Add new hit targets to the tracking array
      hitTargets.forEach(targetId => {
        if (!p.hitTargets?.includes(targetId)) {
          p.hitTargets.push(targetId);
        }
      });
      
      // Emit hit event
      io.emit('msg', {
        type: 'ProjHit2',
        castId: p.id,
        hitIds: hitTargets,
        dmg: hitTargets.map(targetId => {
          const { dmg } = getDamage({
            caster: state.players[p.casterId]?.stats ?? {},
            skill: { base: skill?.dmg || 10, variance: 0.1 },
            seed: `${p.id}:${targetId}`
          });
          return dmg;
        }),
        impactPos: { x: p.pos.x, z: p.pos.z }
      });
      
      // Check if the skill has splash damage
      const skill = SKILLS[p.skillId];
      if (skill?.projectile?.splashRadius) {
        const splashRadius = skill.projectile.splashRadius;
        const splashTargets: string[] = [];
        
        // Check all enemies for splash damage
        for (const enemyId in state.enemies) {
          const enemy = state.enemies[enemyId];
          if (!enemy.isAlive || hitTargets.includes(enemyId)) continue; // Skip dead enemies or already hit
          
          // Skip enemies already hit by this projectile
          if (p.hitTargets.includes(enemyId)) {
            continue;
          }
          
          const enemyPos = { x: enemy.position.x, z: enemy.position.z };
          const distToEnemy = Math.sqrt(
            Math.pow(p.pos.x - enemyPos.x, 2) + 
            Math.pow(p.pos.z - enemyPos.z, 2)
          );
          
          if (distToEnemy <= splashRadius) {
            splashTargets.push(enemyId);
            
            // Apply splash damage to the enemy with distance-based fall-off
            if (skill.dmg) {
              // Calculate damage fall-off based on distance
              // 100% damage at direct hit, scaling down to 25% at max splash radius
              const distanceFactor = 1 - (distToEnemy / splashRadius * 0.75);
              const splashDamage = Math.floor(skill.dmg * distanceFactor);
              
              // Track hit
              p.hitTargets.push(enemyId);
              p.hitCount += 1;
              
              const oldHealth = enemy.health;
              enemy.health -= splashDamage;
              log(LOG_CATEGORIES.DAMAGE, `Enemy ${enemyId} took ${splashDamage} splash damage from projectile ${p.id}. Distance: ${distToEnemy.toFixed(2)}, fall-off: ${(distanceFactor * 100).toFixed(0)}%. Health: ${oldHealth} -> ${enemy.health}`);
              
              if (enemy.health <= 0) {
                enemy.health = 0;
                enemy.isAlive = false;
                enemy.deathTimeTs = Date.now();
                enemy.targetId = null;
                log(LOG_CATEGORIES.ENEMY, `Enemy ${enemyId} was killed by splash from projectile ${p.id}`);
                
                // Remove enemy from spatial hash grid
                spatial.remove(enemyId, { x: enemy.position.x, z: enemy.position.z });
                
                // Give XP to the player who cast the projectile
                const caster = state.players[p.casterId];
                if (caster) {
                  awardPlayerXP(caster, enemy.experienceValue || 0, `splash killing enemy ${enemyId}`, io);
                }
              }
              
              // Apply status effects if defined
              if (skill.effects && skill.effects.length > 0) {
                for (const effect of skill.effects) {
                  // Skip effects without a duration
                  if (!effect.durationMs) continue;
                  
                  const effectId = `effect-${hash(`${effect.type}-${Date.now()}-${enemyId}`).toString(36).substring(0, 9)}`;
                  enemy.statusEffects.push({
                    id: effectId,
                    type: effect.type,
                    value: effect.value,
                    durationMs: effect.durationMs,
                    startTimeTs: Date.now(),
                    sourceSkill: p.skillId
                  });
                }
              }
              
              // Broadcast enemy update
              io.emit('enemyUpdated', enemy);
            }
          }
        };
        
        // Emit a separate hit event for splash targets
        if (splashTargets.length > 0) {
          log(LOG_CATEGORIES.PROJECTILE, `Projectile ${p.id} hit ${splashTargets.length} targets with splash damage`);
          io.emit('msg', {
            type: 'ProjHit2',
            castId: p.id,
            hitIds: splashTargets,
            dmg: splashTargets.map(targetId => {
              const { dmg } = getDamage({
                caster: state.players[p.casterId]?.stats ?? {},
                skill: { 
                  base: skill?.dmg || 10, 
                  variance: 0.1 
                },
                seed: `${p.id}:splash:${targetId}`
              });
              return dmg;
            }),
            impactPos: { x: p.pos.x, z: p.pos.z }
          });
        }
      }
      
      // Check for piercing - continue flight if piercing is true
      if (skill?.projectile?.pierce) {
        // Get the max number of hits for this piercing projectile
        const maxPierceHits = skill.projectile.maxPierceHits || Number.MAX_SAFE_INTEGER;
        
        // Check if we've hit the maximum number of targets already
        if (p.hitCount >= maxPierceHits) {
          log(LOG_CATEGORIES.PROJECTILE, `Projectile ${p.id} reached max pierce hits (${p.hitCount}/${maxPierceHits}), removing`);
          
          // Tell clients to despawn it
          io.emit('msg', {
            type: 'ProjHit2',
            castId: p.id,
            hitIds: [],
            dmg: [],
            impactPos: { x: p.pos.x, z: p.pos.z }
          });
          
          // Mark for removal and skip further processing for this projectile
          projectilesToRemove.push(i);
          continue; // Skip the TTL check
        }
        
        log(LOG_CATEGORIES.PROJECTILE, `Projectile ${p.id} has pierce property, continuing flight (hits: ${p.hitCount || 0}/${maxPierceHits})`);
      } else {
        // Also tell clients to despawn it immediately for non-piercing projectiles
        io.emit('msg', {
          type: 'ProjHit2',
          castId: p.id,
          hitIds: [],
          dmg: [],
          impactPos: { x: p.pos.x, z: p.pos.z }
        });
        
        // Mark for removal and skip further processing for this projectile
        projectilesToRemove.push(i);
        continue; // Skip the TTL check
      }
    }
    
    // Check TTL (Time To Live) - 2 seconds max lifetime (reduced from 4)
    if (now - p.spawnTs > 2000) {
      log(LOG_CATEGORIES.PROJECTILE, `Projectile ${p.id} expired by TTL after ${((now - p.spawnTs)/1000).toFixed(1)}s`);
      io.emit('msg', {
        type: 'ProjHit2',
        castId: p.id,
        hitIds: [],
        dmg: [],
        impactPos: { x: p.pos.x, z: p.pos.z }
      });
      
      projectilesToRemove.push(i);
    }
  }
  
  // Remove projectiles that hit or expired (remove from end to start to avoid index issues)
  if (projectilesToRemove.length > 0) {
    log(LOG_CATEGORIES.PROJECTILE, `Removing ${projectilesToRemove.length} projectiles`);
    for (let i = projectilesToRemove.length - 1; i >= 0; i--) {
      const index = projectilesToRemove[i];
      const p = state.projectiles[index];
      log(LOG_CATEGORIES.PROJECTILE, `Projectile ${p.id} removed from world`);
      state.projectiles.splice(index, 1);
    }
  }
}

/**
 * Handle mana regeneration for all players
 */
function handleManaRegeneration(state: GameState, io: Server) {
  const MANA_REGEN_PER_SECOND = 2;
  
  for (const playerId in state.players) {
    const player = state.players[playerId];
    if (player.isAlive && player.mana < player.maxMana) {
      const oldMana = player.mana;
      // Since this function is called less frequently than the old system,
      // we regenerate more mana per call to achieve the same rate over time
      player.mana = Math.min(player.maxMana, player.mana + MANA_REGEN_PER_SECOND);
      
      // Only broadcast if mana actually changed (avoiding precision issues)
      if (Math.abs(player.mana - oldMana) > 0.01) {
        // Broadcast mana update to all clients
        io.emit('playerUpdated', {
          id: player.id,
          mana: player.mana
        });
      }
    }
  }
}

/**
 * Handle enemy respawns
 */
function handleEnemyRespawns(state: GameState, io: Server) {
  const now = Date.now();

  for (const enemyId in state.enemies) {
    const enemy = state.enemies[enemyId];
    
    if (!enemy.isAlive && enemy.deathTimeTs) {
      const timeSinceDeath = now - enemy.deathTimeTs;
      if (timeSinceDeath >= 30000) { // 30 seconds respawn time
        enemy.isAlive = true;
        enemy.health = enemy.maxHealth;
        enemy.position = { ...enemy.spawnPosition };
        enemy.targetId = null;
        enemy.statusEffects = [];
        
        // Re-add enemy to spatial hash grid upon respawn
        spatial.insert(enemyId, { x: enemy.position.x, z: enemy.position.z });
        
        io.emit('enemyUpdated', enemy);
      }
    }
  }
}

/**
 * Broadcasts position snapshots of all players to clients
 * Should be called regularly (e.g. 10 Hz) to keep clients in sync
 */
export function broadcastSnaps(io: Server, state: GameState): void {
    if (!io || !state.players) return;
    const now = Date.now();
    const playersToForceInclude = new Set<string>();

    for (const playerId in state.players) {
        const player = state.players[playerId];
        if (!player.isAlive) continue;

        const isMoving = player.movement?.isMoving;
        const timeSinceLastSnap = player.lastSnapTime ? (now - player.lastSnapTime) : Infinity;

        // Determine if this player needs a "forced" full snapshot
        // (e.g., for idle refresh or if it's the very first snap)
        if (!isMoving && (!player.lastSnapTime || timeSinceLastSnap > 500)) {
            playersToForceInclude.add(playerId);
        }
        // Always update lastSnapTime if we are considering sending a snap for this player due to idle timeout
        if (playersToForceInclude.has(playerId) || isMoving) { // Or any other condition that leads to sending
             player.lastSnapTime = now;
        }
    }

    // Pass the set of players needing forced updates to collectDeltas
    // collectDeltas will then decide whether to send a full snap or a delta for moving players
    // not in the forced set.
    const snapItems = collectDeltas(state, now, playersToForceInclude);

    if (snapItems.length > 0) {
        io.emit('msg', { type: 'BatchUpdate', updates: snapItems });
        if (Math.random() < 0.1) { // Reduce log spam
             console.log(`Broadcasting BatchUpdate with ${snapItems.length} items. Forced: ${playersToForceInclude.size}`);
        }
    }
}

/**
 * Handles MoveIntent messages from clients requesting to move to a target position
 * This replaces the old MoveStart handler in the server-authoritative movement system
 */
function onMoveIntent(socket: Socket, state: GameState, msg: MoveIntent): void {
  const playerId = msg.id;
  const player = state.players[playerId];
  
  // Verify player exists and belongs to this socket
  if (!player || player.socketId !== socket.id) {
    console.warn(`Invalid player ID or wrong socket for MoveIntent: ${playerId}`);
    return;
  }
  
  // Implement a cast-lock window to prevent "micro-teleport" exploits
  const now = Date.now();
  if (player.lastUpdateTime && now - player.lastUpdateTime < 33) { // 33ms = ~1 tick at 30 FPS
    console.warn(`Movement request from player ${playerId} received too quickly, enforcing cast-lock window`);
    // Still process the request but apply a slight delay (server-side)
  }
  
  // Validate the target position is within reasonable bounds
  if (!isValidPosition(msg.targetPos)) {
    console.warn(`Invalid target position in MoveIntent from player ${playerId}: ${JSON.stringify(msg.targetPos)}`);
    return;
  }

  // Get current position
  const currentPos = { x: player.position.x, z: player.position.z };
  
  // Calculate the distance to the target
  const distance = Math.sqrt(
    Math.pow(currentPos.x - msg.targetPos.x, 2) +
    Math.pow(currentPos.z - msg.targetPos.z, 2)
  );
  
  // Limit maximum teleport distance - if move request is too far, cap it
  let targetPos = { ...msg.targetPos };

  if (distance < 0.05) {
    // This is a stop command - immediately halt the player
    player.movement = { 
      isMoving: false, 
      lastUpdateTime: now 
    };
    player.velocity = { x: 0, z: 0 };
    
    // Create a position snapshot for the stop command
    const stopSnapMsg = {
      type: 'PosSnap',
      snaps: [{
        id: playerId,
        pos: currentPos,
        vel: { x: 0, z: 0 },
        snapTs: now
      }]
    };
    
    // Send to the requesting client
    socket.emit('msg', stopSnapMsg);
    
    // Also broadcast to other players
    socket.broadcast.emit('msg', stopSnapMsg);
    
    return;
  }
  
  // Calculate direction and determine speed (now server-controlled)
  const dir = calculateDir(currentPos, msg.targetPos);
  
  // Use the already defined MAX_MOVE_DISTANCE for capping move distances
  let actualTargetPos = { ...msg.targetPos };
  
    actualTargetPos = msg.targetPos;

  // Determine server-authorized speed (can vary based on player stats, buffs, etc.)
  const speed = getPlayerSpeed(player); // Server decides the speed
  
  // Update player's movement state
  player.movement = {
    ...player.movement,
    isMoving: true,
    targetPos: actualTargetPos, // Use the possibly capped target position
    lastUpdateTime: now,
    speed: speed
  };
  
  // Set velocity for movement simulation
  player.velocity = {
    x: dir.x * speed,
    z: dir.z * speed
  };
  
  // Update last processed time
  player.lastUpdateTime = now;
  
  // Create a position snapshot message
  const posSnapMsg = {
    type: 'PosSnap',
    snaps: [{
      id: playerId, 
      pos: currentPos,
      vel: player.velocity,
      snapTs: now
    }]
  };
  
  // Send position update back to the requesting client
  socket.emit('msg', posSnapMsg);
  
  // Also broadcast to other players
  socket.broadcast.emit('msg', posSnapMsg);
  
  // Log movement (debug level)
  log(LOG_CATEGORIES.MOVEMENT, 'debug', `Player ${playerId} moving to ${JSON.stringify(msg.targetPos)} at speed ${speed}`);
}

/**
 * Determines a player's movement speed based on their stats and effects
 */
function getPlayerSpeed(player: PlayerState): number {
  // Base speed (can be adjusted for different character classes)
  let speed = 20; // Default movement units per second
  
  // Apply modifier based on player class and stats
  if (player.stats) {
    // Use movement speed if defined, or apply a default multiplier
    if ('movement' in player.stats) {
      speed += player.stats.movement as number;
    } else if (player.stats.dmgMult) {
      // Apply a small boost based on damage multiplier as a fallback
      speed += player.stats.dmgMult * 2;
    }
  }
  
  // Apply status effects that modify speed
  for (const effect of player.statusEffects) {
    if (effect.type === 'speed_boost') {
      speed *= 1.3; // 30% speed boost
    } else if (effect.type === 'slow') {
      speed *= 0.7; // 30% slow
    }
  }
  
  // Ensure speed doesn't exceed maximum allowed value
  const MAX_SPEED = 40;
  speed = Math.min(speed, MAX_SPEED);
  
  return speed;
}

/**
 * Validates if a position is within the allowed game bounds
 */
function isValidPosition(pos: VecXZ): boolean {
  const MAX_POSITION = 1000; // Maximum allowed coordinate value
  
  // Check for NaN or Infinity
  if (isNaN(pos.x) || isNaN(pos.z) || 
      !isFinite(pos.x) || !isFinite(pos.z)) {
    return false;
  }
  
  // Check bounds
  if (Math.abs(pos.x) > MAX_POSITION || Math.abs(pos.z) > MAX_POSITION) {
    return false;
  }
  
  return true;
}


// ==============================================================================
// FILE: shared/classSystem.ts
// ==============================================================================

// filepath: /home/s/develop/projects/vibe/1/shared/classSystem.ts
import { SkillId } from './skillsDefinition';

// Class types in the game
export type CharacterClass = 'mage' | 'warrior' | 'healer' | 'ranger';

// Interface for requirements to unlock skills
export interface SkillRequirement {
  level: number;
  classType?: CharacterClass; // If specified, skill is only available to this class
  requiredSkills?: SkillId[]; // Skills that must be learned before this one
}

// Class-specific skill progression tree
export interface ClassSkillTree {
  className: CharacterClass;
  description: string;
  baseStats: {
    healthMultiplier: number;
    manaMultiplier: number;
    damageMultiplier: number;
    speedMultiplier: number;
  };
  skillProgression: Record<SkillId, SkillRequirement>;
}

// Define skill trees for each class
export const CLASS_SKILL_TREES: Record<CharacterClass, ClassSkillTree> = {
  mage: {
    className: 'mage',
    description: 'Masters of elemental magic with high damage output but lower health',
    baseStats: {
      healthMultiplier: 0.8,
      manaMultiplier: 1.3,
      damageMultiplier: 1.2,
      speedMultiplier: 0.9
    },
    skillProgression: {
      'fireball': { level: 1 },  // Available immediately
      'waterSplash': { level: 2, requiredSkills: ['fireball'] },
      'iceBolt': { level: 3, requiredSkills: ['waterSplash'] },
      'petrify': { level: 4, requiredSkills: ['iceBolt'] }
    }
  },
  warrior: {
    className: 'warrior',
    description: 'Strong melee fighters with high health and defensive capabilities',
    baseStats: {
      healthMultiplier: 1.3,
      manaMultiplier: 0.7,
      damageMultiplier: 1.1,
      speedMultiplier: 1.0
    },
    skillProgression: {
      'fireball': { level: 2 }, // Warriors get fireball later
      'waterSplash': { level: 4 }, // Warriors aren't very proficient with water magic
      'iceBolt': { level: 5 }, // Warriors struggle with ice magic
      'petrify': { level: 3 }
    }
  },
  healer: {
    className: 'healer',
    description: 'Support characters focused on healing and buffs',
    baseStats: {
      healthMultiplier: 0.9,
      manaMultiplier: 1.2,
      damageMultiplier: 0.8,
      speedMultiplier: 1.0
    },
    skillProgression: {
      'fireball': { level: 4 }, // Healers aren't very combat-focused
      'waterSplash': { level: 1 }, // Healers start with water abilities
      'iceBolt': { level: 3 },
      'petrify': { level: 5 } // Advanced skill for healers
    }
  },
  ranger: {
    className: 'ranger',
    description: 'Long-range attackers with high speed and moderate damage',
    baseStats: {
      healthMultiplier: 0.9,
      manaMultiplier: 1.0,
      damageMultiplier: 1.1,
      speedMultiplier: 1.2
    },
    skillProgression: {
      'iceBolt': { level: 1 }, // Rangers start with ice abilities
      'fireball': { level: 2 },
      'waterSplash': { level: 3 }, // Rangers get water abilities mid-game
      'petrify': { level: 4 }
    }
  }
};

// Check if a player can learn a specific skill
export function canLearnSkill(
  skillId: SkillId, 
  playerClass: CharacterClass, 
  playerLevel: number, 
  playerSkills: SkillId[]
): boolean {
  const classTree = CLASS_SKILL_TREES[playerClass];
  if (!classTree) return false;
  
  const skillReq = classTree.skillProgression[skillId];
  if (!skillReq) return false; // Skill not available for this class
  
  // Check level requirement
  if (playerLevel < skillReq.level) return false;
  
  // Check prerequisite skills
  if (skillReq.requiredSkills) {
    for (const reqSkill of skillReq.requiredSkills) {
      if (!playerSkills.includes(reqSkill)) return false;
    }
  }
  
  return true;
}

// Get available skills to learn based on player's class, level and current skills
export function getAvailableSkills(
  playerClass: CharacterClass,
  playerLevel: number,
  playerSkills: SkillId[]
): SkillId[] {
  const classTree = CLASS_SKILL_TREES[playerClass];
  if (!classTree) return [];
  
  const availableSkills: SkillId[] = [];
  
  Object.entries(classTree.skillProgression).forEach(([skillId, req]) => {
    const skill = skillId as SkillId;
    // Skip skills player already has
    if (playerSkills.includes(skill)) return;
    
    // Check if player can learn this skill
    if (canLearnSkill(skill, playerClass, playerLevel, playerSkills)) {
      availableSkills.push(skill);
    }
  });
  
  return availableSkills;
}


// ==============================================================================
// FILE: shared/combatMath.ts
// ==============================================================================

import { SkillId, SKILLS } from './skillsDefinition';

/**
 * Calculate the mana cost of a skill, accounting for potential changes from player stats
 * @param skillId The skill ID
 * @param playerLevel Current player level
 * @returns Mana cost for the skill
 */
export function getManaCost(skillId: SkillId): number {
  const skill = SKILLS[skillId];
  if (!skill) return 0;
  
  const baseCost = skill.manaCost;
  
  return baseCost;
}

/**
 * Calculate the cooldown of a skill, accounting for potential changes from player stats
 * @param skillId The skill ID
 * @param playerLevel Current player level
 * @returns Cooldown time in milliseconds
 */
export function getCooldownMs(skillId: SkillId): number {
  const skill = SKILLS[skillId];
  if (!skill) return 0;
  
  const baseCooldown = skill.cooldownMs;

  return baseCooldown;
}

/** xorshift32 – enough for crit & variability, seed != 0 */
export function rng(seed: number): () => number {
  let x = seed >>> 0;
  return () => {
    x ^= x << 13; x ^= x >>> 17; x ^= x << 5;
    return (x >>> 0) / 0xffffffff;
  };
}

/**
 * Simple FNV-1a hash implementation to convert strings to numbers
 * @param str String to hash
 * @returns 32-bit number hash
 */
export function hash(str: string): number {
  let h = 2166136261 >>> 0; // FNV offset basis
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619); // FNV prime
  }
  return h >>> 0;
}

/**
 * Specialized RNG for status effects with a unique hash seed
 * @param seed The base seed to use
 * @returns Random number generator function
 */
export function effectRng(seed: number) {
  return rng(seed ^ 0xEFFECC);
}

export interface DamageOpts {
  caster: { dmgMult?: number; critChance?: number; critMult?: number };
  skill:  { base: number; variance?: number }; // variance , default 0.1
  seed:   string;                              // castId + targetId
}

export function getDamage(opts: DamageOpts): { dmg: number; crit: boolean } {
  const { caster, skill, seed } = opts;
  const roll = rng(hash(seed))();              // 0‑1 uniform
  const variance = 1 + (roll * 2 - 1) * (skill.variance ?? 0.1);
  const critRoll = rng(hash(seed) ^ 0x9e3779b9)();
  const crit = critRoll < (caster.critChance ?? 0);
  const critMult = crit ? (caster.critMult ?? 2) : 1;
  const dmg = skill.base * variance * (caster.dmgMult ?? 1) * critMult;
  return { dmg: Math.round(dmg), crit };
}


// ==============================================================================
// FILE: shared/constants.ts
// ==============================================================================

// Protocol version - bump when making changes to message formats
export const PROTOCOL_VERSION = '0.6.1';

// Game constants
export const DEFAULT_GROUND_Y = 0;
export const DEFAULT_PLAYER_HEIGHT = 1.8;
export const DEFAULT_GRAVITY = 9.8;

// Network constants
export const MAX_SYNC_LAG_MS = 100; // Maximum lag allowed for sync
export const POSITION_CORRECTION_THRESHOLD = 2.0; // Distance in meters
// Protocol version - bump when making changes to message formats

// Game constants

// Network constants

// ==============================================================================
// FILE: shared/effectsDefinition.ts
// ==============================================================================

import { rng } from './combatMath.js';

export type EffectId = 'burn' | 'bleed' | 'regen';

export interface EffectTick {
  value: number;      // Damage/healing amount
  type: 'damage' | 'healing' | 'mana' | 'stat'; // Effect type
}

export interface EffectDef {
  tickMs: number;     // How often the effect ticks
  durationMs: number; // Total duration
  maxStacks: number;  // Maximum number of stacks
  apply(o: {level: number; int: number; seed: number}): EffectTick;
}

export const EFFECTS: Record<EffectId, EffectDef> = {
  burn: {
    tickMs: 1000,     // Tick every second
    durationMs: 8000, // Last for 8 seconds
    maxStacks: 3,     // Max 3 stacks
    apply({ level, int, seed }): EffectTick {
      const random = rng(seed);
      const baseDamage = 8 + level * 2; // Base damage scales with level
      const variance = 0.2; // 20% variance
      const actualDamage = baseDamage * (1 + (random() * 2 - 1) * variance);
      
      return {
        value: Math.round(actualDamage * (1 + int * 0.05)), // Int increases damage by 5% per point
        type: 'damage'
      };
    }
  },
  
  bleed: {
    tickMs: 750,      // Ticks faster than burn
    durationMs: 6000, // Shorter duration
    maxStacks: 5,     // More stacks
    apply({ level, seed }): EffectTick {
      const random = rng(seed);
      const baseDamage = 5 + level * 1.5;
      const variance = 0.15;
      const actualDamage = baseDamage * (1 + (random() * 2 - 1) * variance);
      
      return {
        value: Math.round(actualDamage),
        type: 'damage'
      };
    }
  },
  
  regen: {
    tickMs: 1000,     // Every second
    durationMs: 10000, // 10 seconds
    maxStacks: 2,     // Max 2 stacks
    apply({ level, int, seed }): EffectTick {
      const random = rng(seed);
      const baseHeal = 5 + level * 1.8;
      const variance = 0.1;
      const actualHeal = baseHeal * (1 + (random() * 2 - 1) * variance);
      
      return {
        value: Math.round(actualHeal * (1 + int * 0.08)), // Int increases healing by 8% per point
        type: 'healing'
      };
    }
  }
};


// ==============================================================================
// FILE: shared/messages.ts
// ==============================================================================

import { SkillId } from './skillsDefinition';
import { CastSnapshot, StatusEffect } from './types';

export interface VecXZ {
  x: number;
  z: number;
}

export interface Vec3D {
  x: number;
  y: number;
  z: number;
}

export interface PlayerMovementState {
  isMoving: boolean;
  path?: VecXZ[];
  pos?: VecXZ;  // Current position (optional)
  targetPos?: VecXZ; // Target position when moving
  lastUpdateTime: number;
  speed?: number; // Speed is now optional
}

// Base message with type
export interface ClientMsg {
  type: string;
  [key: string]: any;
}

// Movement messages
// Client → Server: request to move
export interface MoveIntent extends ClientMsg {
  type: 'MoveIntent';
  id: string;          // Entity id (player uid)
  targetPos: VecXZ;    // World coords (XZ plane)
  clientTs: number;    // Ms since epoch on the client
}

// Server-driven position correction
export interface PosSnap extends ServerMsg {
  type: 'PosSnap';
  snaps: {
    id: string;
    pos: VecXZ;
    vel: { x: number; z: number };
    snapTs: number;
  }[];
}

export interface PosDelta extends ClientMsg {
  type: 'PosDelta';
  id: string;
  dx: number;
  dz: number;
  vdx?: number;
  vdz?: number;
  serverTs: number;
}

// Skill casting
export interface CastReq extends ClientMsg {
  type: 'CastReq';
  id: string;
  skillId: string;
  targetId?: string;
  targetPos?: VecXZ;
  clientTs: number;
}

// Projectile messages - Legacy interfaces removed

// Instant skill hit effect
export interface InstantHit extends ClientMsg {
  type: 'InstantHit';
  skillId: string;
  origin: { x: number; y: number; z: number };
  targetPos: { x: number; y: number; z: number };
  hitIds: string[];
  dmg?: number[];  // Damage values for each hit target
}

// Skill management
export interface LearnSkill extends ClientMsg {
  type: 'LearnSkill';
  skillId: SkillId;
}

export interface SetSkillShortcut extends ClientMsg {
  type: 'SetSkillShortcut';
  slotIndex: number;  // 0-8 for keys 1-9
  skillId: SkillId | null;  // null to clear the slot
}

export interface SkillLearned extends ClientMsg {
  type: 'SkillLearned';
  skillId: SkillId;
  remainingPoints: number;
}

export interface SkillShortcutUpdated extends ClientMsg {
  type: 'SkillShortcutUpdated';
  slotIndex: number;
  skillId: SkillId | null;
}

// Class system messages
export interface SelectClass extends ClientMsg {
  type: 'SelectClass';
  className: string;
}

export interface ClassSelected extends ClientMsg {
  type: 'ClassSelected';
  className: string;
  baseStats: {
    healthMultiplier: number;
    manaMultiplier: number;
    damageMultiplier: number;
    speedMultiplier: number;
  };
}

// Skill cast failure message
export interface CastFail extends ClientMsg {
  type: 'CastFail';
  clientSeq: number;
  reason: 'cooldown' | 'nomana' | 'invalid' | 'outofrange';
}

// Server-facing message base type
export interface ServerMsg extends ClientMsg {
  type: string;
}

// New additive messages - do NOT edit old ones
export interface CastSnapshotMsg extends ServerMsg {
  type: 'CastSnapshot';
  data: CastSnapshot;
}

export interface EffectSnapshotMsg extends ServerMsg {
  type: 'EffectSnapshot';
  targetId: string;
  effects: StatusEffect[];
}

export interface CombatLogMsg extends ServerMsg {
  type: 'CombatLog';
  castId: string;
  skillId: string;
  casterId: string;
  targets: string[];
  damages: number[];
}

export interface ProjHit2 extends ServerMsg {
  type: 'ProjHit2';
  castId: string;
  hitIds: string[];
  dmg: number[];   // Aligned with hitIds
  impactPos?: VecXZ; // Position of the projectile impact (optional for backwards compatibility)
}

export interface ProjSpawn2 extends ServerMsg {
  type: 'ProjSpawn2';
  castId: string;
  skillId: string;
  origin: Vec3D;
  dir: VecXZ;
  speed: number;
  launchTs: number;
  casterId: string;
  hitRadius?: number;
}

// Status effect messages
export interface EffectSnapshotMsg extends ServerMsg {
  type: 'EffectSnapshot';
  id: string;       // Entity ID
  src: string;      // Source entity ID
  effectId: string; // Effect type identifier
  stacks: number;   // Current stacks
  remainingMs: number; // Remaining duration in ms
  seed: number;     // RNG seed for deterministic calculations
}


// ==============================================================================
// FILE: shared/netConstants.ts
// ==============================================================================

export const CM_PER_UNIT = 100;
export const POS_MAX_DELTA_CM = 32767; // Maximum delta value for int16


// ==============================================================================
// FILE: shared/positionUtils.ts
// ==============================================================================

// filepath: /home/s/develop/projects/vibe/1/shared/positionUtils.ts
import { VecXZ } from './messages.js';

/**
 * Predicts the position of an entity at a given time based on its movement state
 * @param entity The entity with position and movement
 * @param timestamp The time to predict position for
 * @returns The predicted position at the given time
 */
export function predictPosition(entity: any, timestamp: number): VecXZ {
  if (!entity || !entity.position) {
    return { x: 0, z: 0 };
  }

  // If no movement or timestamp is in the past, return current position
  if (!entity.movement || 
      !entity.movement.startTime || 
      timestamp <= entity.movement.startTime) {
    return { 
      x: entity.position.x, 
      z: entity.position.z 
    };
  }

  // Calculate time elapsed since movement started
  const elapsedTimeSec = (timestamp - entity.movement.startTime) / 1000;
  
  // Calculate distance traveled
  const distanceTraveled = entity.movement.speed * elapsedTimeSec;
  
  // If no direction or speed is 0, return current position
  if (!entity.movement.dir || 
      entity.movement.speed === 0 || 
      (entity.movement.dir.x === 0 && entity.movement.dir.z === 0)) {
    return { 
      x: entity.position.x, 
      z: entity.position.z 
    };
  }
  
  // Calculate predicted position
  return {
    x: entity.position.x + entity.movement.dir.x * distanceTraveled,
    z: entity.position.z + entity.movement.dir.z * distanceTraveled
  };
}

/**
 * Calculate distance between two points in 2D space
 */
export function distance(a: VecXZ, b: VecXZ): number {
  const dx = a.x - b.x;
  const dz = a.z - b.z;
  return Math.sqrt(dx * dx + dz * dz);
}


// ==============================================================================
// FILE: shared/skillsDefinition.ts
// ==============================================================================

// Direct definitions without imports
export type SkillId = 'fireball'|'iceBolt'|'waterSplash'|'petrify';
export type SkillType = SkillId;   // export for compatibility
export type SkillCategory = 'projectile'|'instant'|'beam'|'aura';

export type SkillEffectType = 
  | 'damage' 
  | 'stun' 
  | 'slow' 
  | 'dot'    // damage over time
  | 'burn'   // burn damage over time
  | 'poison' // poison damage over time
  | 'waterWeakness' // increases water damage taken
  | 'freeze' 
  | 'transform'; // for stone conversion

export interface SkillEffect {
  type: SkillEffectType;
  value: number; // damage amount, stun duration, slow percentage, etc.
  durationMs?: number; // how long the effect lasts, in ms
}

export interface SkillDef {
  id: SkillId;
  name: string;
  description: string;
  icon: string; // Path to icon image
  cat: SkillCategory;
  manaCost: number;     // Mana cost for casting
  castMs: number;       // Time to cast in milliseconds
  cooldownMs: number;   // Cooldown time in milliseconds
  dmg?: number;
  range?: number;       // Maximum range from caster
  speed?: number;       // tiles/sec
  area?: number;        // tile radius
  levelRequired: number;
  effects: SkillEffect[];
  projectile?: { 
    speed: number;      // Speed of projectile in units per second
    maxRange?: number;  // Maximum travel distance 
    radius?: number;    // Collision radius
    pierce?: boolean;   // Can hit multiple targets
    splashRadius?: number; // Area of effect radius on impact
    hitRadius?: number;  // Explicit hit detection radius
    maxPierceHits?: number; // Maximum number of targets that can be hit with pierce
  };
}

// Define the SKILLS directly
export const SKILLS: Record<SkillId,SkillDef> = {
  fireball: {
    id: 'fireball',
    name: 'Fireball',
    description: 'Launches a ball of fire that deals damage and applies a burn effect',
    icon: '/skills/fireball.png',
    cat: 'projectile',
    manaCost: 20,
    castMs: 300,
    cooldownMs: 500,
    dmg: 150,
    range: 1800,
    speed: 22,
    levelRequired: 1,
    effects: [
      { type: 'damage', value: 150 },
      { type: 'burn', value: 1, durationMs: 5000 } // 5 seconds
    ],
    projectile: {
      speed: 22,
      pierce: false,
      hitRadius: 1.0
    }
  },
  iceBolt: {
    id: 'iceBolt',
    name: 'Ice Bolt',
    description: 'Fires a bolt of ice that poisons enemies and slows their movement',
    icon: '/skills/icebolt.png',
    cat: 'projectile',
    manaCost: 15,
    castMs: 500,
    cooldownMs: 3000,
    dmg: 30,
    range: 18,
    speed: 26,
    levelRequired: 3,
    effects: [
      { type: 'damage', value: 30 },
      { type: 'poison', value: 0.5, durationMs: 10000 }, // Poisons enemy for 0.5% damage for 10 seconds
      { type: 'slow', value: 50, durationMs: 10000 } // Slows enemy by 50% for 10 seconds
    ],
    projectile: {
      speed: 26,
      pierce: true,
      maxPierceHits: 2,
      hitRadius: 0.8
    }
  },
  waterSplash: {
    id: 'waterSplash',
    name: 'Water Splash',
    description: 'Creates a splash of water that damages enemies and slows them down',
    icon: '/skills/water.png',
    cat: 'projectile',
    manaCost: 25,
    castMs: 1500,
    cooldownMs: 8000,
    dmg: 20,
    range: 15,
    speed: 20,
    area: 3,
    levelRequired: 2,
    effects: [
      { type: 'damage', value: 20 },
      { type: 'waterWeakness', value: 30, durationMs: 5000 } // Makes enemy take 30% more damage from water attacks
    ],
    projectile: {
      speed: 20,
      pierce: false,
      splashRadius: 3,
      hitRadius: 1.2
    }
  },
  petrify: {
    id: 'petrify',
    name: 'Petrify',
    description: 'Temporarily stuns an enemy, preventing them from moving or attacking',
    icon: '/skills/petrify.png',
    cat: 'instant',
    manaCost: 40,
    castMs: 2000,
    cooldownMs: 15000,
    dmg: 10,
    range: 10,
    levelRequired: 4,
    effects: [
      { type: 'damage', value: 10 },
      { type: 'stun', value: 100, durationMs: 2000 } // Stuns enemy completely for 2 seconds
    ]
  }
};


// ==============================================================================
// FILE: shared/types.ts
// ==============================================================================

import { SkillId, SkillType } from './skillsDefinition';
import { CharacterClass } from './classSystem';

export enum CastState { Casting = 0, Traveling = 1, Impact = 2 }

export interface CastSnapshot {
  castId: string;
  casterId: string;
  skillId: SkillId;
  state: CastState;
  origin: VecXZ;
  target?: VecXZ;
  pos?: VecXZ;       // Current projectile position for authoritative trajectories
  dir?: VecXZ;       // Direction vector for traveling projectiles
  startedAt: number; // Timestamp
  castTimeMs: number; // Cast time from skill definition
}

export interface StatusEffect {
    id: string;
    type: string;
    value: number;
    durationMs: number;
    startTimeTs: number;
    sourceSkill: string;
}

export interface Enemy {
    id: string;
    type: string;
    name: string;
    level: number;
    position: { x: number; y: number; z: number };
    spawnPosition: { x: number; y: number; z: number };
    rotation: { x: number; y: number; z: number };
    health: number;
    maxHealth: number;
    isAlive: boolean;
    attackDamage: number;
    attackRange: number;
    baseExperienceValue: number;
    experienceValue: number;
    statusEffects: StatusEffect[];
    targetId?: string | null;
    markedForRemoval?: boolean;
    deathTimeTs?: number;
    attackCooldown?: boolean;
    posHistory?: { ts: number; x: number; z: number }[];  // Position history buffer similar to players
    lastUpdateTime?: number;  // Track last update time
}

// Intent-based movement messages
// These have been moved to shared/messages.ts
// Only keeping old interface definitions for backward compatibility during migration
import type { VecXZ, PlayerMovementState } from './messages';
export type { VecXZ, PlayerMovementState };

export interface MoveStartMsg {
    type: 'moveStart';
    id: string;            // playerId
    from: VecXZ;           // current server-accepted pos (xz only)
    to: VecXZ;             // destination clicked on ground
    speed: number;         // client's intended speed (u/s)
    ts: number;            // client epoch ms when click happened
}

export interface MoveStopMsg {
    type: 'moveStop';
    id: string;
    pos: VecXZ;            // here the client thinks he stopped
    ts: number;
}

// Update PlayerState with optional movement field and class data
export interface PlayerState {
    id: string;
    socketId: string;
    name: string;
    position: { x: number; y: number; z: number };
    rotation: { x: number; y: number; z: number };
    health: number;
    maxHealth: number;
    mana: number;
    maxMana: number;
    className: CharacterClass;
    unlockedSkills: SkillId[];     // All skills the player has learned
    skillShortcuts: (SkillId | null)[];  // Skills assigned to number keys 1-9
    availableSkillPoints: number;  // Points available to learn new skills
    skillCooldownEndTs: Record<string, number>;
    statusEffects: StatusEffect[];
    level: number;
    experience: number;
    experienceToNextLevel: number;
    castingSkill: SkillType | null;
    castingProgressMs: number;
    isAlive: boolean;
    deathTimeTs?: number;
    lastUpdateTime?: number;
    lastSnapTime?: number; // Track when the last position snapshot was sent
    movement?: PlayerMovementState;
    velocity?: { x: number; z: number };
    posHistory?: { ts: number; x: number; z: number }[]; // Position history for better hit detection
    stats?: {
        dmgMult?: number;
        critChance?: number;
        critMult?: number;
    };
}


// ==============================================================================
// FILE: shared/zoneSystem.ts
// ==============================================================================


// Types for zone management
export interface Zone {
    id: string;
    name: string;
    description: string;
    position: { x: number; y: number; z: number };
    radius: number;
    minLevel: number;
    maxLevel: number;
    mobs: {
        type: string;
        weight: number;
        minCount: number;
        maxCount: number;
    }[];
}

export interface MobSpawnConfig {
    type: string;
    count: number;
}

export class ZoneManager {
    getZoneAtPosition(position: { x: number; y: number; z: number }): Zone | null {
        for (const zone of GAME_ZONES) {
            const dx = position.x - zone.position.x;
            const dz = position.z - zone.position.z;
            const distanceSquared = dx * dx + dz * dz;
            
            if (distanceSquared <= zone.radius * zone.radius) {
                return zone;
            }
        }
        return null;
    }

    getMobsToSpawn(zoneId: string): MobSpawnConfig[] {
        const zone = GAME_ZONES.find(z => z.id === zoneId);
        if (!zone) return [];

        return zone.mobs.map(mobConfig => {
            const count = Math.floor(
                Math.random() * (mobConfig.maxCount - mobConfig.minCount + 1) + 
                mobConfig.minCount
            );
            return {
                type: mobConfig.type,
                count
            };
        });
    }

    getRandomPositionInZone(zoneId: string): { x: number; y: number; z: number } | null {
        const zone = GAME_ZONES.find(z => z.id === zoneId);
        if (!zone) return null;

        // Get a random angle and distance within the zone's radius
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.sqrt(Math.random()) * zone.radius;

        return {
            x: zone.position.x + Math.cos(angle) * distance,
            y: 0.5, // Slightly above ground
            z: zone.position.z + Math.sin(angle) * distance
        };
    }

    getMobLevel(zoneId: string): number {
        const zone = GAME_ZONES.find(z => z.id === zoneId);
        if (!zone) return 1;

        return Math.floor(
            Math.random() * (zone.maxLevel - zone.minLevel + 1) + 
            zone.minLevel
        );
    }
    
    /**
     * Get all available game zones
     * @returns Array of all zones
     */
    getZones(): Zone[] {
        return GAME_ZONES;
    }
}

export const GAME_ZONES: Zone[] = [
    {
        id: 'starter_meadow',
        name: 'Peaceful Meadows',
        description: 'A tranquil starting area with gentle slopes and scattered trees',
        position: { x: 0, y: 0, z: 0 },
        radius: 100,
        minLevel: 1,
        maxLevel: 3,
        mobs: [
            { type: 'goblin', weight: 70, minCount: 5, maxCount: 8 },
            { type: 'wolf', weight: 30, minCount: 2, maxCount: 4 }
        ]
    },
    {
        id: 'dark_forest',
        name: 'Dark Forest',
        description: 'A dense forest with challenging enemies',
        position: { x: 200, y: 0, z: 200 },
        radius: 150,
        minLevel: 3,
        maxLevel: 5,
        mobs: [
            { type: 'wolf', weight: 40, minCount: 4, maxCount: 8 },
            { type: 'skeleton', weight: 60, minCount: 3, maxCount: 6 }
        ]
    }
];
